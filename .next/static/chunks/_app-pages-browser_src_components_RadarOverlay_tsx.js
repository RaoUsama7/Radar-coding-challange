/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_components_RadarOverlay_tsx"],{

/***/ "?b5cf":
/*!**********************!*\
  !*** http (ignored) ***!
  \**********************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "?69f2":
/*!***********************!*\
  !*** https (ignored) ***!
  \***********************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "?5a99":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fflate/esm/browser.js":
/*!********************************************!*\
  !*** ./node_modules/fflate/esm/browser.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCompress: function() { return /* binding */ AsyncGzip; },\n/* harmony export */   AsyncDecompress: function() { return /* binding */ AsyncDecompress; },\n/* harmony export */   AsyncDeflate: function() { return /* binding */ AsyncDeflate; },\n/* harmony export */   AsyncGunzip: function() { return /* binding */ AsyncGunzip; },\n/* harmony export */   AsyncGzip: function() { return /* binding */ AsyncGzip; },\n/* harmony export */   AsyncInflate: function() { return /* binding */ AsyncInflate; },\n/* harmony export */   AsyncUnzipInflate: function() { return /* binding */ AsyncUnzipInflate; },\n/* harmony export */   AsyncUnzlib: function() { return /* binding */ AsyncUnzlib; },\n/* harmony export */   AsyncZipDeflate: function() { return /* binding */ AsyncZipDeflate; },\n/* harmony export */   AsyncZlib: function() { return /* binding */ AsyncZlib; },\n/* harmony export */   Compress: function() { return /* binding */ Gzip; },\n/* harmony export */   DecodeUTF8: function() { return /* binding */ DecodeUTF8; },\n/* harmony export */   Decompress: function() { return /* binding */ Decompress; },\n/* harmony export */   Deflate: function() { return /* binding */ Deflate; },\n/* harmony export */   EncodeUTF8: function() { return /* binding */ EncodeUTF8; },\n/* harmony export */   FlateErrorCode: function() { return /* binding */ FlateErrorCode; },\n/* harmony export */   Gunzip: function() { return /* binding */ Gunzip; },\n/* harmony export */   Gzip: function() { return /* binding */ Gzip; },\n/* harmony export */   Inflate: function() { return /* binding */ Inflate; },\n/* harmony export */   Unzip: function() { return /* binding */ Unzip; },\n/* harmony export */   UnzipInflate: function() { return /* binding */ UnzipInflate; },\n/* harmony export */   UnzipPassThrough: function() { return /* binding */ UnzipPassThrough; },\n/* harmony export */   Unzlib: function() { return /* binding */ Unzlib; },\n/* harmony export */   Zip: function() { return /* binding */ Zip; },\n/* harmony export */   ZipDeflate: function() { return /* binding */ ZipDeflate; },\n/* harmony export */   ZipPassThrough: function() { return /* binding */ ZipPassThrough; },\n/* harmony export */   Zlib: function() { return /* binding */ Zlib; },\n/* harmony export */   compress: function() { return /* binding */ gzip; },\n/* harmony export */   compressSync: function() { return /* binding */ gzipSync; },\n/* harmony export */   decompress: function() { return /* binding */ decompress; },\n/* harmony export */   decompressSync: function() { return /* binding */ decompressSync; },\n/* harmony export */   deflate: function() { return /* binding */ deflate; },\n/* harmony export */   deflateSync: function() { return /* binding */ deflateSync; },\n/* harmony export */   gunzip: function() { return /* binding */ gunzip; },\n/* harmony export */   gunzipSync: function() { return /* binding */ gunzipSync; },\n/* harmony export */   gzip: function() { return /* binding */ gzip; },\n/* harmony export */   gzipSync: function() { return /* binding */ gzipSync; },\n/* harmony export */   inflate: function() { return /* binding */ inflate; },\n/* harmony export */   inflateSync: function() { return /* binding */ inflateSync; },\n/* harmony export */   strFromU8: function() { return /* binding */ strFromU8; },\n/* harmony export */   strToU8: function() { return /* binding */ strToU8; },\n/* harmony export */   unzip: function() { return /* binding */ unzip; },\n/* harmony export */   unzipSync: function() { return /* binding */ unzipSync; },\n/* harmony export */   unzlib: function() { return /* binding */ unzlib; },\n/* harmony export */   unzlibSync: function() { return /* binding */ unzlibSync; },\n/* harmony export */   zip: function() { return /* binding */ zip; },\n/* harmony export */   zipSync: function() { return /* binding */ zipSync; },\n/* harmony export */   zlib: function() { return /* binding */ zlib; },\n/* harmony export */   zlibSync: function() { return /* binding */ zlibSync; }\n/* harmony export */ });\n// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\n        c + ';addEventListener(\"error\",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'\n    ], { type: 'text/javascript' }))));\n    w.onmessage = function (e) {\n        var d = e.data, ed = d.$e$;\n        if (ed) {\n            var err = new Error(ed[0]);\n            err['code'] = ed[1];\n            err.stack = ed[2];\n            cb(err, null);\n        }\n        else\n            cb(null, d);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new i32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return { b: b, r: r };\n};\nvar _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b.b, revfd = _b.r;\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >> 8) | ((x & 0x00FF) << 8)) >> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i) {\n        if (cd[i])\n            ++l[cd[i] - 1];\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 1; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p + 7) / 8) | 0; };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    return new u8(v.subarray(s, e));\n};\n/**\n * Codes for errors generated within this library\n */\nvar FlateErrorCode = {\n    UnexpectedEOF: 0,\n    InvalidBlockType: 1,\n    InvalidLengthLiteral: 2,\n    InvalidDistance: 3,\n    StreamFinished: 4,\n    NoStreamHandler: 5,\n    InvalidHeader: 6,\n    NoCallback: 7,\n    InvalidUTF8: 8,\n    ExtraFieldTooLong: 9,\n    InvalidDate: 10,\n    FilenameTooLong: 11,\n    StreamFinishing: 12,\n    InvalidZipData: 13,\n    UnknownCompressionMethod: 14\n};\n// error codes\nvar ec = [\n    'unexpected EOF',\n    'invalid block type',\n    'invalid length/literal',\n    'invalid distance',\n    'stream finished',\n    'no stream handler',\n    ,\n    'no callback',\n    'invalid UTF-8 data',\n    'extra field too long',\n    'date not in range 1980-2099',\n    'filename too long',\n    'stream finishing',\n    'invalid zip data'\n    // determined by unknown compression method\n];\n;\nvar err = function (ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n        Error.captureStackTrace(e, err);\n    if (!nt)\n        throw e;\n    return e;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, st, buf, dict) {\n    // source length       dict length\n    var sl = dat.length, dl = dict ? dict.length : 0;\n    if (!sl || st.f && !st.l)\n        return buf || new u8(0);\n    var noBuf = !buf;\n    // have to estimate size\n    var resize = noBuf || st.i != 2;\n    // no state\n    var noSt = st.i;\n    // Assumes roughly 33% compression ratio average\n    if (noBuf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                // ensure size\n                if (resize)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                err(1);\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17\n        if (resize)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n            if (!c)\n                err(2);\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n                if (!d)\n                    err(3);\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                if (resize)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                if (bt < dt) {\n                    var shift = dl - dt, dend = Math.min(dt, end);\n                    if (shift + bt < 0)\n                        err(3);\n                    for (; bt < dend; ++bt)\n                        buf[bt] = dict[shift + bt];\n                }\n                for (; bt < end; ++bt)\n                    buf[bt] = buf[bt - dt];\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    // don't reallocate for streams or user buffers\n    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n    d[o + 2] |= v >> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return { t: et, l: 0 };\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return { t: v, l: 1 };\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return { t: new u8(tr), l: mbt };\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return { c: cl.subarray(0, cli), n: s };\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a.t, mlb = _a.l;\n    var _b = hTree(df, 15), ddt = _b.t, mdb = _b.l;\n    var _c = lc(dlt), lclt = _c.c, nlc = _c.n;\n    var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        ++lcfreq[lclt[i] & 31];\n    for (var i = 0; i < lcdt.length; ++i)\n        ++lcfreq[lcdt[i] & 31];\n    var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];\n    if (bs >= 0 && flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >> 5) & 127), p += clct[i] >> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        var sym = syms[i];\n        if (sym > 255) {\n            var len = (sym >> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (sym >> 23) & 31), p += fleb[len];\n            var dst = sym & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (sym >> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[sym]), p += ll[sym];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, st) {\n    var s = st.z || dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var lst = st.l;\n    var pos = (st.r || 0) & 7;\n    if (lvl) {\n        if (pos)\n            w[0] = st.r >> 3;\n        var opt = deo[lvl - 1];\n        var n = opt >> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new i32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index          l/lind  waitdx          blkpos\n        var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;\n        for (; i + 2 < s; ++i) {\n            // hash value\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && (rem > 423 || !lst)) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = i - dif + j & 32767;\n                                    var pti = prev[ti];\n                                    var cd = ti - pti & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += imod - pimod & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one int32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        for (i = Math.max(i, wi); i < s; ++i) {\n            syms[li++] = dat[i];\n            ++lf[dat[i]];\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        if (!lst) {\n            st.r = (pos & 7) | w[(pos / 8) | 0] << 3;\n            // shft(pos) now 1 less if pos & 7 != 0\n            pos -= 7;\n            st.h = head, st.p = prev, st.i = i, st.w = wi;\n        }\n    }\n    else {\n        for (var i = st.w || 0; i < s + lst; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e >= s) {\n                // write final block\n                w[(pos / 8) | 0] = lst;\n                e = s;\n            }\n            pos = wfblk(w, pos + 1, dat.subarray(i, e));\n        }\n        st.i = s;\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Adler32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length | 0;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a & 0xFF00) << 8 | (b & 255) << 8 | (b >> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    if (!st) {\n        st = { l: 1 };\n        if (opt.dictionary) {\n            var dict = opt.dictionary.subarray(-32768);\n            var newDat = new u8(dict.length + dat.length);\n            newDat.set(dict);\n            newDat.set(dat, dict.length);\n            dat = newDat;\n            st.w = dict.length;\n        }\n    }\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? (st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20) : (12 + opt.mem), pre, post, st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\\s+/g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return fnStr;\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k].buffer) {\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n        }\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            fnStr = wcln(fns[i], fnStr, td_1);\n        ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };\n    }\n    var td = mrg({}, ch[id].e);\n    return wk(ch[id].c + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt]; };\nvar bDflt = function () { return [u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zls]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get opts\nvar gopt = function (o) { return o && {\n    out: o.size && new u8(o.size),\n    dictionary: o.dictionary\n}; };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) {\n        if (ev.data.length) {\n            strm.push(ev.data[0], ev.data[1]);\n            postMessage([ev.data[0].length]);\n        }\n        else\n            strm.flush();\n    };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id, flush, ext) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else if (!Array.isArray(dat))\n            ext(dat);\n        else if (dat.length == 1) {\n            strm.queuedSize -= dat[0];\n            if (strm.ondrain)\n                strm.ondrain(dat[0]);\n        }\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.queuedSize = 0;\n    strm.push = function (d, f) {\n        if (!strm.ondata)\n            err(5);\n        if (t)\n            strm.ondata(err(4, 0, 1), null, !!f);\n        strm.queuedSize += d.length;\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n    if (flush) {\n        strm.flush = function () { w.postMessage([]); };\n    }\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        err(6, 'invalid gzip data');\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += (d[10] | d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + (o.filename ? o.filename.length + 1 : 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (o.dictionary && 32);\n    c[1] |= 31 - ((c[0] << 8) | c[1]) % 31;\n    if (o.dictionary) {\n        var h = adler();\n        h.p(o.dictionary);\n        wbytes(c, 2, h.d());\n    }\n};\n// zlib start\nvar zls = function (d, dict) {\n    if ((d[0] & 15) != 8 || (d[0] >> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        err(6, 'invalid zlib data');\n    if ((d[1] >> 5 & 1) == +!dict)\n        err(6, 'invalid zlib data: ' + (d[1] & 32 ? 'need' : 'unexpected') + ' dictionary');\n    return (d[1] >> 3 & 4) + 2;\n};\nfunction StrmOpt(opts, cb) {\n    if (typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n        this.s = { l: 0, i: 32768, w: 32768, z: 32768 };\n        // Buffer length must always be 0 mod 32768 for index calculations to be correct when modifying head and prev\n        // 98304 = 32768 (lookback) + 65536 (common chunk size)\n        this.b = new u8(98304);\n        if (this.o.dictionary) {\n            var dict = this.o.dictionary.subarray(-32768);\n            this.b.set(dict, 32768 - dict.length);\n            this.s.i = 32768 - dict.length;\n        }\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, this.s), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.s.l)\n            err(4);\n        var endLen = chunk.length + this.s.z;\n        if (endLen > this.b.length) {\n            if (endLen > 2 * this.b.length - 32768) {\n                var newBuf = new u8(endLen & -32768);\n                newBuf.set(this.b.subarray(0, this.s.z));\n                this.b = newBuf;\n            }\n            var split = this.b.length - this.s.z;\n            this.b.set(chunk.subarray(0, split), this.s.z);\n            this.s.z = this.b.length;\n            this.p(this.b, false);\n            this.b.set(this.b.subarray(-32768));\n            this.b.set(chunk.subarray(split), 32768);\n            this.s.z = chunk.length - split + 32768;\n            this.s.i = 32766, this.s.w = 32768;\n        }\n        else {\n            this.b.set(chunk, this.s.z);\n            this.s.z += chunk.length;\n        }\n        this.s.l = final & 1;\n        if (this.s.z > this.s.w + 8191 || final) {\n            this.p(this.b, final || false);\n            this.s.w = this.s.i, this.s.i -= 2;\n        }\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * deflated output for small inputs.\n     */\n    Deflate.prototype.flush = function () {\n        if (!this.ondata)\n            err(5);\n        if (this.s.l)\n            err(4);\n        this.p(this.b, false);\n        this.s.w = this.s.i, this.s.i -= 2;\n    };\n    return Deflate;\n}());\n\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6, 1);\n    }\n    return AsyncDeflate;\n}());\n\nfunction deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nfunction deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    function Inflate(opts, cb) {\n        // no StrmOpt here to avoid adding to workerizer\n        if (typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);\n        this.s = { i: 0, b: dict ? dict.length : 0 };\n        this.o = new u8(32768);\n        this.p = new u8(0);\n        if (dict)\n            this.o.set(dict);\n    }\n    Inflate.prototype.e = function (c) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        if (!this.p.length)\n            this.p = c;\n        else if (c.length) {\n            var n = new u8(this.p.length + c.length);\n            n.set(this.p), n.set(c, this.p.length), this.p = n;\n        }\n    };\n    Inflate.prototype.c = function (final) {\n        this.s.i = +(this.d = final || false);\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.s, this.o);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\n\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    function AsyncInflate(opts, cb) {\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Inflate(ev.data);\n            onmessage = astrm(strm);\n        }, 7, 0);\n    }\n    return AsyncInflate;\n}());\n\nfunction inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gopt(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nfunction inflateSync(data, opts) {\n    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        this.c.p(chunk);\n        this.l += chunk.length;\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, this.s);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * GZIPped output for small inputs.\n     */\n    Gzip.prototype.flush = function () {\n        Deflate.prototype.flush.call(this);\n    };\n    return Gzip;\n}());\n\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8, 1);\n    }\n    return AsyncGzip;\n}());\n\nfunction gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nfunction gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming single or multi-member GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    function Gunzip(opts, cb) {\n        this.v = 1;\n        this.r = 0;\n        Inflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        this.r += chunk.length;\n        if (this.v) {\n            var p = this.p.subarray(this.v - 1);\n            var s = p.length > 3 ? gzs(p) : 4;\n            if (s > p.length) {\n                if (!final)\n                    return;\n            }\n            else if (this.v > 1 && this.onmember) {\n                this.onmember(this.r - p.length);\n            }\n            this.p = p.subarray(s), this.v = 0;\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n        // process concatenated GZIP\n        if (this.s.f && !this.s.l && !final) {\n            this.v = shft(this.s.p) + 9;\n            this.s = { i: 0 };\n            this.o = new u8(0);\n            this.push(new u8(0), final);\n        }\n    };\n    return Gunzip;\n}());\n\n/**\n * Asynchronous streaming single or multi-member GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    function AsyncGunzip(opts, cb) {\n        var _this = this;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Gunzip(ev.data);\n            strm.onmember = function (offset) { return postMessage(offset); };\n            onmessage = astrm(strm);\n        }, 9, 0, function (offset) { return _this.onmember && _this.onmember(offset); });\n    }\n    return AsyncGunzip;\n}());\n\nfunction gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0], ev.data[1])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nfunction gunzipSync(data, opts) {\n    var st = gzs(data);\n    if (st + 8 > data.length)\n        err(6, 'invalid gzip data');\n    return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        this.c.p(chunk);\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f && 4, this.s);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * zlibbed output for small inputs.\n     */\n    Zlib.prototype.flush = function () {\n        Deflate.prototype.flush.call(this);\n    };\n    return Zlib;\n}());\n\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10, 1);\n    }\n    return AsyncZlib;\n}());\n\nfunction zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nfunction zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, opts.dictionary ? 6 : 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    function Unzlib(opts, cb) {\n        Inflate.call(this, opts, cb);\n        this.v = opts && opts.dictionary ? 2 : 1;\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 6 && !final)\n                return;\n            this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                err(6, 'invalid zlib data');\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\n\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    function AsyncUnzlib(opts, cb) {\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Unzlib(ev.data);\n            onmessage = astrm(strm);\n        }, 11, 0);\n    }\n    return AsyncUnzlib;\n}());\n\nfunction unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gopt(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nfunction unzlibSync(data, opts) {\n    return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\n\n\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    function Decompress(opts, cb) {\n        this.o = StrmOpt.call(this, opts, cb) || {};\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n    }\n    // init substream\n    // overriden by AsyncDecompress\n    Decompress.prototype.i = function () {\n        var _this = this;\n        this.s.ondata = function (dat, final) {\n            _this.ondata(dat, final);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(this.o)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(this.o)\n                        : new this.Z(this.o);\n                this.i();\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\n\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    function AsyncDecompress(opts, cb) {\n        Decompress.call(this, opts, cb);\n        this.queuedSize = 0;\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n    }\n    AsyncDecompress.prototype.i = function () {\n        var _this = this;\n        this.s.ondata = function (err, dat, final) {\n            _this.ondata(err, dat, final);\n        };\n        this.s.ondrain = function (size) {\n            _this.queuedSize -= size;\n            if (_this.ondrain)\n                _this.ondrain(size);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        this.queuedSize += chunk.length;\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\n\nfunction decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nfunction decompressSync(data, opts) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, opts)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, opts)\n            : unzlibSync(data, opts);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k, op = o;\n        if (Array.isArray(val))\n            op = mrg(o, val[1]), val = val[0];\n        if (val instanceof u8)\n            t[n] = [val, op];\n        else {\n            t[n += '/'] = [new u8(0), op];\n            fltn(val, n, t, o);\n        }\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return { s: r, r: slc(d, i - 1) };\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    err(8);\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            err(4);\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (final) {\n            if (r.length)\n                err(8);\n            this.p = null;\n        }\n        else\n            this.p = r;\n        this.ondata(s, final);\n    };\n    return DecodeUTF8;\n}());\n\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\n\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nfunction strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nfunction strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td) {\n        return td.decode(dat);\n    }\n    else {\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (r.length)\n            err(8);\n        return s;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                err(9);\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c < 0 && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        err(10);\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >> 1)), b += 4;\n    if (c != -1) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c < 0 ? -c - 2 : c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\n\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\n\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\n\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this = this;\n        if (!this.ondata)\n            err(5);\n        // finishing or finished\n        if (this.d & 2)\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);\n        else {\n            var f = strToU8(file.filename), fl_1 = f.length;\n            var com = file.comment, o = com && strToU8(com);\n            var u = fl_1 != file.filename.length || (o && (com.length != o.length));\n            var hl_1 = fl_1 + exfl(file.extra) + 30;\n            if (fl_1 > 65535)\n                this.ondata(err(11, 0, 1), null, false);\n            var header = new u8(hl_1);\n            wzh(header, 0, file, f, u, -1);\n            var chks_1 = [header];\n            var pAll_1 = function () {\n                for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {\n                    var chk = chks_2[_i];\n                    _this.ondata(null, chk, false);\n                }\n                chks_1 = [];\n            };\n            var tr_1 = this.d;\n            this.d = 0;\n            var ind_1 = this.u.length;\n            var uf_1 = mrg(file, {\n                f: f,\n                u: u,\n                o: o,\n                t: function () {\n                    if (file.terminate)\n                        file.terminate();\n                },\n                r: function () {\n                    pAll_1();\n                    if (tr_1) {\n                        var nxt = _this.u[ind_1 + 1];\n                        if (nxt)\n                            nxt.r();\n                        else\n                            _this.d = 1;\n                    }\n                    tr_1 = 1;\n                }\n            });\n            var cl_1 = 0;\n            file.ondata = function (err, dat, final) {\n                if (err) {\n                    _this.ondata(err, dat, final);\n                    _this.terminate();\n                }\n                else {\n                    cl_1 += dat.length;\n                    chks_1.push(dat);\n                    if (final) {\n                        var dd = new u8(16);\n                        wbytes(dd, 0, 0x8074B50);\n                        wbytes(dd, 4, file.crc);\n                        wbytes(dd, 8, cl_1);\n                        wbytes(dd, 12, file.size);\n                        chks_1.push(dd);\n                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;\n                        if (tr_1)\n                            uf_1.r();\n                        tr_1 = 1;\n                    }\n                    else if (tr_1)\n                        pAll_1();\n                }\n            };\n            this.u.push(uf_1);\n        }\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this = this;\n        if (this.d & 2) {\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);\n            return;\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this.d & 1))\n                        return;\n                    _this.u.splice(-1, 1);\n                    _this.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\n\nfunction zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cbd(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cbd(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cbd(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl(err(11, 0, 1), null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nfunction zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            err(11);\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\n\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this = this;\n        this.i = new Inflate(function (dat, final) {\n            _this.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\n\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\n\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this = this;\n        if (!this.onfile)\n            err(5);\n        if (!this.p)\n            err(4);\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_3 = [];\n                        this_1.k.unshift(chks_3);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    err(5);\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this.o[cmp_1];\n                                    if (!ctr)\n                                        file_1.ondata(err(14, 'unknown compression type ' + cmp_1, 1), null, false);\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {\n                                        var dat = chks_4[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this.k[0] == chks_3 && _this.c)\n                                        _this.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                err(13);\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\n\nvar mt = typeof queueMicrotask == 'function' ? queueMicrotask : typeof setTimeout == 'function' ? setTimeout : function (fn) { fn(); };\nfunction unzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cbd(err(13, 0, 1), null);\n            return tAll;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (lft) {\n        var c = lft;\n        var o = b4(data, e + 16);\n        var z = o == 4294967295 || c == 65535;\n        if (z) {\n            var ze = b4(data, e - 12);\n            z = b4(data, ze) == 0x6064B50;\n            if (z) {\n                c = lft = b4(data, ze + 32);\n                o = b4(data, ze + 48);\n            }\n        }\n        var fltr = opts && opts.filter;\n        var _loop_3 = function (i) {\n            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n            o = no;\n            var cbl = function (e, d) {\n                if (e) {\n                    tAll();\n                    cbd(e, null);\n                }\n                else {\n                    if (d)\n                        files[fn] = d;\n                    if (!--lft)\n                        cbd(null, files);\n                }\n            };\n            if (!fltr || fltr({\n                name: fn,\n                size: sc,\n                originalSize: su,\n                compression: c_1\n            })) {\n                if (!c_1)\n                    cbl(null, slc(data, b, b + sc));\n                else if (c_1 == 8) {\n                    var infl = data.subarray(b, b + sc);\n                    // Synchronously decompress under 512KB, or barely-compressed data\n                    if (su < 524288 || sc > 0.8 * su) {\n                        try {\n                            cbl(null, inflateSync(infl, { out: new u8(su) }));\n                        }\n                        catch (e) {\n                            cbl(e, null);\n                        }\n                    }\n                    else\n                        term.push(inflate(infl, { size: su }, cbl));\n                }\n                else\n                    cbl(err(14, 'unknown compression type ' + c_1, 1), null);\n            }\n            else\n                cbl(null, null);\n        };\n        for (var i = 0; i < c; ++i) {\n            _loop_3(i);\n        }\n    }\n    else\n        cbd(null, {});\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @param opts The ZIP extraction options\n * @returns The decompressed files\n */\nfunction unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            err(13);\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 0x6064B50;\n        if (z) {\n            c = b4(data, ze + 32);\n            o = b4(data, ze + 48);\n        }\n    }\n    var fltr = opts && opts.filter;\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!fltr || fltr({\n            name: fn,\n            size: sc,\n            originalSize: su,\n            compression: c_2\n        })) {\n            if (!c_2)\n                files[fn] = slc(data, b, b + sc);\n            else if (c_2 == 8)\n                files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });\n            else\n                err(14, 'unknown compression type ' + c_2);\n        }\n    }\n    return files;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mZmxhdGUvZXNtL2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQ0FBcUMsVUFBVSxhQUFhLCtCQUErQixFQUFFO0FBQzNHLFNBQVMseUJBQXlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QiwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ3NCO0FBQ2hCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsdUJBQXVCLHVEQUF1RDtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsMEVBQTBFLE1BQU07QUFDaEY7QUFDQTtBQUN3RDtBQUNGO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDcUI7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDMEI7QUFDcEI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNxQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ3FCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ3lCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FB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QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUMyQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDdUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUM0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RSxzRUFBc0Usb0JBQW9CO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNnQjtBQUNqQiwrSEFBK0g7QUFDeEg7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVc7QUFDcEM7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGlCQUFpQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsVUFBVTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxpQkFBaUI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mZmxhdGUvZXNtL2Jyb3dzZXIuanM/MTQ0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBERUZMQVRFIGlzIGEgY29tcGxleCBmb3JtYXQ7IHRvIHJlYWQgdGhpcyBjb2RlLCB5b3Ugc2hvdWxkIHByb2JhYmx5IGNoZWNrIHRoZSBSRkMgZmlyc3Q6XG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMTk1MVxuLy8gWW91IG1heSBhbHNvIHdpc2ggdG8gdGFrZSBhIGxvb2sgYXQgdGhlIGd1aWRlIEkgbWFkZSBhYm91dCB0aGlzIHByb2dyYW06XG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xMDFhcnJvd3ovMjUzZjMxZWI1YWJjM2Q5Mjc1YWI5NDMwMDNmZmVjYWRcbi8vIFNvbWUgb2YgdGhlIGZvbGxvd2luZyBjb2RlIGlzIHNpbWlsYXIgdG8gdGhhdCBvZiBVWklQLmpzOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvcGVhL1VaSVAuanNcbi8vIEhvd2V2ZXIsIHRoZSB2YXN0IG1ham9yaXR5IG9mIHRoZSBjb2RlYmFzZSBoYXMgZGl2ZXJnZWQgZnJvbSBVWklQLmpzIHRvIGluY3JlYXNlIHBlcmZvcm1hbmNlIGFuZCByZWR1Y2UgYnVuZGxlIHNpemUuXG4vLyBTb21ldGltZXMgMCB3aWxsIGFwcGVhciB3aGVyZSAtMSB3b3VsZCBiZSBtb3JlIGFwcHJvcHJpYXRlLiBUaGlzIGlzIGJlY2F1c2UgdXNpbmcgYSB1aW50XG4vLyBpcyBiZXR0ZXIgZm9yIG1lbW9yeSBpbiBtb3N0IGVuZ2luZXMgKEkgKnRoaW5rKikuXG52YXIgY2gyID0ge307XG52YXIgd2sgPSAoZnVuY3Rpb24gKGMsIGlkLCBtc2csIHRyYW5zZmVyLCBjYikge1xuICAgIHZhciB3ID0gbmV3IFdvcmtlcihjaDJbaWRdIHx8IChjaDJbaWRdID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbXG4gICAgICAgIGMgKyAnO2FkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLGZ1bmN0aW9uKGUpe2U9ZS5lcnJvcjtwb3N0TWVzc2FnZSh7JGUkOltlLm1lc3NhZ2UsZS5jb2RlLGUuc3RhY2tdfSl9KSdcbiAgICBdLCB7IHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnIH0pKSkpO1xuICAgIHcub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGQgPSBlLmRhdGEsIGVkID0gZC4kZSQ7XG4gICAgICAgIGlmIChlZCkge1xuICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihlZFswXSk7XG4gICAgICAgICAgICBlcnJbJ2NvZGUnXSA9IGVkWzFdO1xuICAgICAgICAgICAgZXJyLnN0YWNrID0gZWRbMl07XG4gICAgICAgICAgICBjYihlcnIsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNiKG51bGwsIGQpO1xuICAgIH07XG4gICAgdy5wb3N0TWVzc2FnZShtc2csIHRyYW5zZmVyKTtcbiAgICByZXR1cm4gdztcbn0pO1xuXG4vLyBhbGlhc2VzIGZvciBzaG9ydGVyIGNvbXByZXNzZWQgY29kZSAobW9zdCBtaW5pZmVycyBkb24ndCBkbyB0aGlzKVxudmFyIHU4ID0gVWludDhBcnJheSwgdTE2ID0gVWludDE2QXJyYXksIGkzMiA9IEludDMyQXJyYXk7XG4vLyBmaXhlZCBsZW5ndGggZXh0cmEgYml0c1xudmFyIGZsZWIgPSBuZXcgdTgoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDEsIDEsIDEsIDEsIDIsIDIsIDIsIDIsIDMsIDMsIDMsIDMsIDQsIDQsIDQsIDQsIDUsIDUsIDUsIDUsIDAsIC8qIHVudXNlZCAqLyAwLCAwLCAvKiBpbXBvc3NpYmxlICovIDBdKTtcbi8vIGZpeGVkIGRpc3RhbmNlIGV4dHJhIGJpdHNcbnZhciBmZGViID0gbmV3IHU4KFswLCAwLCAwLCAwLCAxLCAxLCAyLCAyLCAzLCAzLCA0LCA0LCA1LCA1LCA2LCA2LCA3LCA3LCA4LCA4LCA5LCA5LCAxMCwgMTAsIDExLCAxMSwgMTIsIDEyLCAxMywgMTMsIC8qIHVudXNlZCAqLyAwLCAwXSk7XG4vLyBjb2RlIGxlbmd0aCBpbmRleCBtYXBcbnZhciBjbGltID0gbmV3IHU4KFsxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1XSk7XG4vLyBnZXQgYmFzZSwgcmV2ZXJzZSBpbmRleCBtYXAgZnJvbSBleHRyYSBiaXRzXG52YXIgZnJlYiA9IGZ1bmN0aW9uIChlYiwgc3RhcnQpIHtcbiAgICB2YXIgYiA9IG5ldyB1MTYoMzEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzE7ICsraSkge1xuICAgICAgICBiW2ldID0gc3RhcnQgKz0gMSA8PCBlYltpIC0gMV07XG4gICAgfVxuICAgIC8vIG51bWJlcnMgaGVyZSBhcmUgYXQgbWF4IDE4IGJpdHNcbiAgICB2YXIgciA9IG5ldyBpMzIoYlszMF0pO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgMzA7ICsraSkge1xuICAgICAgICBmb3IgKHZhciBqID0gYltpXTsgaiA8IGJbaSArIDFdOyArK2opIHtcbiAgICAgICAgICAgIHJbal0gPSAoKGogLSBiW2ldKSA8PCA1KSB8IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYjogYiwgcjogciB9O1xufTtcbnZhciBfYSA9IGZyZWIoZmxlYiwgMiksIGZsID0gX2EuYiwgcmV2ZmwgPSBfYS5yO1xuLy8gd2UgY2FuIGlnbm9yZSB0aGUgZmFjdCB0aGF0IHRoZSBvdGhlciBudW1iZXJzIGFyZSB3cm9uZzsgdGhleSBuZXZlciBoYXBwZW4gYW55d2F5XG5mbFsyOF0gPSAyNTgsIHJldmZsWzI1OF0gPSAyODtcbnZhciBfYiA9IGZyZWIoZmRlYiwgMCksIGZkID0gX2IuYiwgcmV2ZmQgPSBfYi5yO1xuLy8gbWFwIG9mIHZhbHVlIHRvIHJldmVyc2UgKGFzc3VtaW5nIDE2IGJpdHMpXG52YXIgcmV2ID0gbmV3IHUxNigzMjc2OCk7XG5mb3IgKHZhciBpID0gMDsgaSA8IDMyNzY4OyArK2kpIHtcbiAgICAvLyByZXZlcnNlIHRhYmxlIGFsZ29yaXRobSBmcm9tIFNPXG4gICAgdmFyIHggPSAoKGkgJiAweEFBQUEpID4+IDEpIHwgKChpICYgMHg1NTU1KSA8PCAxKTtcbiAgICB4ID0gKCh4ICYgMHhDQ0NDKSA+PiAyKSB8ICgoeCAmIDB4MzMzMykgPDwgMik7XG4gICAgeCA9ICgoeCAmIDB4RjBGMCkgPj4gNCkgfCAoKHggJiAweDBGMEYpIDw8IDQpO1xuICAgIHJldltpXSA9ICgoKHggJiAweEZGMDApID4+IDgpIHwgKCh4ICYgMHgwMEZGKSA8PCA4KSkgPj4gMTtcbn1cbi8vIGNyZWF0ZSBodWZmbWFuIHRyZWUgZnJvbSB1OCBcIm1hcFwiOiBpbmRleCAtPiBjb2RlIGxlbmd0aCBmb3IgY29kZSBpbmRleFxuLy8gbWIgKG1heCBiaXRzKSBtdXN0IGJlIGF0IG1vc3QgMTVcbi8vIFRPRE86IG9wdGltaXplL3NwbGl0IHVwP1xudmFyIGhNYXAgPSAoZnVuY3Rpb24gKGNkLCBtYiwgcikge1xuICAgIHZhciBzID0gY2QubGVuZ3RoO1xuICAgIC8vIGluZGV4XG4gICAgdmFyIGkgPSAwO1xuICAgIC8vIHUxNiBcIm1hcFwiOiBpbmRleCAtPiAjIG9mIGNvZGVzIHdpdGggYml0IGxlbmd0aCA9IGluZGV4XG4gICAgdmFyIGwgPSBuZXcgdTE2KG1iKTtcbiAgICAvLyBsZW5ndGggb2YgY2QgbXVzdCBiZSAyODggKHRvdGFsICMgb2YgY29kZXMpXG4gICAgZm9yICg7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgaWYgKGNkW2ldKVxuICAgICAgICAgICAgKytsW2NkW2ldIC0gMV07XG4gICAgfVxuICAgIC8vIHUxNiBcIm1hcFwiOiBpbmRleCAtPiBtaW5pbXVtIGNvZGUgZm9yIGJpdCBsZW5ndGggPSBpbmRleFxuICAgIHZhciBsZSA9IG5ldyB1MTYobWIpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBtYjsgKytpKSB7XG4gICAgICAgIGxlW2ldID0gKGxlW2kgLSAxXSArIGxbaSAtIDFdKSA8PCAxO1xuICAgIH1cbiAgICB2YXIgY287XG4gICAgaWYgKHIpIHtcbiAgICAgICAgLy8gdTE2IFwibWFwXCI6IGluZGV4IC0+IG51bWJlciBvZiBhY3R1YWwgYml0cywgc3ltYm9sIGZvciBjb2RlXG4gICAgICAgIGNvID0gbmV3IHUxNigxIDw8IG1iKTtcbiAgICAgICAgLy8gYml0cyB0byByZW1vdmUgZm9yIHJldmVyc2VyXG4gICAgICAgIHZhciBydmIgPSAxNSAtIG1iO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgczsgKytpKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgMCBsZW5ndGhzXG4gICAgICAgICAgICBpZiAoY2RbaV0pIHtcbiAgICAgICAgICAgICAgICAvLyBudW0gZW5jb2RpbmcgYm90aCBzeW1ib2wgYW5kIGJpdHMgcmVhZFxuICAgICAgICAgICAgICAgIHZhciBzdiA9IChpIDw8IDQpIHwgY2RbaV07XG4gICAgICAgICAgICAgICAgLy8gZnJlZSBiaXRzXG4gICAgICAgICAgICAgICAgdmFyIHJfMSA9IG1iIC0gY2RbaV07XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgdmFsdWVcbiAgICAgICAgICAgICAgICB2YXIgdiA9IGxlW2NkW2ldIC0gMV0rKyA8PCByXzE7XG4gICAgICAgICAgICAgICAgLy8gbSBpcyBlbmQgdmFsdWVcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBtID0gdiB8ICgoMSA8PCByXzEpIC0gMSk7IHYgPD0gbTsgKyt2KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZXJ5IDE2IGJpdCB2YWx1ZSBzdGFydGluZyB3aXRoIHRoZSBjb2RlIHlpZWxkcyB0aGUgc2FtZSByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgY29bcmV2W3ZdID4+IHJ2Yl0gPSBzdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvID0gbmV3IHUxNihzKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHM7ICsraSkge1xuICAgICAgICAgICAgaWYgKGNkW2ldKSB7XG4gICAgICAgICAgICAgICAgY29baV0gPSByZXZbbGVbY2RbaV0gLSAxXSsrXSA+PiAoMTUgLSBjZFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvO1xufSk7XG4vLyBmaXhlZCBsZW5ndGggdHJlZVxudmFyIGZsdCA9IG5ldyB1OCgyODgpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAxNDQ7ICsraSlcbiAgICBmbHRbaV0gPSA4O1xuZm9yICh2YXIgaSA9IDE0NDsgaSA8IDI1NjsgKytpKVxuICAgIGZsdFtpXSA9IDk7XG5mb3IgKHZhciBpID0gMjU2OyBpIDwgMjgwOyArK2kpXG4gICAgZmx0W2ldID0gNztcbmZvciAodmFyIGkgPSAyODA7IGkgPCAyODg7ICsraSlcbiAgICBmbHRbaV0gPSA4O1xuLy8gZml4ZWQgZGlzdGFuY2UgdHJlZVxudmFyIGZkdCA9IG5ldyB1OCgzMik7XG5mb3IgKHZhciBpID0gMDsgaSA8IDMyOyArK2kpXG4gICAgZmR0W2ldID0gNTtcbi8vIGZpeGVkIGxlbmd0aCBtYXBcbnZhciBmbG0gPSAvKiNfX1BVUkVfXyovIGhNYXAoZmx0LCA5LCAwKSwgZmxybSA9IC8qI19fUFVSRV9fKi8gaE1hcChmbHQsIDksIDEpO1xuLy8gZml4ZWQgZGlzdGFuY2UgbWFwXG52YXIgZmRtID0gLyojX19QVVJFX18qLyBoTWFwKGZkdCwgNSwgMCksIGZkcm0gPSAvKiNfX1BVUkVfXyovIGhNYXAoZmR0LCA1LCAxKTtcbi8vIGZpbmQgbWF4IG9mIGFycmF5XG52YXIgbWF4ID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgbSA9IGFbMF07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChhW2ldID4gbSlcbiAgICAgICAgICAgIG0gPSBhW2ldO1xuICAgIH1cbiAgICByZXR1cm4gbTtcbn07XG4vLyByZWFkIGQsIHN0YXJ0aW5nIGF0IGJpdCBwIGFuZCBtYXNrIHdpdGggbVxudmFyIGJpdHMgPSBmdW5jdGlvbiAoZCwgcCwgbSkge1xuICAgIHZhciBvID0gKHAgLyA4KSB8IDA7XG4gICAgcmV0dXJuICgoZFtvXSB8IChkW28gKyAxXSA8PCA4KSkgPj4gKHAgJiA3KSkgJiBtO1xufTtcbi8vIHJlYWQgZCwgc3RhcnRpbmcgYXQgYml0IHAgY29udGludWluZyBmb3IgYXQgbGVhc3QgMTYgYml0c1xudmFyIGJpdHMxNiA9IGZ1bmN0aW9uIChkLCBwKSB7XG4gICAgdmFyIG8gPSAocCAvIDgpIHwgMDtcbiAgICByZXR1cm4gKChkW29dIHwgKGRbbyArIDFdIDw8IDgpIHwgKGRbbyArIDJdIDw8IDE2KSkgPj4gKHAgJiA3KSk7XG59O1xuLy8gZ2V0IGVuZCBvZiBieXRlXG52YXIgc2hmdCA9IGZ1bmN0aW9uIChwKSB7IHJldHVybiAoKHAgKyA3KSAvIDgpIHwgMDsgfTtcbi8vIHR5cGVkIGFycmF5IHNsaWNlIC0gYWxsb3dzIGdhcmJhZ2UgY29sbGVjdG9yIHRvIGZyZWUgb3JpZ2luYWwgcmVmZXJlbmNlLFxuLy8gd2hpbGUgYmVpbmcgbW9yZSBjb21wYXRpYmxlIHRoYW4gLnNsaWNlXG52YXIgc2xjID0gZnVuY3Rpb24gKHYsIHMsIGUpIHtcbiAgICBpZiAocyA9PSBudWxsIHx8IHMgPCAwKVxuICAgICAgICBzID0gMDtcbiAgICBpZiAoZSA9PSBudWxsIHx8IGUgPiB2Lmxlbmd0aClcbiAgICAgICAgZSA9IHYubGVuZ3RoO1xuICAgIC8vIGNhbid0IHVzZSAuY29uc3RydWN0b3IgaW4gY2FzZSB1c2VyLXN1cHBsaWVkXG4gICAgcmV0dXJuIG5ldyB1OCh2LnN1YmFycmF5KHMsIGUpKTtcbn07XG4vKipcbiAqIENvZGVzIGZvciBlcnJvcnMgZ2VuZXJhdGVkIHdpdGhpbiB0aGlzIGxpYnJhcnlcbiAqL1xuZXhwb3J0IHZhciBGbGF0ZUVycm9yQ29kZSA9IHtcbiAgICBVbmV4cGVjdGVkRU9GOiAwLFxuICAgIEludmFsaWRCbG9ja1R5cGU6IDEsXG4gICAgSW52YWxpZExlbmd0aExpdGVyYWw6IDIsXG4gICAgSW52YWxpZERpc3RhbmNlOiAzLFxuICAgIFN0cmVhbUZpbmlzaGVkOiA0LFxuICAgIE5vU3RyZWFtSGFuZGxlcjogNSxcbiAgICBJbnZhbGlkSGVhZGVyOiA2LFxuICAgIE5vQ2FsbGJhY2s6IDcsXG4gICAgSW52YWxpZFVURjg6IDgsXG4gICAgRXh0cmFGaWVsZFRvb0xvbmc6IDksXG4gICAgSW52YWxpZERhdGU6IDEwLFxuICAgIEZpbGVuYW1lVG9vTG9uZzogMTEsXG4gICAgU3RyZWFtRmluaXNoaW5nOiAxMixcbiAgICBJbnZhbGlkWmlwRGF0YTogMTMsXG4gICAgVW5rbm93bkNvbXByZXNzaW9uTWV0aG9kOiAxNFxufTtcbi8vIGVycm9yIGNvZGVzXG52YXIgZWMgPSBbXG4gICAgJ3VuZXhwZWN0ZWQgRU9GJyxcbiAgICAnaW52YWxpZCBibG9jayB0eXBlJyxcbiAgICAnaW52YWxpZCBsZW5ndGgvbGl0ZXJhbCcsXG4gICAgJ2ludmFsaWQgZGlzdGFuY2UnLFxuICAgICdzdHJlYW0gZmluaXNoZWQnLFxuICAgICdubyBzdHJlYW0gaGFuZGxlcicsXG4gICAgLFxuICAgICdubyBjYWxsYmFjaycsXG4gICAgJ2ludmFsaWQgVVRGLTggZGF0YScsXG4gICAgJ2V4dHJhIGZpZWxkIHRvbyBsb25nJyxcbiAgICAnZGF0ZSBub3QgaW4gcmFuZ2UgMTk4MC0yMDk5JyxcbiAgICAnZmlsZW5hbWUgdG9vIGxvbmcnLFxuICAgICdzdHJlYW0gZmluaXNoaW5nJyxcbiAgICAnaW52YWxpZCB6aXAgZGF0YSdcbiAgICAvLyBkZXRlcm1pbmVkIGJ5IHVua25vd24gY29tcHJlc3Npb24gbWV0aG9kXG5dO1xuO1xudmFyIGVyciA9IGZ1bmN0aW9uIChpbmQsIG1zZywgbnQpIHtcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtc2cgfHwgZWNbaW5kXSk7XG4gICAgZS5jb2RlID0gaW5kO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSlcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZSwgZXJyKTtcbiAgICBpZiAoIW50KVxuICAgICAgICB0aHJvdyBlO1xuICAgIHJldHVybiBlO1xufTtcbi8vIGV4cGFuZHMgcmF3IERFRkxBVEUgZGF0YVxudmFyIGluZmx0ID0gZnVuY3Rpb24gKGRhdCwgc3QsIGJ1ZiwgZGljdCkge1xuICAgIC8vIHNvdXJjZSBsZW5ndGggICAgICAgZGljdCBsZW5ndGhcbiAgICB2YXIgc2wgPSBkYXQubGVuZ3RoLCBkbCA9IGRpY3QgPyBkaWN0Lmxlbmd0aCA6IDA7XG4gICAgaWYgKCFzbCB8fCBzdC5mICYmICFzdC5sKVxuICAgICAgICByZXR1cm4gYnVmIHx8IG5ldyB1OCgwKTtcbiAgICB2YXIgbm9CdWYgPSAhYnVmO1xuICAgIC8vIGhhdmUgdG8gZXN0aW1hdGUgc2l6ZVxuICAgIHZhciByZXNpemUgPSBub0J1ZiB8fCBzdC5pICE9IDI7XG4gICAgLy8gbm8gc3RhdGVcbiAgICB2YXIgbm9TdCA9IHN0Lmk7XG4gICAgLy8gQXNzdW1lcyByb3VnaGx5IDMzJSBjb21wcmVzc2lvbiByYXRpbyBhdmVyYWdlXG4gICAgaWYgKG5vQnVmKVxuICAgICAgICBidWYgPSBuZXcgdTgoc2wgKiAzKTtcbiAgICAvLyBlbnN1cmUgYnVmZmVyIGNhbiBmaXQgYXQgbGVhc3QgbCBlbGVtZW50c1xuICAgIHZhciBjYnVmID0gZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgdmFyIGJsID0gYnVmLmxlbmd0aDtcbiAgICAgICAgLy8gbmVlZCB0byBpbmNyZWFzZSBzaXplIHRvIGZpdFxuICAgICAgICBpZiAobCA+IGJsKSB7XG4gICAgICAgICAgICAvLyBEb3VibGUgb3Igc2V0IHRvIG5lY2Vzc2FyeSwgd2hpY2hldmVyIGlzIGdyZWF0ZXJcbiAgICAgICAgICAgIHZhciBuYnVmID0gbmV3IHU4KE1hdGgubWF4KGJsICogMiwgbCkpO1xuICAgICAgICAgICAgbmJ1Zi5zZXQoYnVmKTtcbiAgICAgICAgICAgIGJ1ZiA9IG5idWY7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vICBsYXN0IGNodW5rICAgICAgICAgYml0cG9zICAgICAgICAgICBieXRlc1xuICAgIHZhciBmaW5hbCA9IHN0LmYgfHwgMCwgcG9zID0gc3QucCB8fCAwLCBidCA9IHN0LmIgfHwgMCwgbG0gPSBzdC5sLCBkbSA9IHN0LmQsIGxidCA9IHN0Lm0sIGRidCA9IHN0Lm47XG4gICAgLy8gdG90YWwgYml0c1xuICAgIHZhciB0YnRzID0gc2wgKiA4O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKCFsbSkge1xuICAgICAgICAgICAgLy8gQkZJTkFMIC0gdGhpcyBpcyBvbmx5IDEgd2hlbiBsYXN0IGNodW5rIGlzIG5leHRcbiAgICAgICAgICAgIGZpbmFsID0gYml0cyhkYXQsIHBvcywgMSk7XG4gICAgICAgICAgICAvLyB0eXBlOiAwID0gbm8gY29tcHJlc3Npb24sIDEgPSBmaXhlZCBodWZmbWFuLCAyID0gZHluYW1pYyBodWZmbWFuXG4gICAgICAgICAgICB2YXIgdHlwZSA9IGJpdHMoZGF0LCBwb3MgKyAxLCAzKTtcbiAgICAgICAgICAgIHBvcyArPSAzO1xuICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gZ28gdG8gZW5kIG9mIGJ5dGUgYm91bmRhcnlcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHNoZnQocG9zKSArIDQsIGwgPSBkYXRbcyAtIDRdIHwgKGRhdFtzIC0gM10gPDwgOCksIHQgPSBzICsgbDtcbiAgICAgICAgICAgICAgICBpZiAodCA+IHNsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub1N0KVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyKDApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIHNpemVcbiAgICAgICAgICAgICAgICBpZiAocmVzaXplKVxuICAgICAgICAgICAgICAgICAgICBjYnVmKGJ0ICsgbCk7XG4gICAgICAgICAgICAgICAgLy8gQ29weSBvdmVyIHVuY29tcHJlc3NlZCBkYXRhXG4gICAgICAgICAgICAgICAgYnVmLnNldChkYXQuc3ViYXJyYXkocywgdCksIGJ0KTtcbiAgICAgICAgICAgICAgICAvLyBHZXQgbmV3IGJpdHBvcywgdXBkYXRlIGJ5dGUgY291bnRcbiAgICAgICAgICAgICAgICBzdC5iID0gYnQgKz0gbCwgc3QucCA9IHBvcyA9IHQgKiA4LCBzdC5mID0gZmluYWw7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IDEpXG4gICAgICAgICAgICAgICAgbG0gPSBmbHJtLCBkbSA9IGZkcm0sIGxidCA9IDksIGRidCA9IDU7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IDIpIHtcbiAgICAgICAgICAgICAgICAvLyAgbGl0ZXJhbCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGhzXG4gICAgICAgICAgICAgICAgdmFyIGhMaXQgPSBiaXRzKGRhdCwgcG9zLCAzMSkgKyAyNTcsIGhjTGVuID0gYml0cyhkYXQsIHBvcyArIDEwLCAxNSkgKyA0O1xuICAgICAgICAgICAgICAgIHZhciB0bCA9IGhMaXQgKyBiaXRzKGRhdCwgcG9zICsgNSwgMzEpICsgMTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gMTQ7XG4gICAgICAgICAgICAgICAgLy8gbGVuZ3RoK2Rpc3RhbmNlIHRyZWVcbiAgICAgICAgICAgICAgICB2YXIgbGR0ID0gbmV3IHU4KHRsKTtcbiAgICAgICAgICAgICAgICAvLyBjb2RlIGxlbmd0aCB0cmVlXG4gICAgICAgICAgICAgICAgdmFyIGNsdCA9IG5ldyB1OCgxOSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoY0xlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSBpbmRleCBtYXAgdG8gZ2V0IHJlYWwgY29kZVxuICAgICAgICAgICAgICAgICAgICBjbHRbY2xpbVtpXV0gPSBiaXRzKGRhdCwgcG9zICsgaSAqIDMsIDcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgKz0gaGNMZW4gKiAzO1xuICAgICAgICAgICAgICAgIC8vIGNvZGUgbGVuZ3RocyBiaXRzXG4gICAgICAgICAgICAgICAgdmFyIGNsYiA9IG1heChjbHQpLCBjbGJtc2sgPSAoMSA8PCBjbGIpIC0gMTtcbiAgICAgICAgICAgICAgICAvLyBjb2RlIGxlbmd0aHMgbWFwXG4gICAgICAgICAgICAgICAgdmFyIGNsbSA9IGhNYXAoY2x0LCBjbGIsIDEpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGw7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gY2xtW2JpdHMoZGF0LCBwb3MsIGNsYm1zayldO1xuICAgICAgICAgICAgICAgICAgICAvLyBiaXRzIHJlYWRcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IHIgJiAxNTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3ltYm9sXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gciA+PiA0O1xuICAgICAgICAgICAgICAgICAgICAvLyBjb2RlIGxlbmd0aCB0byBjb3B5XG4gICAgICAgICAgICAgICAgICAgIGlmIChzIDwgMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxkdFtpKytdID0gcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBjb3B5ICAgY291bnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gMCwgbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA9PSAxNilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gMyArIGJpdHMoZGF0LCBwb3MsIDMpLCBwb3MgKz0gMiwgYyA9IGxkdFtpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzID09IDE3KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAzICsgYml0cyhkYXQsIHBvcywgNyksIHBvcyArPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocyA9PSAxOClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gMTEgKyBiaXRzKGRhdCwgcG9zLCAxMjcpLCBwb3MgKz0gNztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChuLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGR0W2krK10gPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICAgIGxlbmd0aCB0cmVlICAgICAgICAgICAgICAgICBkaXN0YW5jZSB0cmVlXG4gICAgICAgICAgICAgICAgdmFyIGx0ID0gbGR0LnN1YmFycmF5KDAsIGhMaXQpLCBkdCA9IGxkdC5zdWJhcnJheShoTGl0KTtcbiAgICAgICAgICAgICAgICAvLyBtYXggbGVuZ3RoIGJpdHNcbiAgICAgICAgICAgICAgICBsYnQgPSBtYXgobHQpO1xuICAgICAgICAgICAgICAgIC8vIG1heCBkaXN0IGJpdHNcbiAgICAgICAgICAgICAgICBkYnQgPSBtYXgoZHQpO1xuICAgICAgICAgICAgICAgIGxtID0gaE1hcChsdCwgbGJ0LCAxKTtcbiAgICAgICAgICAgICAgICBkbSA9IGhNYXAoZHQsIGRidCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZXJyKDEpO1xuICAgICAgICAgICAgaWYgKHBvcyA+IHRidHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgICAgICAgICAgZXJyKDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgYnVmZmVyIGNhbiBob2xkIHRoaXMgKyB0aGUgbGFyZ2VzdCBwb3NzaWJsZSBhZGRpdGlvblxuICAgICAgICAvLyBNYXhpbXVtIGNodW5rIHNpemUgKHByYWN0aWNhbGx5LCB0aGVvcmV0aWNhbGx5IGluZmluaXRlKSBpcyAyXjE3XG4gICAgICAgIGlmIChyZXNpemUpXG4gICAgICAgICAgICBjYnVmKGJ0ICsgMTMxMDcyKTtcbiAgICAgICAgdmFyIGxtcyA9ICgxIDw8IGxidCkgLSAxLCBkbXMgPSAoMSA8PCBkYnQpIC0gMTtcbiAgICAgICAgdmFyIGxwb3MgPSBwb3M7XG4gICAgICAgIGZvciAoOzsgbHBvcyA9IHBvcykge1xuICAgICAgICAgICAgLy8gYml0cyByZWFkLCBjb2RlXG4gICAgICAgICAgICB2YXIgYyA9IGxtW2JpdHMxNihkYXQsIHBvcykgJiBsbXNdLCBzeW0gPSBjID4+IDQ7XG4gICAgICAgICAgICBwb3MgKz0gYyAmIDE1O1xuICAgICAgICAgICAgaWYgKHBvcyA+IHRidHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgICAgICAgICAgZXJyKDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjKVxuICAgICAgICAgICAgICAgIGVycigyKTtcbiAgICAgICAgICAgIGlmIChzeW0gPCAyNTYpXG4gICAgICAgICAgICAgICAgYnVmW2J0KytdID0gc3ltO1xuICAgICAgICAgICAgZWxzZSBpZiAoc3ltID09IDI1Nikge1xuICAgICAgICAgICAgICAgIGxwb3MgPSBwb3MsIGxtID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBhZGQgPSBzeW0gLSAyNTQ7XG4gICAgICAgICAgICAgICAgLy8gbm8gZXh0cmEgYml0cyBuZWVkZWQgaWYgbGVzc1xuICAgICAgICAgICAgICAgIGlmIChzeW0gPiAyNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBzeW0gLSAyNTcsIGIgPSBmbGViW2ldO1xuICAgICAgICAgICAgICAgICAgICBhZGQgPSBiaXRzKGRhdCwgcG9zLCAoMSA8PCBiKSAtIDEpICsgZmxbaV07XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSBiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkaXN0XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBkbVtiaXRzMTYoZGF0LCBwb3MpICYgZG1zXSwgZHN5bSA9IGQgPj4gNDtcbiAgICAgICAgICAgICAgICBpZiAoIWQpXG4gICAgICAgICAgICAgICAgICAgIGVycigzKTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gZCAmIDE1O1xuICAgICAgICAgICAgICAgIHZhciBkdCA9IGZkW2RzeW1dO1xuICAgICAgICAgICAgICAgIGlmIChkc3ltID4gMykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IGZkZWJbZHN5bV07XG4gICAgICAgICAgICAgICAgICAgIGR0ICs9IGJpdHMxNihkYXQsIHBvcykgJiAoMSA8PCBiKSAtIDEsIHBvcyArPSBiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zID4gdGJ0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycigwKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXNpemUpXG4gICAgICAgICAgICAgICAgICAgIGNidWYoYnQgKyAxMzEwNzIpO1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBidCArIGFkZDtcbiAgICAgICAgICAgICAgICBpZiAoYnQgPCBkdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2hpZnQgPSBkbCAtIGR0LCBkZW5kID0gTWF0aC5taW4oZHQsIGVuZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaGlmdCArIGJ0IDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycigzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGJ0IDwgZGVuZDsgKytidClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZltidF0gPSBkaWN0W3NoaWZ0ICsgYnRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKDsgYnQgPCBlbmQ7ICsrYnQpXG4gICAgICAgICAgICAgICAgICAgIGJ1ZltidF0gPSBidWZbYnQgLSBkdF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3QubCA9IGxtLCBzdC5wID0gbHBvcywgc3QuYiA9IGJ0LCBzdC5mID0gZmluYWw7XG4gICAgICAgIGlmIChsbSlcbiAgICAgICAgICAgIGZpbmFsID0gMSwgc3QubSA9IGxidCwgc3QuZCA9IGRtLCBzdC5uID0gZGJ0O1xuICAgIH0gd2hpbGUgKCFmaW5hbCk7XG4gICAgLy8gZG9uJ3QgcmVhbGxvY2F0ZSBmb3Igc3RyZWFtcyBvciB1c2VyIGJ1ZmZlcnNcbiAgICByZXR1cm4gYnQgIT0gYnVmLmxlbmd0aCAmJiBub0J1ZiA/IHNsYyhidWYsIDAsIGJ0KSA6IGJ1Zi5zdWJhcnJheSgwLCBidCk7XG59O1xuLy8gc3RhcnRpbmcgYXQgcCwgd3JpdGUgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGJpdHMgdGhhdCBjYW4gaG9sZCB2IHRvIGRcbnZhciB3Yml0cyA9IGZ1bmN0aW9uIChkLCBwLCB2KSB7XG4gICAgdiA8PD0gcCAmIDc7XG4gICAgdmFyIG8gPSAocCAvIDgpIHwgMDtcbiAgICBkW29dIHw9IHY7XG4gICAgZFtvICsgMV0gfD0gdiA+PiA4O1xufTtcbi8vIHN0YXJ0aW5nIGF0IHAsIHdyaXRlIHRoZSBtaW5pbXVtIG51bWJlciBvZiBiaXRzICg+OCkgdGhhdCBjYW4gaG9sZCB2IHRvIGRcbnZhciB3Yml0czE2ID0gZnVuY3Rpb24gKGQsIHAsIHYpIHtcbiAgICB2IDw8PSBwICYgNztcbiAgICB2YXIgbyA9IChwIC8gOCkgfCAwO1xuICAgIGRbb10gfD0gdjtcbiAgICBkW28gKyAxXSB8PSB2ID4+IDg7XG4gICAgZFtvICsgMl0gfD0gdiA+PiAxNjtcbn07XG4vLyBjcmVhdGVzIGNvZGUgbGVuZ3RocyBmcm9tIGEgZnJlcXVlbmN5IHRhYmxlXG52YXIgaFRyZWUgPSBmdW5jdGlvbiAoZCwgbWIpIHtcbiAgICAvLyBOZWVkIGV4dHJhIGluZm8gdG8gbWFrZSBhIHRyZWVcbiAgICB2YXIgdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZC5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoZFtpXSlcbiAgICAgICAgICAgIHQucHVzaCh7IHM6IGksIGY6IGRbaV0gfSk7XG4gICAgfVxuICAgIHZhciBzID0gdC5sZW5ndGg7XG4gICAgdmFyIHQyID0gdC5zbGljZSgpO1xuICAgIGlmICghcylcbiAgICAgICAgcmV0dXJuIHsgdDogZXQsIGw6IDAgfTtcbiAgICBpZiAocyA9PSAxKSB7XG4gICAgICAgIHZhciB2ID0gbmV3IHU4KHRbMF0ucyArIDEpO1xuICAgICAgICB2W3RbMF0uc10gPSAxO1xuICAgICAgICByZXR1cm4geyB0OiB2LCBsOiAxIH07XG4gICAgfVxuICAgIHQuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5mIC0gYi5mOyB9KTtcbiAgICAvLyBhZnRlciBpMiByZWFjaGVzIGxhc3QgaW5kLCB3aWxsIGJlIHN0b3BwZWRcbiAgICAvLyBmcmVxIG11c3QgYmUgZ3JlYXRlciB0aGFuIGxhcmdlc3QgcG9zc2libGUgbnVtYmVyIG9mIHN5bWJvbHNcbiAgICB0LnB1c2goeyBzOiAtMSwgZjogMjUwMDEgfSk7XG4gICAgdmFyIGwgPSB0WzBdLCByID0gdFsxXSwgaTAgPSAwLCBpMSA9IDEsIGkyID0gMjtcbiAgICB0WzBdID0geyBzOiAtMSwgZjogbC5mICsgci5mLCBsOiBsLCByOiByIH07XG4gICAgLy8gZWZmaWNpZW50IGFsZ29yaXRobSBmcm9tIFVaSVAuanNcbiAgICAvLyBpMCBpcyBsb29rYmVoaW5kLCBpMiBpcyBsb29rYWhlYWQgLSBhZnRlciBwcm9jZXNzaW5nIHR3byBsb3ctZnJlcVxuICAgIC8vIHN5bWJvbHMgdGhhdCBjb21iaW5lZCBoYXZlIGhpZ2ggZnJlcSwgd2lsbCBzdGFydCBwcm9jZXNzaW5nIGkyIChoaWdoLWZyZXEsXG4gICAgLy8gbm9uLWNvbXBvc2l0ZSkgc3ltYm9scyBpbnN0ZWFkXG4gICAgLy8gc2VlIGh0dHBzOi8vcmVkZGl0LmNvbS9yL3Bob3RvcGVhL2NvbW1lbnRzL2lrZWtodC91emlwanNfcXVlc3Rpb25zL1xuICAgIHdoaWxlIChpMSAhPSBzIC0gMSkge1xuICAgICAgICBsID0gdFt0W2kwXS5mIDwgdFtpMl0uZiA/IGkwKysgOiBpMisrXTtcbiAgICAgICAgciA9IHRbaTAgIT0gaTEgJiYgdFtpMF0uZiA8IHRbaTJdLmYgPyBpMCsrIDogaTIrK107XG4gICAgICAgIHRbaTErK10gPSB7IHM6IC0xLCBmOiBsLmYgKyByLmYsIGw6IGwsIHI6IHIgfTtcbiAgICB9XG4gICAgdmFyIG1heFN5bSA9IHQyWzBdLnM7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgaWYgKHQyW2ldLnMgPiBtYXhTeW0pXG4gICAgICAgICAgICBtYXhTeW0gPSB0MltpXS5zO1xuICAgIH1cbiAgICAvLyBjb2RlIGxlbmd0aHNcbiAgICB2YXIgdHIgPSBuZXcgdTE2KG1heFN5bSArIDEpO1xuICAgIC8vIG1heCBiaXRzIGluIHRyZWVcbiAgICB2YXIgbWJ0ID0gbG4odFtpMSAtIDFdLCB0ciwgMCk7XG4gICAgaWYgKG1idCA+IG1iKSB7XG4gICAgICAgIC8vIG1vcmUgYWxnb3JpdGhtcyBmcm9tIFVaSVAuanNcbiAgICAgICAgLy8gVE9ETzogZmluZCBvdXQgaG93IHRoaXMgY29kZSB3b3JrcyAoZGVidClcbiAgICAgICAgLy8gIGluZCAgICBkZWJ0XG4gICAgICAgIHZhciBpID0gMCwgZHQgPSAwO1xuICAgICAgICAvLyAgICBsZWZ0ICAgICAgICAgICAgY29zdFxuICAgICAgICB2YXIgbGZ0ID0gbWJ0IC0gbWIsIGNzdCA9IDEgPDwgbGZ0O1xuICAgICAgICB0Mi5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiB0cltiLnNdIC0gdHJbYS5zXSB8fCBhLmYgLSBiLmY7IH0pO1xuICAgICAgICBmb3IgKDsgaSA8IHM7ICsraSkge1xuICAgICAgICAgICAgdmFyIGkyXzEgPSB0MltpXS5zO1xuICAgICAgICAgICAgaWYgKHRyW2kyXzFdID4gbWIpIHtcbiAgICAgICAgICAgICAgICBkdCArPSBjc3QgLSAoMSA8PCAobWJ0IC0gdHJbaTJfMV0pKTtcbiAgICAgICAgICAgICAgICB0cltpMl8xXSA9IG1iO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGR0ID4+PSBsZnQ7XG4gICAgICAgIHdoaWxlIChkdCA+IDApIHtcbiAgICAgICAgICAgIHZhciBpMl8yID0gdDJbaV0ucztcbiAgICAgICAgICAgIGlmICh0cltpMl8yXSA8IG1iKVxuICAgICAgICAgICAgICAgIGR0IC09IDEgPDwgKG1iIC0gdHJbaTJfMl0rKyAtIDEpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA+PSAwICYmIGR0OyAtLWkpIHtcbiAgICAgICAgICAgIHZhciBpMl8zID0gdDJbaV0ucztcbiAgICAgICAgICAgIGlmICh0cltpMl8zXSA9PSBtYikge1xuICAgICAgICAgICAgICAgIC0tdHJbaTJfM107XG4gICAgICAgICAgICAgICAgKytkdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYnQgPSBtYjtcbiAgICB9XG4gICAgcmV0dXJuIHsgdDogbmV3IHU4KHRyKSwgbDogbWJ0IH07XG59O1xuLy8gZ2V0IHRoZSBtYXggbGVuZ3RoIGFuZCBhc3NpZ24gbGVuZ3RoIGNvZGVzXG52YXIgbG4gPSBmdW5jdGlvbiAobiwgbCwgZCkge1xuICAgIHJldHVybiBuLnMgPT0gLTFcbiAgICAgICAgPyBNYXRoLm1heChsbihuLmwsIGwsIGQgKyAxKSwgbG4obi5yLCBsLCBkICsgMSkpXG4gICAgICAgIDogKGxbbi5zXSA9IGQpO1xufTtcbi8vIGxlbmd0aCBjb2RlcyBnZW5lcmF0aW9uXG52YXIgbGMgPSBmdW5jdGlvbiAoYykge1xuICAgIHZhciBzID0gYy5sZW5ndGg7XG4gICAgLy8gTm90ZSB0aGF0IHRoZSBzZW1pY29sb24gd2FzIGludGVudGlvbmFsXG4gICAgd2hpbGUgKHMgJiYgIWNbLS1zXSlcbiAgICAgICAgO1xuICAgIHZhciBjbCA9IG5ldyB1MTYoKytzKTtcbiAgICAvLyAgaW5kICAgICAgbnVtICAgICAgICAgc3RyZWFrXG4gICAgdmFyIGNsaSA9IDAsIGNsbiA9IGNbMF0sIGNscyA9IDE7XG4gICAgdmFyIHcgPSBmdW5jdGlvbiAodikgeyBjbFtjbGkrK10gPSB2OyB9O1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHM7ICsraSkge1xuICAgICAgICBpZiAoY1tpXSA9PSBjbG4gJiYgaSAhPSBzKVxuICAgICAgICAgICAgKytjbHM7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFjbG4gJiYgY2xzID4gMikge1xuICAgICAgICAgICAgICAgIGZvciAoOyBjbHMgPiAxMzg7IGNscyAtPSAxMzgpXG4gICAgICAgICAgICAgICAgICAgIHcoMzI3NTQpO1xuICAgICAgICAgICAgICAgIGlmIChjbHMgPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHcoY2xzID4gMTAgPyAoKGNscyAtIDExKSA8PCA1KSB8IDI4NjkwIDogKChjbHMgLSAzKSA8PCA1KSB8IDEyMzA1KTtcbiAgICAgICAgICAgICAgICAgICAgY2xzID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbHMgPiAzKSB7XG4gICAgICAgICAgICAgICAgdyhjbG4pLCAtLWNscztcbiAgICAgICAgICAgICAgICBmb3IgKDsgY2xzID4gNjsgY2xzIC09IDYpXG4gICAgICAgICAgICAgICAgICAgIHcoODMwNCk7XG4gICAgICAgICAgICAgICAgaWYgKGNscyA+IDIpXG4gICAgICAgICAgICAgICAgICAgIHcoKChjbHMgLSAzKSA8PCA1KSB8IDgyMDgpLCBjbHMgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNscy0tKVxuICAgICAgICAgICAgICAgIHcoY2xuKTtcbiAgICAgICAgICAgIGNscyA9IDE7XG4gICAgICAgICAgICBjbG4gPSBjW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGM6IGNsLnN1YmFycmF5KDAsIGNsaSksIG46IHMgfTtcbn07XG4vLyBjYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiBvdXRwdXQgZnJvbSB0cmVlLCBjb2RlIGxlbmd0aHNcbnZhciBjbGVuID0gZnVuY3Rpb24gKGNmLCBjbCkge1xuICAgIHZhciBsID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsLmxlbmd0aDsgKytpKVxuICAgICAgICBsICs9IGNmW2ldICogY2xbaV07XG4gICAgcmV0dXJuIGw7XG59O1xuLy8gd3JpdGVzIGEgZml4ZWQgYmxvY2tcbi8vIHJldHVybnMgdGhlIG5ldyBiaXQgcG9zXG52YXIgd2ZibGsgPSBmdW5jdGlvbiAob3V0LCBwb3MsIGRhdCkge1xuICAgIC8vIG5vIG5lZWQgdG8gd3JpdGUgMDAgYXMgdHlwZTogVHlwZWRBcnJheSBkZWZhdWx0cyB0byAwXG4gICAgdmFyIHMgPSBkYXQubGVuZ3RoO1xuICAgIHZhciBvID0gc2hmdChwb3MgKyAyKTtcbiAgICBvdXRbb10gPSBzICYgMjU1O1xuICAgIG91dFtvICsgMV0gPSBzID4+IDg7XG4gICAgb3V0W28gKyAyXSA9IG91dFtvXSBeIDI1NTtcbiAgICBvdXRbbyArIDNdID0gb3V0W28gKyAxXSBeIDI1NTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7ICsraSlcbiAgICAgICAgb3V0W28gKyBpICsgNF0gPSBkYXRbaV07XG4gICAgcmV0dXJuIChvICsgNCArIHMpICogODtcbn07XG4vLyB3cml0ZXMgYSBibG9ja1xudmFyIHdibGsgPSBmdW5jdGlvbiAoZGF0LCBvdXQsIGZpbmFsLCBzeW1zLCBsZiwgZGYsIGViLCBsaSwgYnMsIGJsLCBwKSB7XG4gICAgd2JpdHMob3V0LCBwKyssIGZpbmFsKTtcbiAgICArK2xmWzI1Nl07XG4gICAgdmFyIF9hID0gaFRyZWUobGYsIDE1KSwgZGx0ID0gX2EudCwgbWxiID0gX2EubDtcbiAgICB2YXIgX2IgPSBoVHJlZShkZiwgMTUpLCBkZHQgPSBfYi50LCBtZGIgPSBfYi5sO1xuICAgIHZhciBfYyA9IGxjKGRsdCksIGxjbHQgPSBfYy5jLCBubGMgPSBfYy5uO1xuICAgIHZhciBfZCA9IGxjKGRkdCksIGxjZHQgPSBfZC5jLCBuZGMgPSBfZC5uO1xuICAgIHZhciBsY2ZyZXEgPSBuZXcgdTE2KDE5KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxjbHQubGVuZ3RoOyArK2kpXG4gICAgICAgICsrbGNmcmVxW2xjbHRbaV0gJiAzMV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsY2R0Lmxlbmd0aDsgKytpKVxuICAgICAgICArK2xjZnJlcVtsY2R0W2ldICYgMzFdO1xuICAgIHZhciBfZSA9IGhUcmVlKGxjZnJlcSwgNyksIGxjdCA9IF9lLnQsIG1sY2IgPSBfZS5sO1xuICAgIHZhciBubGNjID0gMTk7XG4gICAgZm9yICg7IG5sY2MgPiA0ICYmICFsY3RbY2xpbVtubGNjIC0gMV1dOyAtLW5sY2MpXG4gICAgICAgIDtcbiAgICB2YXIgZmxlbiA9IChibCArIDUpIDw8IDM7XG4gICAgdmFyIGZ0bGVuID0gY2xlbihsZiwgZmx0KSArIGNsZW4oZGYsIGZkdCkgKyBlYjtcbiAgICB2YXIgZHRsZW4gPSBjbGVuKGxmLCBkbHQpICsgY2xlbihkZiwgZGR0KSArIGViICsgMTQgKyAzICogbmxjYyArIGNsZW4obGNmcmVxLCBsY3QpICsgMiAqIGxjZnJlcVsxNl0gKyAzICogbGNmcmVxWzE3XSArIDcgKiBsY2ZyZXFbMThdO1xuICAgIGlmIChicyA+PSAwICYmIGZsZW4gPD0gZnRsZW4gJiYgZmxlbiA8PSBkdGxlbilcbiAgICAgICAgcmV0dXJuIHdmYmxrKG91dCwgcCwgZGF0LnN1YmFycmF5KGJzLCBicyArIGJsKSk7XG4gICAgdmFyIGxtLCBsbCwgZG0sIGRsO1xuICAgIHdiaXRzKG91dCwgcCwgMSArIChkdGxlbiA8IGZ0bGVuKSksIHAgKz0gMjtcbiAgICBpZiAoZHRsZW4gPCBmdGxlbikge1xuICAgICAgICBsbSA9IGhNYXAoZGx0LCBtbGIsIDApLCBsbCA9IGRsdCwgZG0gPSBoTWFwKGRkdCwgbWRiLCAwKSwgZGwgPSBkZHQ7XG4gICAgICAgIHZhciBsbG0gPSBoTWFwKGxjdCwgbWxjYiwgMCk7XG4gICAgICAgIHdiaXRzKG91dCwgcCwgbmxjIC0gMjU3KTtcbiAgICAgICAgd2JpdHMob3V0LCBwICsgNSwgbmRjIC0gMSk7XG4gICAgICAgIHdiaXRzKG91dCwgcCArIDEwLCBubGNjIC0gNCk7XG4gICAgICAgIHAgKz0gMTQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmxjYzsgKytpKVxuICAgICAgICAgICAgd2JpdHMob3V0LCBwICsgMyAqIGksIGxjdFtjbGltW2ldXSk7XG4gICAgICAgIHAgKz0gMyAqIG5sY2M7XG4gICAgICAgIHZhciBsY3RzID0gW2xjbHQsIGxjZHRdO1xuICAgICAgICBmb3IgKHZhciBpdCA9IDA7IGl0IDwgMjsgKytpdCkge1xuICAgICAgICAgICAgdmFyIGNsY3QgPSBsY3RzW2l0XTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xjdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBjbGN0W2ldICYgMzE7XG4gICAgICAgICAgICAgICAgd2JpdHMob3V0LCBwLCBsbG1bbGVuXSksIHAgKz0gbGN0W2xlbl07XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDE1KVxuICAgICAgICAgICAgICAgICAgICB3Yml0cyhvdXQsIHAsIChjbGN0W2ldID4+IDUpICYgMTI3KSwgcCArPSBjbGN0W2ldID4+IDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsbSA9IGZsbSwgbGwgPSBmbHQsIGRtID0gZmRtLCBkbCA9IGZkdDtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaTsgKytpKSB7XG4gICAgICAgIHZhciBzeW0gPSBzeW1zW2ldO1xuICAgICAgICBpZiAoc3ltID4gMjU1KSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gKHN5bSA+PiAxOCkgJiAzMTtcbiAgICAgICAgICAgIHdiaXRzMTYob3V0LCBwLCBsbVtsZW4gKyAyNTddKSwgcCArPSBsbFtsZW4gKyAyNTddO1xuICAgICAgICAgICAgaWYgKGxlbiA+IDcpXG4gICAgICAgICAgICAgICAgd2JpdHMob3V0LCBwLCAoc3ltID4+IDIzKSAmIDMxKSwgcCArPSBmbGViW2xlbl07XG4gICAgICAgICAgICB2YXIgZHN0ID0gc3ltICYgMzE7XG4gICAgICAgICAgICB3Yml0czE2KG91dCwgcCwgZG1bZHN0XSksIHAgKz0gZGxbZHN0XTtcbiAgICAgICAgICAgIGlmIChkc3QgPiAzKVxuICAgICAgICAgICAgICAgIHdiaXRzMTYob3V0LCBwLCAoc3ltID4+IDUpICYgODE5MSksIHAgKz0gZmRlYltkc3RdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2JpdHMxNihvdXQsIHAsIGxtW3N5bV0pLCBwICs9IGxsW3N5bV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2JpdHMxNihvdXQsIHAsIGxtWzI1Nl0pO1xuICAgIHJldHVybiBwICsgbGxbMjU2XTtcbn07XG4vLyBkZWZsYXRlIG9wdGlvbnMgKG5pY2UgPDwgMTMpIHwgY2hhaW5cbnZhciBkZW8gPSAvKiNfX1BVUkVfXyovIG5ldyBpMzIoWzY1NTQwLCAxMzEwODAsIDEzMTA4OCwgMTMxMTA0LCAyNjIxNzYsIDEwNDg3MDQsIDEwNDg4MzIsIDIxMTQ1NjAsIDIxMTc2MzJdKTtcbi8vIGVtcHR5XG52YXIgZXQgPSAvKiNfX1BVUkVfXyovIG5ldyB1OCgwKTtcbi8vIGNvbXByZXNzZXMgZGF0YSBpbnRvIGEgcmF3IERFRkxBVEUgYnVmZmVyXG52YXIgZGZsdCA9IGZ1bmN0aW9uIChkYXQsIGx2bCwgcGx2bCwgcHJlLCBwb3N0LCBzdCkge1xuICAgIHZhciBzID0gc3QueiB8fCBkYXQubGVuZ3RoO1xuICAgIHZhciBvID0gbmV3IHU4KHByZSArIHMgKyA1ICogKDEgKyBNYXRoLmNlaWwocyAvIDcwMDApKSArIHBvc3QpO1xuICAgIC8vIHdyaXRpbmcgdG8gdGhpcyB3cml0ZXMgdG8gdGhlIG91dHB1dCBidWZmZXJcbiAgICB2YXIgdyA9IG8uc3ViYXJyYXkocHJlLCBvLmxlbmd0aCAtIHBvc3QpO1xuICAgIHZhciBsc3QgPSBzdC5sO1xuICAgIHZhciBwb3MgPSAoc3QuciB8fCAwKSAmIDc7XG4gICAgaWYgKGx2bCkge1xuICAgICAgICBpZiAocG9zKVxuICAgICAgICAgICAgd1swXSA9IHN0LnIgPj4gMztcbiAgICAgICAgdmFyIG9wdCA9IGRlb1tsdmwgLSAxXTtcbiAgICAgICAgdmFyIG4gPSBvcHQgPj4gMTMsIGMgPSBvcHQgJiA4MTkxO1xuICAgICAgICB2YXIgbXNrXzEgPSAoMSA8PCBwbHZsKSAtIDE7XG4gICAgICAgIC8vICAgIHByZXYgMi1ieXRlIHZhbCBtYXAgICAgY3VyciAyLWJ5dGUgdmFsIG1hcFxuICAgICAgICB2YXIgcHJldiA9IHN0LnAgfHwgbmV3IHUxNigzMjc2OCksIGhlYWQgPSBzdC5oIHx8IG5ldyB1MTYobXNrXzEgKyAxKTtcbiAgICAgICAgdmFyIGJzMV8xID0gTWF0aC5jZWlsKHBsdmwgLyAzKSwgYnMyXzEgPSAyICogYnMxXzE7XG4gICAgICAgIHZhciBoc2ggPSBmdW5jdGlvbiAoaSkgeyByZXR1cm4gKGRhdFtpXSBeIChkYXRbaSArIDFdIDw8IGJzMV8xKSBeIChkYXRbaSArIDJdIDw8IGJzMl8xKSkgJiBtc2tfMTsgfTtcbiAgICAgICAgLy8gMjQ1NzYgaXMgYW4gYXJiaXRyYXJ5IG51bWJlciBvZiBtYXhpbXVtIHN5bWJvbHMgcGVyIGJsb2NrXG4gICAgICAgIC8vIDQyNCBidWZmZXIgZm9yIGxhc3QgYmxvY2tcbiAgICAgICAgdmFyIHN5bXMgPSBuZXcgaTMyKDI1MDAwKTtcbiAgICAgICAgLy8gbGVuZ3RoL2xpdGVyYWwgZnJlcSAgIGRpc3RhbmNlIGZyZXFcbiAgICAgICAgdmFyIGxmID0gbmV3IHUxNigyODgpLCBkZiA9IG5ldyB1MTYoMzIpO1xuICAgICAgICAvLyAgbC9sY250ICBleGJpdHMgIGluZGV4ICAgICAgICAgIGwvbGluZCAgd2FpdGR4ICAgICAgICAgIGJsa3Bvc1xuICAgICAgICB2YXIgbGNfMSA9IDAsIGViID0gMCwgaSA9IHN0LmkgfHwgMCwgbGkgPSAwLCB3aSA9IHN0LncgfHwgMCwgYnMgPSAwO1xuICAgICAgICBmb3IgKDsgaSArIDIgPCBzOyArK2kpIHtcbiAgICAgICAgICAgIC8vIGhhc2ggdmFsdWVcbiAgICAgICAgICAgIHZhciBodiA9IGhzaChpKTtcbiAgICAgICAgICAgIC8vIGluZGV4IG1vZCAzMjc2OCAgICBwcmV2aW91cyBpbmRleCBtb2RcbiAgICAgICAgICAgIHZhciBpbW9kID0gaSAmIDMyNzY3LCBwaW1vZCA9IGhlYWRbaHZdO1xuICAgICAgICAgICAgcHJldltpbW9kXSA9IHBpbW9kO1xuICAgICAgICAgICAgaGVhZFtodl0gPSBpbW9kO1xuICAgICAgICAgICAgLy8gV2UgYWx3YXlzIHNob3VsZCBtb2RpZnkgaGVhZCBhbmQgcHJldiwgYnV0IG9ubHkgYWRkIHN5bWJvbHMgaWZcbiAgICAgICAgICAgIC8vIHRoaXMgZGF0YSBpcyBub3QgeWV0IHByb2Nlc3NlZCAoXCJ3YWl0XCIgZm9yIHdhaXQgaW5kZXgpXG4gICAgICAgICAgICBpZiAod2kgPD0gaSkge1xuICAgICAgICAgICAgICAgIC8vIGJ5dGVzIHJlbWFpbmluZ1xuICAgICAgICAgICAgICAgIHZhciByZW0gPSBzIC0gaTtcbiAgICAgICAgICAgICAgICBpZiAoKGxjXzEgPiA3MDAwIHx8IGxpID4gMjQ1NzYpICYmIChyZW0gPiA0MjMgfHwgIWxzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gd2JsayhkYXQsIHcsIDAsIHN5bXMsIGxmLCBkZiwgZWIsIGxpLCBicywgaSAtIGJzLCBwb3MpO1xuICAgICAgICAgICAgICAgICAgICBsaSA9IGxjXzEgPSBlYiA9IDAsIGJzID0gaTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAyODY7ICsrailcbiAgICAgICAgICAgICAgICAgICAgICAgIGxmW2pdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAzMDsgKytqKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGZbal0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAgbGVuICAgIGRpc3QgICBjaGFpblxuICAgICAgICAgICAgICAgIHZhciBsID0gMiwgZCA9IDAsIGNoXzEgPSBjLCBkaWYgPSBpbW9kIC0gcGltb2QgJiAzMjc2NztcbiAgICAgICAgICAgICAgICBpZiAocmVtID4gMiAmJiBodiA9PSBoc2goaSAtIGRpZikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heG4gPSBNYXRoLm1pbihuLCByZW0pIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heGQgPSBNYXRoLm1pbigzMjc2NywgaSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1heCBwb3NzaWJsZSBsZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IGNhcHBlZCBhdCBkaWYgYmVjYXVzZSBkZWNvbXByZXNzb3JzIGltcGxlbWVudCBcInJvbGxpbmdcIiBpbmRleCBwb3B1bGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHZhciBtbCA9IE1hdGgubWluKDI1OCwgcmVtKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRpZiA8PSBtYXhkICYmIC0tY2hfMSAmJiBpbW9kICE9IHBpbW9kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0W2kgKyBsXSA9PSBkYXRbaSArIGwgLSBkaWZdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5sID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgbmwgPCBtbCAmJiBkYXRbaSArIG5sXSA9PSBkYXRbaSArIG5sIC0gZGlmXTsgKytubClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChubCA+IGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9IG5sLCBkID0gZGlmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBicmVhayBvdXQgZWFybHkgd2hlbiB3ZSByZWFjaCBcIm5pY2VcIiAod2UgYXJlIHNhdGlzZmllZCBlbm91Z2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChubCA+IG1heG4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm93LCBmaW5kIHRoZSByYXJlc3QgMi1ieXRlIHNlcXVlbmNlIHdpdGhpbiB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxlbmd0aCBvZiBsaXRlcmFscyBhbmQgc2VhcmNoIGZvciB0aGF0IGluc3RlYWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE11Y2ggZmFzdGVyIHRoYW4ganVzdCB1c2luZyB0aGUgc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1tZCA9IE1hdGgubWluKGRpZiwgbmwgLSAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtbWQ7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpID0gaSAtIGRpZiArIGogJiAzMjc2NztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwdGkgPSBwcmV2W3RpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZCA9IHRpIC0gcHRpICYgMzI3Njc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2QgPiBtZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZCA9IGNkLCBwaW1vZCA9IHRpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgdGhlIHByZXZpb3VzIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbW9kID0gcGltb2QsIHBpbW9kID0gcHJldltpbW9kXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZiArPSBpbW9kIC0gcGltb2QgJiAzMjc2NztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkIHdpbGwgYmUgbm9uemVybyBvbmx5IHdoZW4gYSBtYXRjaCB3YXMgZm91bmRcbiAgICAgICAgICAgICAgICBpZiAoZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSBib3RoIGRpc3QgYW5kIGxlbiBkYXRhIGluIG9uZSBpbnQzMlxuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhpcyBpcyByZWNvZ25pemVkIGFzIGEgbGVuL2Rpc3Qgd2l0aCAyOHRoIGJpdCAoMl4yOClcbiAgICAgICAgICAgICAgICAgICAgc3ltc1tsaSsrXSA9IDI2ODQzNTQ1NiB8IChyZXZmbFtsXSA8PCAxOCkgfCByZXZmZFtkXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbiA9IHJldmZsW2xdICYgMzEsIGRpbiA9IHJldmZkW2RdICYgMzE7XG4gICAgICAgICAgICAgICAgICAgIGViICs9IGZsZWJbbGluXSArIGZkZWJbZGluXTtcbiAgICAgICAgICAgICAgICAgICAgKytsZlsyNTcgKyBsaW5dO1xuICAgICAgICAgICAgICAgICAgICArK2RmW2Rpbl07XG4gICAgICAgICAgICAgICAgICAgIHdpID0gaSArIGw7XG4gICAgICAgICAgICAgICAgICAgICsrbGNfMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bXNbbGkrK10gPSBkYXRbaV07XG4gICAgICAgICAgICAgICAgICAgICsrbGZbZGF0W2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gTWF0aC5tYXgoaSwgd2kpOyBpIDwgczsgKytpKSB7XG4gICAgICAgICAgICBzeW1zW2xpKytdID0gZGF0W2ldO1xuICAgICAgICAgICAgKytsZltkYXRbaV1dO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IHdibGsoZGF0LCB3LCBsc3QsIHN5bXMsIGxmLCBkZiwgZWIsIGxpLCBicywgaSAtIGJzLCBwb3MpO1xuICAgICAgICBpZiAoIWxzdCkge1xuICAgICAgICAgICAgc3QuciA9IChwb3MgJiA3KSB8IHdbKHBvcyAvIDgpIHwgMF0gPDwgMztcbiAgICAgICAgICAgIC8vIHNoZnQocG9zKSBub3cgMSBsZXNzIGlmIHBvcyAmIDcgIT0gMFxuICAgICAgICAgICAgcG9zIC09IDc7XG4gICAgICAgICAgICBzdC5oID0gaGVhZCwgc3QucCA9IHByZXYsIHN0LmkgPSBpLCBzdC53ID0gd2k7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdC53IHx8IDA7IGkgPCBzICsgbHN0OyBpICs9IDY1NTM1KSB7XG4gICAgICAgICAgICAvLyBlbmRcbiAgICAgICAgICAgIHZhciBlID0gaSArIDY1NTM1O1xuICAgICAgICAgICAgaWYgKGUgPj0gcykge1xuICAgICAgICAgICAgICAgIC8vIHdyaXRlIGZpbmFsIGJsb2NrXG4gICAgICAgICAgICAgICAgd1socG9zIC8gOCkgfCAwXSA9IGxzdDtcbiAgICAgICAgICAgICAgICBlID0gcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IHdmYmxrKHcsIHBvcyArIDEsIGRhdC5zdWJhcnJheShpLCBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3QuaSA9IHM7XG4gICAgfVxuICAgIHJldHVybiBzbGMobywgMCwgcHJlICsgc2hmdChwb3MpICsgcG9zdCk7XG59O1xuLy8gQ1JDMzIgdGFibGVcbnZhciBjcmN0ID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ID0gbmV3IEludDMyQXJyYXkoMjU2KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gICAgICAgIHZhciBjID0gaSwgayA9IDk7XG4gICAgICAgIHdoaWxlICgtLWspXG4gICAgICAgICAgICBjID0gKChjICYgMSkgJiYgLTMwNjY3NDkxMikgXiAoYyA+Pj4gMSk7XG4gICAgICAgIHRbaV0gPSBjO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbn0pKCk7XG4vLyBDUkMzMlxudmFyIGNyYyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYyA9IC0xO1xuICAgIHJldHVybiB7XG4gICAgICAgIHA6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAvLyBjbG9zdXJlcyBoYXZlIGF3ZnVsIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICB2YXIgY3IgPSBjO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIGNyID0gY3JjdFsoY3IgJiAyNTUpIF4gZFtpXV0gXiAoY3IgPj4+IDgpO1xuICAgICAgICAgICAgYyA9IGNyO1xuICAgICAgICB9LFxuICAgICAgICBkOiBmdW5jdGlvbiAoKSB7IHJldHVybiB+YzsgfVxuICAgIH07XG59O1xuLy8gQWRsZXIzMlxudmFyIGFkbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhID0gMSwgYiA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcDogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIC8vIGNsb3N1cmVzIGhhdmUgYXdmdWwgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIHZhciBuID0gYSwgbSA9IGI7XG4gICAgICAgICAgICB2YXIgbCA9IGQubGVuZ3RoIHwgMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9IGw7KSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBNYXRoLm1pbihpICsgMjY1NSwgbCk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBlOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIG0gKz0gbiArPSBkW2ldO1xuICAgICAgICAgICAgICAgIG4gPSAobiAmIDY1NTM1KSArIDE1ICogKG4gPj4gMTYpLCBtID0gKG0gJiA2NTUzNSkgKyAxNSAqIChtID4+IDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGEgPSBuLCBiID0gbTtcbiAgICAgICAgfSxcbiAgICAgICAgZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYSAlPSA2NTUyMSwgYiAlPSA2NTUyMTtcbiAgICAgICAgICAgIHJldHVybiAoYSAmIDI1NSkgPDwgMjQgfCAoYSAmIDB4RkYwMCkgPDwgOCB8IChiICYgMjU1KSA8PCA4IHwgKGIgPj4gOCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbjtcbi8vIGRlZmxhdGUgd2l0aCBvcHRzXG52YXIgZG9wdCA9IGZ1bmN0aW9uIChkYXQsIG9wdCwgcHJlLCBwb3N0LCBzdCkge1xuICAgIGlmICghc3QpIHtcbiAgICAgICAgc3QgPSB7IGw6IDEgfTtcbiAgICAgICAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgICAgICAgICB2YXIgZGljdCA9IG9wdC5kaWN0aW9uYXJ5LnN1YmFycmF5KC0zMjc2OCk7XG4gICAgICAgICAgICB2YXIgbmV3RGF0ID0gbmV3IHU4KGRpY3QubGVuZ3RoICsgZGF0Lmxlbmd0aCk7XG4gICAgICAgICAgICBuZXdEYXQuc2V0KGRpY3QpO1xuICAgICAgICAgICAgbmV3RGF0LnNldChkYXQsIGRpY3QubGVuZ3RoKTtcbiAgICAgICAgICAgIGRhdCA9IG5ld0RhdDtcbiAgICAgICAgICAgIHN0LncgPSBkaWN0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGZsdChkYXQsIG9wdC5sZXZlbCA9PSBudWxsID8gNiA6IG9wdC5sZXZlbCwgb3B0Lm1lbSA9PSBudWxsID8gKHN0LmwgPyBNYXRoLmNlaWwoTWF0aC5tYXgoOCwgTWF0aC5taW4oMTMsIE1hdGgubG9nKGRhdC5sZW5ndGgpKSkgKiAxLjUpIDogMjApIDogKDEyICsgb3B0Lm1lbSksIHByZSwgcG9zdCwgc3QpO1xufTtcbi8vIFdhbG1hcnQgb2JqZWN0IHNwcmVhZFxudmFyIG1yZyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIG8gPSB7fTtcbiAgICBmb3IgKHZhciBrIGluIGEpXG4gICAgICAgIG9ba10gPSBhW2tdO1xuICAgIGZvciAodmFyIGsgaW4gYilcbiAgICAgICAgb1trXSA9IGJba107XG4gICAgcmV0dXJuIG87XG59O1xuLy8gd29ya2VyIGNsb25lXG4vLyBUaGlzIGlzIHBvc3NpYmx5IHRoZSBjcmF6aWVzdCBwYXJ0IG9mIHRoZSBlbnRpcmUgY29kZWJhc2UsIGRlc3BpdGUgaG93IHNpbXBsZSBpdCBtYXkgc2VlbS5cbi8vIFRoZSBvbmx5IHBhcmFtZXRlciB0byB0aGlzIGZ1bmN0aW9uIGlzIGEgY2xvc3VyZSB0aGF0IHJldHVybnMgYW4gYXJyYXkgb2YgdmFyaWFibGVzIG91dHNpZGUgb2YgdGhlIGZ1bmN0aW9uIHNjb3BlLlxuLy8gV2UncmUgZ29pbmcgdG8gdHJ5IHRvIGZpZ3VyZSBvdXQgdGhlIHZhcmlhYmxlIG5hbWVzIHVzZWQgaW4gdGhlIGNsb3N1cmUgYXMgc3RyaW5ncyBiZWNhdXNlIHRoYXQgaXMgY3J1Y2lhbCBmb3Igd29ya2VyaXphdGlvbi5cbi8vIFdlIHdpbGwgcmV0dXJuIGFuIG9iamVjdCBtYXBwaW5nIG9mIHRydWUgdmFyaWFibGUgbmFtZSB0byB2YWx1ZSAoYmFzaWNhbGx5LCB0aGUgY3VycmVudCBzY29wZSBhcyBhIEpTIG9iamVjdCkuXG4vLyBUaGUgcmVhc29uIHdlIGNhbid0IGp1c3QgdXNlIHRoZSBvcmlnaW5hbCB2YXJpYWJsZSBuYW1lcyBpcyBtaW5pZmllcnMgbWFuZ2xpbmcgdGhlIHRvcGxldmVsIHNjb3BlLlxuLy8gVGhpcyB0b29rIG1lIHRocmVlIHdlZWtzIHRvIGZpZ3VyZSBvdXQgaG93IHRvIGRvLlxudmFyIHdjbG4gPSBmdW5jdGlvbiAoZm4sIGZuU3RyLCB0ZCkge1xuICAgIHZhciBkdCA9IGZuKCk7XG4gICAgdmFyIHN0ID0gZm4udG9TdHJpbmcoKTtcbiAgICB2YXIga3MgPSBzdC5zbGljZShzdC5pbmRleE9mKCdbJykgKyAxLCBzdC5sYXN0SW5kZXhPZignXScpKS5yZXBsYWNlKC9cXHMrL2csICcnKS5zcGxpdCgnLCcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHYgPSBkdFtpXSwgayA9IGtzW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZm5TdHIgKz0gJzsnICsgayArICc9JztcbiAgICAgICAgICAgIHZhciBzdF8xID0gdi50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKHYucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGdsb2JhbCBvYmplY3RzXG4gICAgICAgICAgICAgICAgaWYgKHN0XzEuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcEluZCA9IHN0XzEuaW5kZXhPZignICcsIDgpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgZm5TdHIgKz0gc3RfMS5zbGljZShzcEluZCwgc3RfMS5pbmRleE9mKCcoJywgc3BJbmQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZuU3RyICs9IHN0XzE7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQgaW4gdi5wcm90b3R5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBmblN0ciArPSAnOycgKyBrICsgJy5wcm90b3R5cGUuJyArIHQgKyAnPScgKyB2LnByb3RvdHlwZVt0XS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBmblN0ciArPSBzdF8xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRkW2tdID0gdjtcbiAgICB9XG4gICAgcmV0dXJuIGZuU3RyO1xufTtcbnZhciBjaCA9IFtdO1xuLy8gY2xvbmUgYnVmc1xudmFyIGNiZnMgPSBmdW5jdGlvbiAodikge1xuICAgIHZhciB0bCA9IFtdO1xuICAgIGZvciAodmFyIGsgaW4gdikge1xuICAgICAgICBpZiAodltrXS5idWZmZXIpIHtcbiAgICAgICAgICAgIHRsLnB1c2goKHZba10gPSBuZXcgdltrXS5jb25zdHJ1Y3Rvcih2W2tdKSkuYnVmZmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGw7XG59O1xuLy8gdXNlIGEgd29ya2VyIHRvIGV4ZWN1dGUgY29kZVxudmFyIHdya3IgPSBmdW5jdGlvbiAoZm5zLCBpbml0LCBpZCwgY2IpIHtcbiAgICBpZiAoIWNoW2lkXSkge1xuICAgICAgICB2YXIgZm5TdHIgPSAnJywgdGRfMSA9IHt9LCBtID0gZm5zLmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbTsgKytpKVxuICAgICAgICAgICAgZm5TdHIgPSB3Y2xuKGZuc1tpXSwgZm5TdHIsIHRkXzEpO1xuICAgICAgICBjaFtpZF0gPSB7IGM6IHdjbG4oZm5zW21dLCBmblN0ciwgdGRfMSksIGU6IHRkXzEgfTtcbiAgICB9XG4gICAgdmFyIHRkID0gbXJnKHt9LCBjaFtpZF0uZSk7XG4gICAgcmV0dXJuIHdrKGNoW2lkXS5jICsgJztvbm1lc3NhZ2U9ZnVuY3Rpb24oZSl7Zm9yKHZhciBrIGluIGUuZGF0YSlzZWxmW2tdPWUuZGF0YVtrXTtvbm1lc3NhZ2U9JyArIGluaXQudG9TdHJpbmcoKSArICd9JywgaWQsIHRkLCBjYmZzKHRkKSwgY2IpO1xufTtcbi8vIGJhc2UgYXN5bmMgaW5mbGF0ZSBmblxudmFyIGJJbmZsdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt1OCwgdTE2LCBpMzIsIGZsZWIsIGZkZWIsIGNsaW0sIGZsLCBmZCwgZmxybSwgZmRybSwgcmV2LCBlYywgaE1hcCwgbWF4LCBiaXRzLCBiaXRzMTYsIHNoZnQsIHNsYywgZXJyLCBpbmZsdCwgaW5mbGF0ZVN5bmMsIHBiZiwgZ29wdF07IH07XG52YXIgYkRmbHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbdTgsIHUxNiwgaTMyLCBmbGViLCBmZGViLCBjbGltLCByZXZmbCwgcmV2ZmQsIGZsbSwgZmx0LCBmZG0sIGZkdCwgcmV2LCBkZW8sIGV0LCBoTWFwLCB3Yml0cywgd2JpdHMxNiwgaFRyZWUsIGxuLCBsYywgY2xlbiwgd2ZibGssIHdibGssIHNoZnQsIHNsYywgZGZsdCwgZG9wdCwgZGVmbGF0ZVN5bmMsIHBiZl07IH07XG4vLyBnemlwIGV4dHJhXG52YXIgZ3plID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW2d6aCwgZ3pobCwgd2J5dGVzLCBjcmMsIGNyY3RdOyB9O1xuLy8gZ3VuemlwIGV4dHJhXG52YXIgZ3V6ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtnenMsIGd6bF07IH07XG4vLyB6bGliIGV4dHJhXG52YXIgemxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW3psaCwgd2J5dGVzLCBhZGxlcl07IH07XG4vLyB1bnpsaWIgZXh0cmFcbnZhciB6dWxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW3psc107IH07XG4vLyBwb3N0IGJ1ZlxudmFyIHBiZiA9IGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHBvc3RNZXNzYWdlKG1zZywgW21zZy5idWZmZXJdKTsgfTtcbi8vIGdldCBvcHRzXG52YXIgZ29wdCA9IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIHtcbiAgICBvdXQ6IG8uc2l6ZSAmJiBuZXcgdTgoby5zaXplKSxcbiAgICBkaWN0aW9uYXJ5OiBvLmRpY3Rpb25hcnlcbn07IH07XG4vLyBhc3luYyBoZWxwZXJcbnZhciBjYmlmeSA9IGZ1bmN0aW9uIChkYXQsIG9wdHMsIGZucywgaW5pdCwgaWQsIGNiKSB7XG4gICAgdmFyIHcgPSB3cmtyKGZucywgaW5pdCwgaWQsIGZ1bmN0aW9uIChlcnIsIGRhdCkge1xuICAgICAgICB3LnRlcm1pbmF0ZSgpO1xuICAgICAgICBjYihlcnIsIGRhdCk7XG4gICAgfSk7XG4gICAgdy5wb3N0TWVzc2FnZShbZGF0LCBvcHRzXSwgb3B0cy5jb25zdW1lID8gW2RhdC5idWZmZXJdIDogW10pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHcudGVybWluYXRlKCk7IH07XG59O1xuLy8gYXV0byBzdHJlYW1cbnZhciBhc3RybSA9IGZ1bmN0aW9uIChzdHJtKSB7XG4gICAgc3RybS5vbmRhdGEgPSBmdW5jdGlvbiAoZGF0LCBmaW5hbCkgeyByZXR1cm4gcG9zdE1lc3NhZ2UoW2RhdCwgZmluYWxdLCBbZGF0LmJ1ZmZlcl0pOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgaWYgKGV2LmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdHJtLnB1c2goZXYuZGF0YVswXSwgZXYuZGF0YVsxXSk7XG4gICAgICAgICAgICBwb3N0TWVzc2FnZShbZXYuZGF0YVswXS5sZW5ndGhdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzdHJtLmZsdXNoKCk7XG4gICAgfTtcbn07XG4vLyBhc3luYyBzdHJlYW0gYXR0YWNoXG52YXIgYXN0cm1pZnkgPSBmdW5jdGlvbiAoZm5zLCBzdHJtLCBvcHRzLCBpbml0LCBpZCwgZmx1c2gsIGV4dCkge1xuICAgIHZhciB0O1xuICAgIHZhciB3ID0gd3JrcihmbnMsIGluaXQsIGlkLCBmdW5jdGlvbiAoZXJyLCBkYXQpIHtcbiAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgIHcudGVybWluYXRlKCksIHN0cm0ub25kYXRhLmNhbGwoc3RybSwgZXJyKTtcbiAgICAgICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZGF0KSlcbiAgICAgICAgICAgIGV4dChkYXQpO1xuICAgICAgICBlbHNlIGlmIChkYXQubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHN0cm0ucXVldWVkU2l6ZSAtPSBkYXRbMF07XG4gICAgICAgICAgICBpZiAoc3RybS5vbmRyYWluKVxuICAgICAgICAgICAgICAgIHN0cm0ub25kcmFpbihkYXRbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRhdFsxXSlcbiAgICAgICAgICAgICAgICB3LnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgc3RybS5vbmRhdGEuY2FsbChzdHJtLCBlcnIsIGRhdFswXSwgZGF0WzFdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHcucG9zdE1lc3NhZ2Uob3B0cyk7XG4gICAgc3RybS5xdWV1ZWRTaXplID0gMDtcbiAgICBzdHJtLnB1c2ggPSBmdW5jdGlvbiAoZCwgZikge1xuICAgICAgICBpZiAoIXN0cm0ub25kYXRhKVxuICAgICAgICAgICAgZXJyKDUpO1xuICAgICAgICBpZiAodClcbiAgICAgICAgICAgIHN0cm0ub25kYXRhKGVycig0LCAwLCAxKSwgbnVsbCwgISFmKTtcbiAgICAgICAgc3RybS5xdWV1ZWRTaXplICs9IGQubGVuZ3RoO1xuICAgICAgICB3LnBvc3RNZXNzYWdlKFtkLCB0ID0gZl0sIFtkLmJ1ZmZlcl0pO1xuICAgIH07XG4gICAgc3RybS50ZXJtaW5hdGUgPSBmdW5jdGlvbiAoKSB7IHcudGVybWluYXRlKCk7IH07XG4gICAgaWYgKGZsdXNoKSB7XG4gICAgICAgIHN0cm0uZmx1c2ggPSBmdW5jdGlvbiAoKSB7IHcucG9zdE1lc3NhZ2UoW10pOyB9O1xuICAgIH1cbn07XG4vLyByZWFkIDIgYnl0ZXNcbnZhciBiMiA9IGZ1bmN0aW9uIChkLCBiKSB7IHJldHVybiBkW2JdIHwgKGRbYiArIDFdIDw8IDgpOyB9O1xuLy8gcmVhZCA0IGJ5dGVzXG52YXIgYjQgPSBmdW5jdGlvbiAoZCwgYikgeyByZXR1cm4gKGRbYl0gfCAoZFtiICsgMV0gPDwgOCkgfCAoZFtiICsgMl0gPDwgMTYpIHwgKGRbYiArIDNdIDw8IDI0KSkgPj4+IDA7IH07XG52YXIgYjggPSBmdW5jdGlvbiAoZCwgYikgeyByZXR1cm4gYjQoZCwgYikgKyAoYjQoZCwgYiArIDQpICogNDI5NDk2NzI5Nik7IH07XG4vLyB3cml0ZSBieXRlc1xudmFyIHdieXRlcyA9IGZ1bmN0aW9uIChkLCBiLCB2KSB7XG4gICAgZm9yICg7IHY7ICsrYilcbiAgICAgICAgZFtiXSA9IHYsIHYgPj4+PSA4O1xufTtcbi8vIGd6aXAgaGVhZGVyXG52YXIgZ3poID0gZnVuY3Rpb24gKGMsIG8pIHtcbiAgICB2YXIgZm4gPSBvLmZpbGVuYW1lO1xuICAgIGNbMF0gPSAzMSwgY1sxXSA9IDEzOSwgY1syXSA9IDgsIGNbOF0gPSBvLmxldmVsIDwgMiA/IDQgOiBvLmxldmVsID09IDkgPyAyIDogMCwgY1s5XSA9IDM7IC8vIGFzc3VtZSBVbml4XG4gICAgaWYgKG8ubXRpbWUgIT0gMClcbiAgICAgICAgd2J5dGVzKGMsIDQsIE1hdGguZmxvb3IobmV3IERhdGUoby5tdGltZSB8fCBEYXRlLm5vdygpKSAvIDEwMDApKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgICAgY1szXSA9IDg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGZuLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgY1tpICsgMTBdID0gZm4uY2hhckNvZGVBdChpKTtcbiAgICB9XG59O1xuLy8gZ3ppcCBmb290ZXI6IC04IHRvIC00ID0gQ1JDLCAtNCB0byAtMCBpcyBsZW5ndGhcbi8vIGd6aXAgc3RhcnRcbnZhciBnenMgPSBmdW5jdGlvbiAoZCkge1xuICAgIGlmIChkWzBdICE9IDMxIHx8IGRbMV0gIT0gMTM5IHx8IGRbMl0gIT0gOClcbiAgICAgICAgZXJyKDYsICdpbnZhbGlkIGd6aXAgZGF0YScpO1xuICAgIHZhciBmbGcgPSBkWzNdO1xuICAgIHZhciBzdCA9IDEwO1xuICAgIGlmIChmbGcgJiA0KVxuICAgICAgICBzdCArPSAoZFsxMF0gfCBkWzExXSA8PCA4KSArIDI7XG4gICAgZm9yICh2YXIgenMgPSAoZmxnID4+IDMgJiAxKSArIChmbGcgPj4gNCAmIDEpOyB6cyA+IDA7IHpzIC09ICFkW3N0KytdKVxuICAgICAgICA7XG4gICAgcmV0dXJuIHN0ICsgKGZsZyAmIDIpO1xufTtcbi8vIGd6aXAgbGVuZ3RoXG52YXIgZ3psID0gZnVuY3Rpb24gKGQpIHtcbiAgICB2YXIgbCA9IGQubGVuZ3RoO1xuICAgIHJldHVybiAoZFtsIC0gNF0gfCBkW2wgLSAzXSA8PCA4IHwgZFtsIC0gMl0gPDwgMTYgfCBkW2wgLSAxXSA8PCAyNCkgPj4+IDA7XG59O1xuLy8gZ3ppcCBoZWFkZXIgbGVuZ3RoXG52YXIgZ3pobCA9IGZ1bmN0aW9uIChvKSB7IHJldHVybiAxMCArIChvLmZpbGVuYW1lID8gby5maWxlbmFtZS5sZW5ndGggKyAxIDogMCk7IH07XG4vLyB6bGliIGhlYWRlclxudmFyIHpsaCA9IGZ1bmN0aW9uIChjLCBvKSB7XG4gICAgdmFyIGx2ID0gby5sZXZlbCwgZmwgPSBsdiA9PSAwID8gMCA6IGx2IDwgNiA/IDEgOiBsdiA9PSA5ID8gMyA6IDI7XG4gICAgY1swXSA9IDEyMCwgY1sxXSA9IChmbCA8PCA2KSB8IChvLmRpY3Rpb25hcnkgJiYgMzIpO1xuICAgIGNbMV0gfD0gMzEgLSAoKGNbMF0gPDwgOCkgfCBjWzFdKSAlIDMxO1xuICAgIGlmIChvLmRpY3Rpb25hcnkpIHtcbiAgICAgICAgdmFyIGggPSBhZGxlcigpO1xuICAgICAgICBoLnAoby5kaWN0aW9uYXJ5KTtcbiAgICAgICAgd2J5dGVzKGMsIDIsIGguZCgpKTtcbiAgICB9XG59O1xuLy8gemxpYiBzdGFydFxudmFyIHpscyA9IGZ1bmN0aW9uIChkLCBkaWN0KSB7XG4gICAgaWYgKChkWzBdICYgMTUpICE9IDggfHwgKGRbMF0gPj4gNCkgPiA3IHx8ICgoZFswXSA8PCA4IHwgZFsxXSkgJSAzMSkpXG4gICAgICAgIGVycig2LCAnaW52YWxpZCB6bGliIGRhdGEnKTtcbiAgICBpZiAoKGRbMV0gPj4gNSAmIDEpID09ICshZGljdClcbiAgICAgICAgZXJyKDYsICdpbnZhbGlkIHpsaWIgZGF0YTogJyArIChkWzFdICYgMzIgPyAnbmVlZCcgOiAndW5leHBlY3RlZCcpICsgJyBkaWN0aW9uYXJ5Jyk7XG4gICAgcmV0dXJuIChkWzFdID4+IDMgJiA0KSArIDI7XG59O1xuZnVuY3Rpb24gU3RybU9wdChvcHRzLCBjYikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PSAnZnVuY3Rpb24nKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgIHJldHVybiBvcHRzO1xufVxuLyoqXG4gKiBTdHJlYW1pbmcgREVGTEFURSBjb21wcmVzc2lvblxuICovXG52YXIgRGVmbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZsYXRlKG9wdHMsIGNiKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cyA9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgICAgIHRoaXMubyA9IG9wdHMgfHwge307XG4gICAgICAgIHRoaXMucyA9IHsgbDogMCwgaTogMzI3NjgsIHc6IDMyNzY4LCB6OiAzMjc2OCB9O1xuICAgICAgICAvLyBCdWZmZXIgbGVuZ3RoIG11c3QgYWx3YXlzIGJlIDAgbW9kIDMyNzY4IGZvciBpbmRleCBjYWxjdWxhdGlvbnMgdG8gYmUgY29ycmVjdCB3aGVuIG1vZGlmeWluZyBoZWFkIGFuZCBwcmV2XG4gICAgICAgIC8vIDk4MzA0ID0gMzI3NjggKGxvb2tiYWNrKSArIDY1NTM2IChjb21tb24gY2h1bmsgc2l6ZSlcbiAgICAgICAgdGhpcy5iID0gbmV3IHU4KDk4MzA0KTtcbiAgICAgICAgaWYgKHRoaXMuby5kaWN0aW9uYXJ5KSB7XG4gICAgICAgICAgICB2YXIgZGljdCA9IHRoaXMuby5kaWN0aW9uYXJ5LnN1YmFycmF5KC0zMjc2OCk7XG4gICAgICAgICAgICB0aGlzLmIuc2V0KGRpY3QsIDMyNzY4IC0gZGljdC5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5zLmkgPSAzMjc2OCAtIGRpY3QubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIERlZmxhdGUucHJvdG90eXBlLnAgPSBmdW5jdGlvbiAoYywgZikge1xuICAgICAgICB0aGlzLm9uZGF0YShkb3B0KGMsIHRoaXMubywgMCwgMCwgdGhpcy5zKSwgZik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWZsYXRlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBEZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgZXJyKDUpO1xuICAgICAgICBpZiAodGhpcy5zLmwpXG4gICAgICAgICAgICBlcnIoNCk7XG4gICAgICAgIHZhciBlbmRMZW4gPSBjaHVuay5sZW5ndGggKyB0aGlzLnMuejtcbiAgICAgICAgaWYgKGVuZExlbiA+IHRoaXMuYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChlbmRMZW4gPiAyICogdGhpcy5iLmxlbmd0aCAtIDMyNzY4KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0J1ZiA9IG5ldyB1OChlbmRMZW4gJiAtMzI3NjgpO1xuICAgICAgICAgICAgICAgIG5ld0J1Zi5zZXQodGhpcy5iLnN1YmFycmF5KDAsIHRoaXMucy56KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5iID0gbmV3QnVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNwbGl0ID0gdGhpcy5iLmxlbmd0aCAtIHRoaXMucy56O1xuICAgICAgICAgICAgdGhpcy5iLnNldChjaHVuay5zdWJhcnJheSgwLCBzcGxpdCksIHRoaXMucy56KTtcbiAgICAgICAgICAgIHRoaXMucy56ID0gdGhpcy5iLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMucCh0aGlzLmIsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuYi5zZXQodGhpcy5iLnN1YmFycmF5KC0zMjc2OCkpO1xuICAgICAgICAgICAgdGhpcy5iLnNldChjaHVuay5zdWJhcnJheShzcGxpdCksIDMyNzY4KTtcbiAgICAgICAgICAgIHRoaXMucy56ID0gY2h1bmsubGVuZ3RoIC0gc3BsaXQgKyAzMjc2ODtcbiAgICAgICAgICAgIHRoaXMucy5pID0gMzI3NjYsIHRoaXMucy53ID0gMzI3Njg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmIuc2V0KGNodW5rLCB0aGlzLnMueik7XG4gICAgICAgICAgICB0aGlzLnMueiArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zLmwgPSBmaW5hbCAmIDE7XG4gICAgICAgIGlmICh0aGlzLnMueiA+IHRoaXMucy53ICsgODE5MSB8fCBmaW5hbCkge1xuICAgICAgICAgICAgdGhpcy5wKHRoaXMuYiwgZmluYWwgfHwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5zLncgPSB0aGlzLnMuaSwgdGhpcy5zLmkgLT0gMjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRmx1c2hlcyBidWZmZXJlZCB1bmNvbXByZXNzZWQgZGF0YS4gVXNlZnVsIHRvIGltbWVkaWF0ZWx5IHJldHJpZXZlIHRoZVxuICAgICAqIGRlZmxhdGVkIG91dHB1dCBmb3Igc21hbGwgaW5wdXRzLlxuICAgICAqL1xuICAgIERlZmxhdGUucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgZXJyKDUpO1xuICAgICAgICBpZiAodGhpcy5zLmwpXG4gICAgICAgICAgICBlcnIoNCk7XG4gICAgICAgIHRoaXMucCh0aGlzLmIsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zLncgPSB0aGlzLnMuaSwgdGhpcy5zLmkgLT0gMjtcbiAgICB9O1xuICAgIHJldHVybiBEZWZsYXRlO1xufSgpKTtcbmV4cG9ydCB7IERlZmxhdGUgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBERUZMQVRFIGNvbXByZXNzaW9uXG4gKi9cbnZhciBBc3luY0RlZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXN5bmNEZWZsYXRlKG9wdHMsIGNiKSB7XG4gICAgICAgIGFzdHJtaWZ5KFtcbiAgICAgICAgICAgIGJEZmx0LFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW2FzdHJtLCBEZWZsYXRlXTsgfVxuICAgICAgICBdLCB0aGlzLCBTdHJtT3B0LmNhbGwodGhpcywgb3B0cywgY2IpLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzdHJtID0gbmV3IERlZmxhdGUoZXYuZGF0YSk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgNiwgMSk7XG4gICAgfVxuICAgIHJldHVybiBBc3luY0RlZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNEZWZsYXRlIH07XG5leHBvcnQgZnVuY3Rpb24gZGVmbGF0ZShkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgZXJyKDcpO1xuICAgIHJldHVybiBjYmlmeShkYXRhLCBvcHRzLCBbXG4gICAgICAgIGJEZmx0LFxuICAgIF0sIGZ1bmN0aW9uIChldikgeyByZXR1cm4gcGJmKGRlZmxhdGVTeW5jKGV2LmRhdGFbMF0sIGV2LmRhdGFbMV0pKTsgfSwgMCwgY2IpO1xufVxuLyoqXG4gKiBDb21wcmVzc2VzIGRhdGEgd2l0aCBERUZMQVRFIHdpdGhvdXQgYW55IHdyYXBwZXJcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGNvbXByZXNzXG4gKiBAcGFyYW0gb3B0cyBUaGUgY29tcHJlc3Npb24gb3B0aW9uc1xuICogQHJldHVybnMgVGhlIGRlZmxhdGVkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmxhdGVTeW5jKGRhdGEsIG9wdHMpIHtcbiAgICByZXR1cm4gZG9wdChkYXRhLCBvcHRzIHx8IHt9LCAwLCAwKTtcbn1cbi8qKlxuICogU3RyZWFtaW5nIERFRkxBVEUgZGVjb21wcmVzc2lvblxuICovXG52YXIgSW5mbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbmZsYXRlKG9wdHMsIGNiKSB7XG4gICAgICAgIC8vIG5vIFN0cm1PcHQgaGVyZSB0byBhdm9pZCBhZGRpbmcgdG8gd29ya2VyaXplclxuICAgICAgICBpZiAodHlwZW9mIG9wdHMgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgICAgICB2YXIgZGljdCA9IG9wdHMgJiYgb3B0cy5kaWN0aW9uYXJ5ICYmIG9wdHMuZGljdGlvbmFyeS5zdWJhcnJheSgtMzI3NjgpO1xuICAgICAgICB0aGlzLnMgPSB7IGk6IDAsIGI6IGRpY3QgPyBkaWN0Lmxlbmd0aCA6IDAgfTtcbiAgICAgICAgdGhpcy5vID0gbmV3IHU4KDMyNzY4KTtcbiAgICAgICAgdGhpcy5wID0gbmV3IHU4KDApO1xuICAgICAgICBpZiAoZGljdClcbiAgICAgICAgICAgIHRoaXMuby5zZXQoZGljdCk7XG4gICAgfVxuICAgIEluZmxhdGUucHJvdG90eXBlLmUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgZXJyKDUpO1xuICAgICAgICBpZiAodGhpcy5kKVxuICAgICAgICAgICAgZXJyKDQpO1xuICAgICAgICBpZiAoIXRoaXMucC5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnAgPSBjO1xuICAgICAgICBlbHNlIGlmIChjLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG4gPSBuZXcgdTgodGhpcy5wLmxlbmd0aCArIGMubGVuZ3RoKTtcbiAgICAgICAgICAgIG4uc2V0KHRoaXMucCksIG4uc2V0KGMsIHRoaXMucC5sZW5ndGgpLCB0aGlzLnAgPSBuO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmZsYXRlLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKGZpbmFsKSB7XG4gICAgICAgIHRoaXMucy5pID0gKyh0aGlzLmQgPSBmaW5hbCB8fCBmYWxzZSk7XG4gICAgICAgIHZhciBidHMgPSB0aGlzLnMuYjtcbiAgICAgICAgdmFyIGR0ID0gaW5mbHQodGhpcy5wLCB0aGlzLnMsIHRoaXMubyk7XG4gICAgICAgIHRoaXMub25kYXRhKHNsYyhkdCwgYnRzLCB0aGlzLnMuYiksIHRoaXMuZCk7XG4gICAgICAgIHRoaXMubyA9IHNsYyhkdCwgdGhpcy5zLmIgLSAzMjc2OCksIHRoaXMucy5iID0gdGhpcy5vLmxlbmd0aDtcbiAgICAgICAgdGhpcy5wID0gc2xjKHRoaXMucCwgKHRoaXMucy5wIC8gOCkgfCAwKSwgdGhpcy5zLnAgJj0gNztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGluZmxhdGVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgZmluYWwgY2h1bmtcbiAgICAgKi9cbiAgICBJbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICB0aGlzLmUoY2h1bmspLCB0aGlzLmMoZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIEluZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgSW5mbGF0ZSB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIERFRkxBVEUgZGVjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNJbmZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFzeW5jSW5mbGF0ZShvcHRzLCBjYikge1xuICAgICAgICBhc3RybWlmeShbXG4gICAgICAgICAgICBiSW5mbHQsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIEluZmxhdGVdOyB9XG4gICAgICAgIF0sIHRoaXMsIFN0cm1PcHQuY2FsbCh0aGlzLCBvcHRzLCBjYiksIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHN0cm0gPSBuZXcgSW5mbGF0ZShldi5kYXRhKTtcbiAgICAgICAgICAgIG9ubWVzc2FnZSA9IGFzdHJtKHN0cm0pO1xuICAgICAgICB9LCA3LCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIEFzeW5jSW5mbGF0ZTtcbn0oKSk7XG5leHBvcnQgeyBBc3luY0luZmxhdGUgfTtcbmV4cG9ydCBmdW5jdGlvbiBpbmZsYXRlKGRhdGEsIG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYilcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICBlcnIoNyk7XG4gICAgcmV0dXJuIGNiaWZ5KGRhdGEsIG9wdHMsIFtcbiAgICAgICAgYkluZmx0XG4gICAgXSwgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBwYmYoaW5mbGF0ZVN5bmMoZXYuZGF0YVswXSwgZ29wdChldi5kYXRhWzFdKSkpOyB9LCAxLCBjYik7XG59XG4vKipcbiAqIEV4cGFuZHMgREVGTEFURSBkYXRhIHdpdGggbm8gd3JhcHBlclxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gZGVjb21wcmVzc1xuICogQHBhcmFtIG9wdHMgVGhlIGRlY29tcHJlc3Npb24gb3B0aW9uc1xuICogQHJldHVybnMgVGhlIGRlY29tcHJlc3NlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmZsYXRlU3luYyhkYXRhLCBvcHRzKSB7XG4gICAgcmV0dXJuIGluZmx0KGRhdGEsIHsgaTogMiB9LCBvcHRzICYmIG9wdHMub3V0LCBvcHRzICYmIG9wdHMuZGljdGlvbmFyeSk7XG59XG4vLyBiZWZvcmUgeW91IHllbGwgYXQgbWUgZm9yIG5vdCBqdXN0IHVzaW5nIGV4dGVuZHMsIG15IHJlYXNvbiBpcyB0aGF0IFRTIGluaGVyaXRhbmNlIGlzIGhhcmQgdG8gd29ya2VyaXplLlxuLyoqXG4gKiBTdHJlYW1pbmcgR1pJUCBjb21wcmVzc2lvblxuICovXG52YXIgR3ppcCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHemlwKG9wdHMsIGNiKSB7XG4gICAgICAgIHRoaXMuYyA9IGNyYygpO1xuICAgICAgICB0aGlzLmwgPSAwO1xuICAgICAgICB0aGlzLnYgPSAxO1xuICAgICAgICBEZWZsYXRlLmNhbGwodGhpcywgb3B0cywgY2IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBHWklQcGVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIEd6aXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHRoaXMuYy5wKGNodW5rKTtcbiAgICAgICAgdGhpcy5sICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgRGVmbGF0ZS5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICBHemlwLnByb3RvdHlwZS5wID0gZnVuY3Rpb24gKGMsIGYpIHtcbiAgICAgICAgdmFyIHJhdyA9IGRvcHQoYywgdGhpcy5vLCB0aGlzLnYgJiYgZ3pobCh0aGlzLm8pLCBmICYmIDgsIHRoaXMucyk7XG4gICAgICAgIGlmICh0aGlzLnYpXG4gICAgICAgICAgICBnemgocmF3LCB0aGlzLm8pLCB0aGlzLnYgPSAwO1xuICAgICAgICBpZiAoZilcbiAgICAgICAgICAgIHdieXRlcyhyYXcsIHJhdy5sZW5ndGggLSA4LCB0aGlzLmMuZCgpKSwgd2J5dGVzKHJhdywgcmF3Lmxlbmd0aCAtIDQsIHRoaXMubCk7XG4gICAgICAgIHRoaXMub25kYXRhKHJhdywgZik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGbHVzaGVzIGJ1ZmZlcmVkIHVuY29tcHJlc3NlZCBkYXRhLiBVc2VmdWwgdG8gaW1tZWRpYXRlbHkgcmV0cmlldmUgdGhlXG4gICAgICogR1pJUHBlZCBvdXRwdXQgZm9yIHNtYWxsIGlucHV0cy5cbiAgICAgKi9cbiAgICBHemlwLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgRGVmbGF0ZS5wcm90b3R5cGUuZmx1c2guY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBHemlwO1xufSgpKTtcbmV4cG9ydCB7IEd6aXAgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBHWklQIGNvbXByZXNzaW9uXG4gKi9cbnZhciBBc3luY0d6aXAgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXN5bmNHemlwKG9wdHMsIGNiKSB7XG4gICAgICAgIGFzdHJtaWZ5KFtcbiAgICAgICAgICAgIGJEZmx0LFxuICAgICAgICAgICAgZ3plLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW2FzdHJtLCBEZWZsYXRlLCBHemlwXTsgfVxuICAgICAgICBdLCB0aGlzLCBTdHJtT3B0LmNhbGwodGhpcywgb3B0cywgY2IpLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzdHJtID0gbmV3IEd6aXAoZXYuZGF0YSk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgOCwgMSk7XG4gICAgfVxuICAgIHJldHVybiBBc3luY0d6aXA7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNHemlwIH07XG5leHBvcnQgZnVuY3Rpb24gZ3ppcChkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgZXJyKDcpO1xuICAgIHJldHVybiBjYmlmeShkYXRhLCBvcHRzLCBbXG4gICAgICAgIGJEZmx0LFxuICAgICAgICBnemUsXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtnemlwU3luY107IH1cbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZihnemlwU3luYyhldi5kYXRhWzBdLCBldi5kYXRhWzFdKSk7IH0sIDIsIGNiKTtcbn1cbi8qKlxuICogQ29tcHJlc3NlcyBkYXRhIHdpdGggR1pJUFxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gY29tcHJlc3NcbiAqIEBwYXJhbSBvcHRzIFRoZSBjb21wcmVzc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgZ3ppcHBlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnemlwU3luYyhkYXRhLCBvcHRzKSB7XG4gICAgaWYgKCFvcHRzKVxuICAgICAgICBvcHRzID0ge307XG4gICAgdmFyIGMgPSBjcmMoKSwgbCA9IGRhdGEubGVuZ3RoO1xuICAgIGMucChkYXRhKTtcbiAgICB2YXIgZCA9IGRvcHQoZGF0YSwgb3B0cywgZ3pobChvcHRzKSwgOCksIHMgPSBkLmxlbmd0aDtcbiAgICByZXR1cm4gZ3poKGQsIG9wdHMpLCB3Ynl0ZXMoZCwgcyAtIDgsIGMuZCgpKSwgd2J5dGVzKGQsIHMgLSA0LCBsKSwgZDtcbn1cbi8qKlxuICogU3RyZWFtaW5nIHNpbmdsZSBvciBtdWx0aS1tZW1iZXIgR1pJUCBkZWNvbXByZXNzaW9uXG4gKi9cbnZhciBHdW56aXAgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3VuemlwKG9wdHMsIGNiKSB7XG4gICAgICAgIHRoaXMudiA9IDE7XG4gICAgICAgIHRoaXMuciA9IDA7XG4gICAgICAgIEluZmxhdGUuY2FsbCh0aGlzLCBvcHRzLCBjYik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIEdVTlpJUHBlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBHdW56aXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIEluZmxhdGUucHJvdG90eXBlLmUuY2FsbCh0aGlzLCBjaHVuayk7XG4gICAgICAgIHRoaXMuciArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLnYpIHtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5wLnN1YmFycmF5KHRoaXMudiAtIDEpO1xuICAgICAgICAgICAgdmFyIHMgPSBwLmxlbmd0aCA+IDMgPyBnenMocCkgOiA0O1xuICAgICAgICAgICAgaWYgKHMgPiBwLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICghZmluYWwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudiA+IDEgJiYgdGhpcy5vbm1lbWJlcikge1xuICAgICAgICAgICAgICAgIHRoaXMub25tZW1iZXIodGhpcy5yIC0gcC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wID0gcC5zdWJhcnJheShzKSwgdGhpcy52ID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBuZWNlc3NhcnkgdG8gcHJldmVudCBUUyBmcm9tIHVzaW5nIHRoZSBjbG9zdXJlIHZhbHVlXG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIGZvciB3b3JrZXJpemF0aW9uIHRvIGZ1bmN0aW9uIGNvcnJlY3RseVxuICAgICAgICBJbmZsYXRlLnByb3RvdHlwZS5jLmNhbGwodGhpcywgZmluYWwpO1xuICAgICAgICAvLyBwcm9jZXNzIGNvbmNhdGVuYXRlZCBHWklQXG4gICAgICAgIGlmICh0aGlzLnMuZiAmJiAhdGhpcy5zLmwgJiYgIWZpbmFsKSB7XG4gICAgICAgICAgICB0aGlzLnYgPSBzaGZ0KHRoaXMucy5wKSArIDk7XG4gICAgICAgICAgICB0aGlzLnMgPSB7IGk6IDAgfTtcbiAgICAgICAgICAgIHRoaXMubyA9IG5ldyB1OCgwKTtcbiAgICAgICAgICAgIHRoaXMucHVzaChuZXcgdTgoMCksIGZpbmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEd1bnppcDtcbn0oKSk7XG5leHBvcnQgeyBHdW56aXAgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBzaW5nbGUgb3IgbXVsdGktbWVtYmVyIEdaSVAgZGVjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNHdW56aXAgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXN5bmNHdW56aXAob3B0cywgY2IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgYXN0cm1pZnkoW1xuICAgICAgICAgICAgYkluZmx0LFxuICAgICAgICAgICAgZ3V6ZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFthc3RybSwgSW5mbGF0ZSwgR3VuemlwXTsgfVxuICAgICAgICBdLCB0aGlzLCBTdHJtT3B0LmNhbGwodGhpcywgb3B0cywgY2IpLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzdHJtID0gbmV3IEd1bnppcChldi5kYXRhKTtcbiAgICAgICAgICAgIHN0cm0ub25tZW1iZXIgPSBmdW5jdGlvbiAob2Zmc2V0KSB7IHJldHVybiBwb3N0TWVzc2FnZShvZmZzZXQpOyB9O1xuICAgICAgICAgICAgb25tZXNzYWdlID0gYXN0cm0oc3RybSk7XG4gICAgICAgIH0sIDksIDAsIGZ1bmN0aW9uIChvZmZzZXQpIHsgcmV0dXJuIF90aGlzLm9ubWVtYmVyICYmIF90aGlzLm9ubWVtYmVyKG9mZnNldCk7IH0pO1xuICAgIH1cbiAgICByZXR1cm4gQXN5bmNHdW56aXA7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNHdW56aXAgfTtcbmV4cG9ydCBmdW5jdGlvbiBndW56aXAoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIGVycig3KTtcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiSW5mbHQsXG4gICAgICAgIGd1emUsXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtndW56aXBTeW5jXTsgfVxuICAgIF0sIGZ1bmN0aW9uIChldikgeyByZXR1cm4gcGJmKGd1bnppcFN5bmMoZXYuZGF0YVswXSwgZXYuZGF0YVsxXSkpOyB9LCAzLCBjYik7XG59XG4vKipcbiAqIEV4cGFuZHMgR1pJUCBkYXRhXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvbXByZXNzXG4gKiBAcGFyYW0gb3B0cyBUaGUgZGVjb21wcmVzc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgZGVjb21wcmVzc2VkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGd1bnppcFN5bmMoZGF0YSwgb3B0cykge1xuICAgIHZhciBzdCA9IGd6cyhkYXRhKTtcbiAgICBpZiAoc3QgKyA4ID4gZGF0YS5sZW5ndGgpXG4gICAgICAgIGVycig2LCAnaW52YWxpZCBnemlwIGRhdGEnKTtcbiAgICByZXR1cm4gaW5mbHQoZGF0YS5zdWJhcnJheShzdCwgLTgpLCB7IGk6IDIgfSwgb3B0cyAmJiBvcHRzLm91dCB8fCBuZXcgdTgoZ3psKGRhdGEpKSwgb3B0cyAmJiBvcHRzLmRpY3Rpb25hcnkpO1xufVxuLyoqXG4gKiBTdHJlYW1pbmcgWmxpYiBjb21wcmVzc2lvblxuICovXG52YXIgWmxpYiA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBabGliKG9wdHMsIGNiKSB7XG4gICAgICAgIHRoaXMuYyA9IGFkbGVyKCk7XG4gICAgICAgIHRoaXMudiA9IDE7XG4gICAgICAgIERlZmxhdGUuY2FsbCh0aGlzLCBvcHRzLCBjYik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIHpsaWJiZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgWmxpYi5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgdGhpcy5jLnAoY2h1bmspO1xuICAgICAgICBEZWZsYXRlLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIFpsaWIucHJvdG90eXBlLnAgPSBmdW5jdGlvbiAoYywgZikge1xuICAgICAgICB2YXIgcmF3ID0gZG9wdChjLCB0aGlzLm8sIHRoaXMudiAmJiAodGhpcy5vLmRpY3Rpb25hcnkgPyA2IDogMiksIGYgJiYgNCwgdGhpcy5zKTtcbiAgICAgICAgaWYgKHRoaXMudilcbiAgICAgICAgICAgIHpsaChyYXcsIHRoaXMubyksIHRoaXMudiA9IDA7XG4gICAgICAgIGlmIChmKVxuICAgICAgICAgICAgd2J5dGVzKHJhdywgcmF3Lmxlbmd0aCAtIDQsIHRoaXMuYy5kKCkpO1xuICAgICAgICB0aGlzLm9uZGF0YShyYXcsIGYpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmx1c2hlcyBidWZmZXJlZCB1bmNvbXByZXNzZWQgZGF0YS4gVXNlZnVsIHRvIGltbWVkaWF0ZWx5IHJldHJpZXZlIHRoZVxuICAgICAqIHpsaWJiZWQgb3V0cHV0IGZvciBzbWFsbCBpbnB1dHMuXG4gICAgICovXG4gICAgWmxpYi5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIERlZmxhdGUucHJvdG90eXBlLmZsdXNoLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gWmxpYjtcbn0oKSk7XG5leHBvcnQgeyBabGliIH07XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgWmxpYiBjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNabGliID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFzeW5jWmxpYihvcHRzLCBjYikge1xuICAgICAgICBhc3RybWlmeShbXG4gICAgICAgICAgICBiRGZsdCxcbiAgICAgICAgICAgIHpsZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFthc3RybSwgRGVmbGF0ZSwgWmxpYl07IH1cbiAgICAgICAgXSwgdGhpcywgU3RybU9wdC5jYWxsKHRoaXMsIG9wdHMsIGNiKSwgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc3RybSA9IG5ldyBabGliKGV2LmRhdGEpO1xuICAgICAgICAgICAgb25tZXNzYWdlID0gYXN0cm0oc3RybSk7XG4gICAgICAgIH0sIDEwLCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIEFzeW5jWmxpYjtcbn0oKSk7XG5leHBvcnQgeyBBc3luY1psaWIgfTtcbmV4cG9ydCBmdW5jdGlvbiB6bGliKGRhdGEsIG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYilcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICBlcnIoNyk7XG4gICAgcmV0dXJuIGNiaWZ5KGRhdGEsIG9wdHMsIFtcbiAgICAgICAgYkRmbHQsXG4gICAgICAgIHpsZSxcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW3psaWJTeW5jXTsgfVxuICAgIF0sIGZ1bmN0aW9uIChldikgeyByZXR1cm4gcGJmKHpsaWJTeW5jKGV2LmRhdGFbMF0sIGV2LmRhdGFbMV0pKTsgfSwgNCwgY2IpO1xufVxuLyoqXG4gKiBDb21wcmVzcyBkYXRhIHdpdGggWmxpYlxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gY29tcHJlc3NcbiAqIEBwYXJhbSBvcHRzIFRoZSBjb21wcmVzc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgemxpYi1jb21wcmVzc2VkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHpsaWJTeW5jKGRhdGEsIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpXG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICB2YXIgYSA9IGFkbGVyKCk7XG4gICAgYS5wKGRhdGEpO1xuICAgIHZhciBkID0gZG9wdChkYXRhLCBvcHRzLCBvcHRzLmRpY3Rpb25hcnkgPyA2IDogMiwgNCk7XG4gICAgcmV0dXJuIHpsaChkLCBvcHRzKSwgd2J5dGVzKGQsIGQubGVuZ3RoIC0gNCwgYS5kKCkpLCBkO1xufVxuLyoqXG4gKiBTdHJlYW1pbmcgWmxpYiBkZWNvbXByZXNzaW9uXG4gKi9cbnZhciBVbnpsaWIgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW56bGliKG9wdHMsIGNiKSB7XG4gICAgICAgIEluZmxhdGUuY2FsbCh0aGlzLCBvcHRzLCBjYik7XG4gICAgICAgIHRoaXMudiA9IG9wdHMgJiYgb3B0cy5kaWN0aW9uYXJ5ID8gMiA6IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIHVuemxpYmJlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBVbnpsaWIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIEluZmxhdGUucHJvdG90eXBlLmUuY2FsbCh0aGlzLCBjaHVuayk7XG4gICAgICAgIGlmICh0aGlzLnYpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnAubGVuZ3RoIDwgNiAmJiAhZmluYWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5wID0gdGhpcy5wLnN1YmFycmF5KHpscyh0aGlzLnAsIHRoaXMudiAtIDEpKSwgdGhpcy52ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnAubGVuZ3RoIDwgNClcbiAgICAgICAgICAgICAgICBlcnIoNiwgJ2ludmFsaWQgemxpYiBkYXRhJyk7XG4gICAgICAgICAgICB0aGlzLnAgPSB0aGlzLnAuc3ViYXJyYXkoMCwgLTQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5lY2Vzc2FyeSB0byBwcmV2ZW50IFRTIGZyb20gdXNpbmcgdGhlIGNsb3N1cmUgdmFsdWVcbiAgICAgICAgLy8gVGhpcyBhbGxvd3MgZm9yIHdvcmtlcml6YXRpb24gdG8gZnVuY3Rpb24gY29ycmVjdGx5XG4gICAgICAgIEluZmxhdGUucHJvdG90eXBlLmMuY2FsbCh0aGlzLCBmaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gVW56bGliO1xufSgpKTtcbmV4cG9ydCB7IFVuemxpYiB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIFpsaWIgZGVjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNVbnpsaWIgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXN5bmNVbnpsaWIob3B0cywgY2IpIHtcbiAgICAgICAgYXN0cm1pZnkoW1xuICAgICAgICAgICAgYkluZmx0LFxuICAgICAgICAgICAgenVsZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFthc3RybSwgSW5mbGF0ZSwgVW56bGliXTsgfVxuICAgICAgICBdLCB0aGlzLCBTdHJtT3B0LmNhbGwodGhpcywgb3B0cywgY2IpLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzdHJtID0gbmV3IFVuemxpYihldi5kYXRhKTtcbiAgICAgICAgICAgIG9ubWVzc2FnZSA9IGFzdHJtKHN0cm0pO1xuICAgICAgICB9LCAxMSwgMCk7XG4gICAgfVxuICAgIHJldHVybiBBc3luY1VuemxpYjtcbn0oKSk7XG5leHBvcnQgeyBBc3luY1VuemxpYiB9O1xuZXhwb3J0IGZ1bmN0aW9uIHVuemxpYihkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgZXJyKDcpO1xuICAgIHJldHVybiBjYmlmeShkYXRhLCBvcHRzLCBbXG4gICAgICAgIGJJbmZsdCxcbiAgICAgICAgenVsZSxcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW3VuemxpYlN5bmNdOyB9XG4gICAgXSwgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBwYmYodW56bGliU3luYyhldi5kYXRhWzBdLCBnb3B0KGV2LmRhdGFbMV0pKSk7IH0sIDUsIGNiKTtcbn1cbi8qKlxuICogRXhwYW5kcyBabGliIGRhdGFcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29tcHJlc3NcbiAqIEBwYXJhbSBvcHRzIFRoZSBkZWNvbXByZXNzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW56bGliU3luYyhkYXRhLCBvcHRzKSB7XG4gICAgcmV0dXJuIGluZmx0KGRhdGEuc3ViYXJyYXkoemxzKGRhdGEsIG9wdHMgJiYgb3B0cy5kaWN0aW9uYXJ5KSwgLTQpLCB7IGk6IDIgfSwgb3B0cyAmJiBvcHRzLm91dCwgb3B0cyAmJiBvcHRzLmRpY3Rpb25hcnkpO1xufVxuLy8gRGVmYXVsdCBhbGdvcml0aG0gZm9yIGNvbXByZXNzaW9uICh1c2VkIGJlY2F1c2UgaGF2aW5nIGEga25vd24gb3V0cHV0IHNpemUgYWxsb3dzIGZhc3RlciBkZWNvbXByZXNzaW9uKVxuZXhwb3J0IHsgZ3ppcCBhcyBjb21wcmVzcywgQXN5bmNHemlwIGFzIEFzeW5jQ29tcHJlc3MgfTtcbmV4cG9ydCB7IGd6aXBTeW5jIGFzIGNvbXByZXNzU3luYywgR3ppcCBhcyBDb21wcmVzcyB9O1xuLyoqXG4gKiBTdHJlYW1pbmcgR1pJUCwgWmxpYiwgb3IgcmF3IERFRkxBVEUgZGVjb21wcmVzc2lvblxuICovXG52YXIgRGVjb21wcmVzcyA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWNvbXByZXNzKG9wdHMsIGNiKSB7XG4gICAgICAgIHRoaXMubyA9IFN0cm1PcHQuY2FsbCh0aGlzLCBvcHRzLCBjYikgfHwge307XG4gICAgICAgIHRoaXMuRyA9IEd1bnppcDtcbiAgICAgICAgdGhpcy5JID0gSW5mbGF0ZTtcbiAgICAgICAgdGhpcy5aID0gVW56bGliO1xuICAgIH1cbiAgICAvLyBpbml0IHN1YnN0cmVhbVxuICAgIC8vIG92ZXJyaWRlbiBieSBBc3luY0RlY29tcHJlc3NcbiAgICBEZWNvbXByZXNzLnByb3RvdHlwZS5pID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnMub25kYXRhID0gZnVuY3Rpb24gKGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgIF90aGlzLm9uZGF0YShkYXQsIGZpbmFsKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGRlY29tcHJlc3NlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBEZWNvbXByZXNzLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgZXJyKDUpO1xuICAgICAgICBpZiAoIXRoaXMucykge1xuICAgICAgICAgICAgaWYgKHRoaXMucCAmJiB0aGlzLnAubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBuZXcgdTgodGhpcy5wLmxlbmd0aCArIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbi5zZXQodGhpcy5wKSwgbi5zZXQoY2h1bmssIHRoaXMucC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMucCA9IGNodW5rO1xuICAgICAgICAgICAgaWYgKHRoaXMucC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zID0gKHRoaXMucFswXSA9PSAzMSAmJiB0aGlzLnBbMV0gPT0gMTM5ICYmIHRoaXMucFsyXSA9PSA4KVxuICAgICAgICAgICAgICAgICAgICA/IG5ldyB0aGlzLkcodGhpcy5vKVxuICAgICAgICAgICAgICAgICAgICA6ICgodGhpcy5wWzBdICYgMTUpICE9IDggfHwgKHRoaXMucFswXSA+PiA0KSA+IDcgfHwgKCh0aGlzLnBbMF0gPDwgOCB8IHRoaXMucFsxXSkgJSAzMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyB0aGlzLkkodGhpcy5vKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgdGhpcy5aKHRoaXMubyk7XG4gICAgICAgICAgICAgICAgdGhpcy5pKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zLnB1c2godGhpcy5wLCBmaW5hbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnMucHVzaChjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIERlY29tcHJlc3M7XG59KCkpO1xuZXhwb3J0IHsgRGVjb21wcmVzcyB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIEdaSVAsIFpsaWIsIG9yIHJhdyBERUZMQVRFIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jRGVjb21wcmVzcyA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3luY0RlY29tcHJlc3Mob3B0cywgY2IpIHtcbiAgICAgICAgRGVjb21wcmVzcy5jYWxsKHRoaXMsIG9wdHMsIGNiKTtcbiAgICAgICAgdGhpcy5xdWV1ZWRTaXplID0gMDtcbiAgICAgICAgdGhpcy5HID0gQXN5bmNHdW56aXA7XG4gICAgICAgIHRoaXMuSSA9IEFzeW5jSW5mbGF0ZTtcbiAgICAgICAgdGhpcy5aID0gQXN5bmNVbnpsaWI7XG4gICAgfVxuICAgIEFzeW5jRGVjb21wcmVzcy5wcm90b3R5cGUuaSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zLm9uZGF0YSA9IGZ1bmN0aW9uIChlcnIsIGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgIF90aGlzLm9uZGF0YShlcnIsIGRhdCwgZmluYWwpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnMub25kcmFpbiA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgICAgICBfdGhpcy5xdWV1ZWRTaXplIC09IHNpemU7XG4gICAgICAgICAgICBpZiAoX3RoaXMub25kcmFpbilcbiAgICAgICAgICAgICAgICBfdGhpcy5vbmRyYWluKHNpemUpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZGVjb21wcmVzc2VkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIEFzeW5jRGVjb21wcmVzcy5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgdGhpcy5xdWV1ZWRTaXplICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgRGVjb21wcmVzcy5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gQXN5bmNEZWNvbXByZXNzO1xufSgpKTtcbmV4cG9ydCB7IEFzeW5jRGVjb21wcmVzcyB9O1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29tcHJlc3MoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIGVycig3KTtcbiAgICByZXR1cm4gKGRhdGFbMF0gPT0gMzEgJiYgZGF0YVsxXSA9PSAxMzkgJiYgZGF0YVsyXSA9PSA4KVxuICAgICAgICA/IGd1bnppcChkYXRhLCBvcHRzLCBjYilcbiAgICAgICAgOiAoKGRhdGFbMF0gJiAxNSkgIT0gOCB8fCAoZGF0YVswXSA+PiA0KSA+IDcgfHwgKChkYXRhWzBdIDw8IDggfCBkYXRhWzFdKSAlIDMxKSlcbiAgICAgICAgICAgID8gaW5mbGF0ZShkYXRhLCBvcHRzLCBjYilcbiAgICAgICAgICAgIDogdW56bGliKGRhdGEsIG9wdHMsIGNiKTtcbn1cbi8qKlxuICogRXhwYW5kcyBjb21wcmVzc2VkIEdaSVAsIFpsaWIsIG9yIHJhdyBERUZMQVRFIGRhdGEsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0aW5nIHRoZSBmb3JtYXRcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29tcHJlc3NcbiAqIEBwYXJhbSBvcHRzIFRoZSBkZWNvbXByZXNzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb21wcmVzc1N5bmMoZGF0YSwgb3B0cykge1xuICAgIHJldHVybiAoZGF0YVswXSA9PSAzMSAmJiBkYXRhWzFdID09IDEzOSAmJiBkYXRhWzJdID09IDgpXG4gICAgICAgID8gZ3VuemlwU3luYyhkYXRhLCBvcHRzKVxuICAgICAgICA6ICgoZGF0YVswXSAmIDE1KSAhPSA4IHx8IChkYXRhWzBdID4+IDQpID4gNyB8fCAoKGRhdGFbMF0gPDwgOCB8IGRhdGFbMV0pICUgMzEpKVxuICAgICAgICAgICAgPyBpbmZsYXRlU3luYyhkYXRhLCBvcHRzKVxuICAgICAgICAgICAgOiB1bnpsaWJTeW5jKGRhdGEsIG9wdHMpO1xufVxuLy8gZmxhdHRlbiBhIGRpcmVjdG9yeSBzdHJ1Y3R1cmVcbnZhciBmbHRuID0gZnVuY3Rpb24gKGQsIHAsIHQsIG8pIHtcbiAgICBmb3IgKHZhciBrIGluIGQpIHtcbiAgICAgICAgdmFyIHZhbCA9IGRba10sIG4gPSBwICsgaywgb3AgPSBvO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKVxuICAgICAgICAgICAgb3AgPSBtcmcobywgdmFsWzFdKSwgdmFsID0gdmFsWzBdO1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgdTgpXG4gICAgICAgICAgICB0W25dID0gW3ZhbCwgb3BdO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRbbiArPSAnLyddID0gW25ldyB1OCgwKSwgb3BdO1xuICAgICAgICAgICAgZmx0bih2YWwsIG4sIHQsIG8pO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8vIHRleHQgZW5jb2RlclxudmFyIHRlID0gdHlwZW9mIFRleHRFbmNvZGVyICE9ICd1bmRlZmluZWQnICYmIC8qI19fUFVSRV9fKi8gbmV3IFRleHRFbmNvZGVyKCk7XG4vLyB0ZXh0IGRlY29kZXJcbnZhciB0ZCA9IHR5cGVvZiBUZXh0RGVjb2RlciAhPSAndW5kZWZpbmVkJyAmJiAvKiNfX1BVUkVfXyovIG5ldyBUZXh0RGVjb2RlcigpO1xuLy8gdGV4dCBkZWNvZGVyIHN0cmVhbVxudmFyIHRkcyA9IDA7XG50cnkge1xuICAgIHRkLmRlY29kZShldCwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgdGRzID0gMTtcbn1cbmNhdGNoIChlKSB7IH1cbi8vIGRlY29kZSBVVEY4XG52YXIgZHV0ZjggPSBmdW5jdGlvbiAoZCkge1xuICAgIGZvciAodmFyIHIgPSAnJywgaSA9IDA7Oykge1xuICAgICAgICB2YXIgYyA9IGRbaSsrXTtcbiAgICAgICAgdmFyIGViID0gKGMgPiAxMjcpICsgKGMgPiAyMjMpICsgKGMgPiAyMzkpO1xuICAgICAgICBpZiAoaSArIGViID4gZC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4geyBzOiByLCByOiBzbGMoZCwgaSAtIDEpIH07XG4gICAgICAgIGlmICghZWIpXG4gICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgIGVsc2UgaWYgKGViID09IDMpIHtcbiAgICAgICAgICAgIGMgPSAoKGMgJiAxNSkgPDwgMTggfCAoZFtpKytdICYgNjMpIDw8IDEyIHwgKGRbaSsrXSAmIDYzKSA8PCA2IHwgKGRbaSsrXSAmIDYzKSkgLSA2NTUzNixcbiAgICAgICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYgfCAoYyA+PiAxMCksIDU2MzIwIHwgKGMgJiAxMDIzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWIgJiAxKVxuICAgICAgICAgICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMzEpIDw8IDYgfCAoZFtpKytdICYgNjMpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMTUpIDw8IDEyIHwgKGRbaSsrXSAmIDYzKSA8PCA2IHwgKGRbaSsrXSAmIDYzKSk7XG4gICAgfVxufTtcbi8qKlxuICogU3RyZWFtaW5nIFVURi04IGRlY29kaW5nXG4gKi9cbnZhciBEZWNvZGVVVEY4ID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBVVEYtOCBkZWNvZGluZyBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBkZWNvZGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGVjb2RlVVRGOChjYikge1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgICAgICBpZiAodGRzKVxuICAgICAgICAgICAgdGhpcy50ID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucCA9IGV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWNvZGVkIGZyb20gVVRGLTggYmluYXJ5XG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIERlY29kZVVURjgucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICBlcnIoNSk7XG4gICAgICAgIGZpbmFsID0gISFmaW5hbDtcbiAgICAgICAgaWYgKHRoaXMudCkge1xuICAgICAgICAgICAgdGhpcy5vbmRhdGEodGhpcy50LmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSksIGZpbmFsKTtcbiAgICAgICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnQuZGVjb2RlKCkubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBlcnIoOCk7XG4gICAgICAgICAgICAgICAgdGhpcy50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucClcbiAgICAgICAgICAgIGVycig0KTtcbiAgICAgICAgdmFyIGRhdCA9IG5ldyB1OCh0aGlzLnAubGVuZ3RoICsgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgZGF0LnNldCh0aGlzLnApO1xuICAgICAgICBkYXQuc2V0KGNodW5rLCB0aGlzLnAubGVuZ3RoKTtcbiAgICAgICAgdmFyIF9hID0gZHV0ZjgoZGF0KSwgcyA9IF9hLnMsIHIgPSBfYS5yO1xuICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgIGlmIChyLmxlbmd0aClcbiAgICAgICAgICAgICAgICBlcnIoOCk7XG4gICAgICAgICAgICB0aGlzLnAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucCA9IHI7XG4gICAgICAgIHRoaXMub25kYXRhKHMsIGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWNvZGVVVEY4O1xufSgpKTtcbmV4cG9ydCB7IERlY29kZVVURjggfTtcbi8qKlxuICogU3RyZWFtaW5nIFVURi04IGVuY29kaW5nXG4gKi9cbnZhciBFbmNvZGVVVEY4ID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBVVEYtOCBkZWNvZGluZyBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBlbmNvZGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gRW5jb2RlVVRGOChjYikge1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBlbmNvZGVkIHRvIFVURi04XG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBzdHJpbmcgZGF0YSB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIEVuY29kZVVURjgucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICBlcnIoNSk7XG4gICAgICAgIGlmICh0aGlzLmQpXG4gICAgICAgICAgICBlcnIoNCk7XG4gICAgICAgIHRoaXMub25kYXRhKHN0clRvVTgoY2h1bmspLCB0aGlzLmQgPSBmaW5hbCB8fCBmYWxzZSk7XG4gICAgfTtcbiAgICByZXR1cm4gRW5jb2RlVVRGODtcbn0oKSk7XG5leHBvcnQgeyBFbmNvZGVVVEY4IH07XG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGludG8gYSBVaW50OEFycmF5IGZvciB1c2Ugd2l0aCBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIG1ldGhvZHNcbiAqIEBwYXJhbSBzdHIgVGhlIHN0cmluZyB0byBlbmNvZGVcbiAqIEBwYXJhbSBsYXRpbjEgV2hldGhlciBvciBub3QgdG8gaW50ZXJwcmV0IHRoZSBkYXRhIGFzIExhdGluLTEuIFRoaXMgc2hvdWxkXG4gKiAgICAgICAgICAgICAgIG5vdCBuZWVkIHRvIGJlIHRydWUgdW5sZXNzIGRlY29kaW5nIGEgYmluYXJ5IHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBzdHJpbmcgZW5jb2RlZCBpbiBVVEYtOC9MYXRpbi0xIGJpbmFyeVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyVG9VOChzdHIsIGxhdGluMSkge1xuICAgIGlmIChsYXRpbjEpIHtcbiAgICAgICAgdmFyIGFyXzEgPSBuZXcgdTgoc3RyLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgYXJfMVtpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICByZXR1cm4gYXJfMTtcbiAgICB9XG4gICAgaWYgKHRlKVxuICAgICAgICByZXR1cm4gdGUuZW5jb2RlKHN0cik7XG4gICAgdmFyIGwgPSBzdHIubGVuZ3RoO1xuICAgIHZhciBhciA9IG5ldyB1OChzdHIubGVuZ3RoICsgKHN0ci5sZW5ndGggPj4gMSkpO1xuICAgIHZhciBhaSA9IDA7XG4gICAgdmFyIHcgPSBmdW5jdGlvbiAodikgeyBhclthaSsrXSA9IHY7IH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgaWYgKGFpICsgNSA+IGFyLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG4gPSBuZXcgdTgoYWkgKyA4ICsgKChsIC0gaSkgPDwgMSkpO1xuICAgICAgICAgICAgbi5zZXQoYXIpO1xuICAgICAgICAgICAgYXIgPSBuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMTI4IHx8IGxhdGluMSlcbiAgICAgICAgICAgIHcoYyk7XG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KVxuICAgICAgICAgICAgdygxOTIgfCAoYyA+PiA2KSksIHcoMTI4IHwgKGMgJiA2MykpO1xuICAgICAgICBlbHNlIGlmIChjID4gNTUyOTUgJiYgYyA8IDU3MzQ0KVxuICAgICAgICAgICAgYyA9IDY1NTM2ICsgKGMgJiAxMDIzIDw8IDEwKSB8IChzdHIuY2hhckNvZGVBdCgrK2kpICYgMTAyMyksXG4gICAgICAgICAgICAgICAgdygyNDAgfCAoYyA+PiAxOCkpLCB3KDEyOCB8ICgoYyA+PiAxMikgJiA2MykpLCB3KDEyOCB8ICgoYyA+PiA2KSAmIDYzKSksIHcoMTI4IHwgKGMgJiA2MykpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB3KDIyNCB8IChjID4+IDEyKSksIHcoMTI4IHwgKChjID4+IDYpICYgNjMpKSwgdygxMjggfCAoYyAmIDYzKSk7XG4gICAgfVxuICAgIHJldHVybiBzbGMoYXIsIDAsIGFpKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBVaW50OEFycmF5IHRvIGEgc3RyaW5nXG4gKiBAcGFyYW0gZGF0IFRoZSBkYXRhIHRvIGRlY29kZSB0byBzdHJpbmdcbiAqIEBwYXJhbSBsYXRpbjEgV2hldGhlciBvciBub3QgdG8gaW50ZXJwcmV0IHRoZSBkYXRhIGFzIExhdGluLTEuIFRoaXMgc2hvdWxkXG4gKiAgICAgICAgICAgICAgIG5vdCBuZWVkIHRvIGJlIHRydWUgdW5sZXNzIGVuY29kaW5nIHRvIGJpbmFyeSBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgb3JpZ2luYWwgVVRGLTgvTGF0aW4tMSBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0ckZyb21VOChkYXQsIGxhdGluMSkge1xuICAgIGlmIChsYXRpbjEpIHtcbiAgICAgICAgdmFyIHIgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXQubGVuZ3RoOyBpICs9IDE2Mzg0KVxuICAgICAgICAgICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGRhdC5zdWJhcnJheShpLCBpICsgMTYzODQpKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRkKSB7XG4gICAgICAgIHJldHVybiB0ZC5kZWNvZGUoZGF0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBfYSA9IGR1dGY4KGRhdCksIHMgPSBfYS5zLCByID0gX2EucjtcbiAgICAgICAgaWYgKHIubGVuZ3RoKVxuICAgICAgICAgICAgZXJyKDgpO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG59XG47XG4vLyBkZWZsYXRlIGJpdCBmbGFnXG52YXIgZGJmID0gZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwgPT0gMSA/IDMgOiBsIDwgNiA/IDIgOiBsID09IDkgPyAxIDogMDsgfTtcbi8vIHNraXAgbG9jYWwgemlwIGhlYWRlclxudmFyIHNsemggPSBmdW5jdGlvbiAoZCwgYikgeyByZXR1cm4gYiArIDMwICsgYjIoZCwgYiArIDI2KSArIGIyKGQsIGIgKyAyOCk7IH07XG4vLyByZWFkIHppcCBoZWFkZXJcbnZhciB6aCA9IGZ1bmN0aW9uIChkLCBiLCB6KSB7XG4gICAgdmFyIGZubCA9IGIyKGQsIGIgKyAyOCksIGZuID0gc3RyRnJvbVU4KGQuc3ViYXJyYXkoYiArIDQ2LCBiICsgNDYgKyBmbmwpLCAhKGIyKGQsIGIgKyA4KSAmIDIwNDgpKSwgZXMgPSBiICsgNDYgKyBmbmwsIGJzID0gYjQoZCwgYiArIDIwKTtcbiAgICB2YXIgX2EgPSB6ICYmIGJzID09IDQyOTQ5NjcyOTUgPyB6NjRlKGQsIGVzKSA6IFticywgYjQoZCwgYiArIDI0KSwgYjQoZCwgYiArIDQyKV0sIHNjID0gX2FbMF0sIHN1ID0gX2FbMV0sIG9mZiA9IF9hWzJdO1xuICAgIHJldHVybiBbYjIoZCwgYiArIDEwKSwgc2MsIHN1LCBmbiwgZXMgKyBiMihkLCBiICsgMzApICsgYjIoZCwgYiArIDMyKSwgb2ZmXTtcbn07XG4vLyByZWFkIHppcDY0IGV4dHJhIGZpZWxkXG52YXIgejY0ZSA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICg7IGIyKGQsIGIpICE9IDE7IGIgKz0gNCArIGIyKGQsIGIgKyAyKSlcbiAgICAgICAgO1xuICAgIHJldHVybiBbYjgoZCwgYiArIDEyKSwgYjgoZCwgYiArIDQpLCBiOChkLCBiICsgMjApXTtcbn07XG4vLyBleHRyYSBmaWVsZCBsZW5ndGhcbnZhciBleGZsID0gZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIGxlID0gMDtcbiAgICBpZiAoZXgpIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiBleCkge1xuICAgICAgICAgICAgdmFyIGwgPSBleFtrXS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobCA+IDY1NTM1KVxuICAgICAgICAgICAgICAgIGVycig5KTtcbiAgICAgICAgICAgIGxlICs9IGwgKyA0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZTtcbn07XG4vLyB3cml0ZSB6aXAgaGVhZGVyXG52YXIgd3poID0gZnVuY3Rpb24gKGQsIGIsIGYsIGZuLCB1LCBjLCBjZSwgY28pIHtcbiAgICB2YXIgZmwgPSBmbi5sZW5ndGgsIGV4ID0gZi5leHRyYSwgY29sID0gY28gJiYgY28ubGVuZ3RoO1xuICAgIHZhciBleGwgPSBleGZsKGV4KTtcbiAgICB3Ynl0ZXMoZCwgYiwgY2UgIT0gbnVsbCA/IDB4MjAxNEI1MCA6IDB4NDAzNEI1MCksIGIgKz0gNDtcbiAgICBpZiAoY2UgIT0gbnVsbClcbiAgICAgICAgZFtiKytdID0gMjAsIGRbYisrXSA9IGYub3M7XG4gICAgZFtiXSA9IDIwLCBiICs9IDI7IC8vIHNwZWMgY29tcGxpYW5jZT8gd2hhdCdzIHRoYXQ/XG4gICAgZFtiKytdID0gKGYuZmxhZyA8PCAxKSB8IChjIDwgMCAmJiA4KSwgZFtiKytdID0gdSAmJiA4O1xuICAgIGRbYisrXSA9IGYuY29tcHJlc3Npb24gJiAyNTUsIGRbYisrXSA9IGYuY29tcHJlc3Npb24gPj4gODtcbiAgICB2YXIgZHQgPSBuZXcgRGF0ZShmLm10aW1lID09IG51bGwgPyBEYXRlLm5vdygpIDogZi5tdGltZSksIHkgPSBkdC5nZXRGdWxsWWVhcigpIC0gMTk4MDtcbiAgICBpZiAoeSA8IDAgfHwgeSA+IDExOSlcbiAgICAgICAgZXJyKDEwKTtcbiAgICB3Ynl0ZXMoZCwgYiwgKHkgPDwgMjUpIHwgKChkdC5nZXRNb250aCgpICsgMSkgPDwgMjEpIHwgKGR0LmdldERhdGUoKSA8PCAxNikgfCAoZHQuZ2V0SG91cnMoKSA8PCAxMSkgfCAoZHQuZ2V0TWludXRlcygpIDw8IDUpIHwgKGR0LmdldFNlY29uZHMoKSA+PiAxKSksIGIgKz0gNDtcbiAgICBpZiAoYyAhPSAtMSkge1xuICAgICAgICB3Ynl0ZXMoZCwgYiwgZi5jcmMpO1xuICAgICAgICB3Ynl0ZXMoZCwgYiArIDQsIGMgPCAwID8gLWMgLSAyIDogYyk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgOCwgZi5zaXplKTtcbiAgICB9XG4gICAgd2J5dGVzKGQsIGIgKyAxMiwgZmwpO1xuICAgIHdieXRlcyhkLCBiICsgMTQsIGV4bCksIGIgKz0gMTY7XG4gICAgaWYgKGNlICE9IG51bGwpIHtcbiAgICAgICAgd2J5dGVzKGQsIGIsIGNvbCk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgNiwgZi5hdHRycyk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgMTAsIGNlKSwgYiArPSAxNDtcbiAgICB9XG4gICAgZC5zZXQoZm4sIGIpO1xuICAgIGIgKz0gZmw7XG4gICAgaWYgKGV4bCkge1xuICAgICAgICBmb3IgKHZhciBrIGluIGV4KSB7XG4gICAgICAgICAgICB2YXIgZXhmID0gZXhba10sIGwgPSBleGYubGVuZ3RoO1xuICAgICAgICAgICAgd2J5dGVzKGQsIGIsICtrKTtcbiAgICAgICAgICAgIHdieXRlcyhkLCBiICsgMiwgbCk7XG4gICAgICAgICAgICBkLnNldChleGYsIGIgKyA0KSwgYiArPSA0ICsgbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29sKVxuICAgICAgICBkLnNldChjbywgYiksIGIgKz0gY29sO1xuICAgIHJldHVybiBiO1xufTtcbi8vIHdyaXRlIHppcCBmb290ZXIgKGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSlcbnZhciB3emYgPSBmdW5jdGlvbiAobywgYiwgYywgZCwgZSkge1xuICAgIHdieXRlcyhvLCBiLCAweDYwNTRCNTApOyAvLyBza2lwIGRpc2tcbiAgICB3Ynl0ZXMobywgYiArIDgsIGMpO1xuICAgIHdieXRlcyhvLCBiICsgMTAsIGMpO1xuICAgIHdieXRlcyhvLCBiICsgMTIsIGQpO1xuICAgIHdieXRlcyhvLCBiICsgMTYsIGUpO1xufTtcbi8qKlxuICogQSBwYXNzLXRocm91Z2ggc3RyZWFtIHRvIGtlZXAgZGF0YSB1bmNvbXByZXNzZWQgaW4gYSBaSVAgYXJjaGl2ZS5cbiAqL1xudmFyIFppcFBhc3NUaHJvdWdoID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwYXNzLXRocm91Z2ggc3RyZWFtIHRoYXQgY2FuIGJlIGFkZGVkIHRvIFpJUCBhcmNoaXZlc1xuICAgICAqIEBwYXJhbSBmaWxlbmFtZSBUaGUgZmlsZW5hbWUgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBkYXRhIHN0cmVhbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFppcFBhc3NUaHJvdWdoKGZpbGVuYW1lKSB7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgdGhpcy5jID0gY3JjKCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb24gPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgYSBjaHVuayBhbmQgcHVzaGVzIHRvIHRoZSBvdXRwdXQgc3RyZWFtLiBZb3UgY2FuIG92ZXJyaWRlIHRoaXNcbiAgICAgKiBtZXRob2QgaW4gYSBzdWJjbGFzcyBmb3IgY3VzdG9tIGJlaGF2aW9yLCBidXQgYnkgZGVmYXVsdCB0aGlzIHBhc3Nlc1xuICAgICAqIHRoZSBkYXRhIHRocm91Z2guIFlvdSBtdXN0IGNhbGwgdGhpcy5vbmRhdGEoZXJyLCBjaHVuaywgZmluYWwpIGF0IHNvbWVcbiAgICAgKiBwb2ludCBpbiB0aGlzIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHByb2Nlc3NcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgWmlwUGFzc1Rocm91Z2gucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHRoaXMub25kYXRhKG51bGwsIGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBhZGRlZC4gSWYgeW91IGFyZSBzdWJjbGFzc2luZyB0aGlzIHdpdGggYSBjdXN0b21cbiAgICAgKiBjb21wcmVzc2lvbiBhbGdvcml0aG0sIG5vdGUgdGhhdCB5b3UgbXVzdCBwdXNoIGRhdGEgZnJvbSB0aGUgc291cmNlXG4gICAgICogZmlsZSBvbmx5LCBwcmUtY29tcHJlc3Npb24uXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIFppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgZXJyKDUpO1xuICAgICAgICB0aGlzLmMucChjaHVuayk7XG4gICAgICAgIHRoaXMuc2l6ZSArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIGlmIChmaW5hbClcbiAgICAgICAgICAgIHRoaXMuY3JjID0gdGhpcy5jLmQoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKGNodW5rLCBmaW5hbCB8fCBmYWxzZSk7XG4gICAgfTtcbiAgICByZXR1cm4gWmlwUGFzc1Rocm91Z2g7XG59KCkpO1xuZXhwb3J0IHsgWmlwUGFzc1Rocm91Z2ggfTtcbi8vIEkgZG9uJ3QgZXh0ZW5kIGJlY2F1c2UgVHlwZVNjcmlwdCBleHRlbnNpb24gYWRkcyAxa0Igb2YgcnVudGltZSBibG9hdFxuLyoqXG4gKiBTdHJlYW1pbmcgREVGTEFURSBjb21wcmVzc2lvbiBmb3IgWklQIGFyY2hpdmVzLiBQcmVmZXIgdXNpbmcgQXN5bmNaaXBEZWZsYXRlXG4gKiBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG4gKi9cbnZhciBaaXBEZWZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBERUZMQVRFIHN0cmVhbSB0aGF0IGNhbiBiZSBhZGRlZCB0byBaSVAgYXJjaGl2ZXNcbiAgICAgKiBAcGFyYW0gZmlsZW5hbWUgVGhlIGZpbGVuYW1lIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgZGF0YSBzdHJlYW1cbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgY29tcHJlc3Npb24gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFppcERlZmxhdGUoZmlsZW5hbWUsIG9wdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFvcHRzKVxuICAgICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICBaaXBQYXNzVGhyb3VnaC5jYWxsKHRoaXMsIGZpbGVuYW1lKTtcbiAgICAgICAgdGhpcy5kID0gbmV3IERlZmxhdGUob3B0cywgZnVuY3Rpb24gKGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgIF90aGlzLm9uZGF0YShudWxsLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb24gPSA4O1xuICAgICAgICB0aGlzLmZsYWcgPSBkYmYob3B0cy5sZXZlbCk7XG4gICAgfVxuICAgIFppcERlZmxhdGUucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmQucHVzaChjaHVuaywgZmluYWwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLm9uZGF0YShlLCBudWxsLCBmaW5hbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGRlZmxhdGVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIFppcERlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIFppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBaaXBEZWZsYXRlO1xufSgpKTtcbmV4cG9ydCB7IFppcERlZmxhdGUgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBERUZMQVRFIGNvbXByZXNzaW9uIGZvciBaSVAgYXJjaGl2ZXNcbiAqL1xudmFyIEFzeW5jWmlwRGVmbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFzeW5jaHJvbm91cyBERUZMQVRFIHN0cmVhbSB0aGF0IGNhbiBiZSBhZGRlZCB0byBaSVAgYXJjaGl2ZXNcbiAgICAgKiBAcGFyYW0gZmlsZW5hbWUgVGhlIGZpbGVuYW1lIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgZGF0YSBzdHJlYW1cbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgY29tcHJlc3Npb24gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFzeW5jWmlwRGVmbGF0ZShmaWxlbmFtZSwgb3B0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIW9wdHMpXG4gICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgIFppcFBhc3NUaHJvdWdoLmNhbGwodGhpcywgZmlsZW5hbWUpO1xuICAgICAgICB0aGlzLmQgPSBuZXcgQXN5bmNEZWZsYXRlKG9wdHMsIGZ1bmN0aW9uIChlcnIsIGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgIF90aGlzLm9uZGF0YShlcnIsIGRhdCwgZmluYWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb21wcmVzc2lvbiA9IDg7XG4gICAgICAgIHRoaXMuZmxhZyA9IGRiZihvcHRzLmxldmVsKTtcbiAgICAgICAgdGhpcy50ZXJtaW5hdGUgPSB0aGlzLmQudGVybWluYXRlO1xuICAgIH1cbiAgICBBc3luY1ppcERlZmxhdGUucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHRoaXMuZC5wdXNoKGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWZsYXRlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBBc3luY1ppcERlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIFppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBBc3luY1ppcERlZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNaaXBEZWZsYXRlIH07XG4vLyBUT0RPOiBCZXR0ZXIgdHJlZSBzaGFraW5nXG4vKipcbiAqIEEgemlwcGFibGUgYXJjaGl2ZSB0byB3aGljaCBmaWxlcyBjYW4gaW5jcmVtZW50YWxseSBiZSBhZGRlZFxuICovXG52YXIgWmlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZW1wdHkgWklQIGFyY2hpdmUgdG8gd2hpY2ggZmlsZXMgY2FuIGJlIGFkZGVkXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgZm9yIHRoZSBnZW5lcmF0ZWQgWklQIGFyY2hpdmVcbiAgICAgKiAgICAgICAgICAgaXMgYXZhaWxhYmxlXG4gICAgICovXG4gICAgZnVuY3Rpb24gWmlwKGNiKSB7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgICAgIHRoaXMudSA9IFtdO1xuICAgICAgICB0aGlzLmQgPSAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgZmlsZSB0byB0aGUgWklQIGFyY2hpdmVcbiAgICAgKiBAcGFyYW0gZmlsZSBUaGUgZmlsZSBzdHJlYW0gdG8gYWRkXG4gICAgICovXG4gICAgWmlwLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgZXJyKDUpO1xuICAgICAgICAvLyBmaW5pc2hpbmcgb3IgZmluaXNoZWRcbiAgICAgICAgaWYgKHRoaXMuZCAmIDIpXG4gICAgICAgICAgICB0aGlzLm9uZGF0YShlcnIoNCArICh0aGlzLmQgJiAxKSAqIDgsIDAsIDEpLCBudWxsLCBmYWxzZSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGYgPSBzdHJUb1U4KGZpbGUuZmlsZW5hbWUpLCBmbF8xID0gZi5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgY29tID0gZmlsZS5jb21tZW50LCBvID0gY29tICYmIHN0clRvVTgoY29tKTtcbiAgICAgICAgICAgIHZhciB1ID0gZmxfMSAhPSBmaWxlLmZpbGVuYW1lLmxlbmd0aCB8fCAobyAmJiAoY29tLmxlbmd0aCAhPSBvLmxlbmd0aCkpO1xuICAgICAgICAgICAgdmFyIGhsXzEgPSBmbF8xICsgZXhmbChmaWxlLmV4dHJhKSArIDMwO1xuICAgICAgICAgICAgaWYgKGZsXzEgPiA2NTUzNSlcbiAgICAgICAgICAgICAgICB0aGlzLm9uZGF0YShlcnIoMTEsIDAsIDEpLCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gbmV3IHU4KGhsXzEpO1xuICAgICAgICAgICAgd3poKGhlYWRlciwgMCwgZmlsZSwgZiwgdSwgLTEpO1xuICAgICAgICAgICAgdmFyIGNoa3NfMSA9IFtoZWFkZXJdO1xuICAgICAgICAgICAgdmFyIHBBbGxfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNoa3NfMiA9IGNoa3NfMTsgX2kgPCBjaGtzXzIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGsgPSBjaGtzXzJbX2ldO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmRhdGEobnVsbCwgY2hrLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoa3NfMSA9IFtdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB0cl8xID0gdGhpcy5kO1xuICAgICAgICAgICAgdGhpcy5kID0gMDtcbiAgICAgICAgICAgIHZhciBpbmRfMSA9IHRoaXMudS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgdWZfMSA9IG1yZyhmaWxlLCB7XG4gICAgICAgICAgICAgICAgZjogZixcbiAgICAgICAgICAgICAgICB1OiB1LFxuICAgICAgICAgICAgICAgIG86IG8sXG4gICAgICAgICAgICAgICAgdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZS50ZXJtaW5hdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBwQWxsXzEoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBueHQgPSBfdGhpcy51W2luZF8xICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG54dC5yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJfMSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgY2xfMSA9IDA7XG4gICAgICAgICAgICBmaWxlLm9uZGF0YSA9IGZ1bmN0aW9uIChlcnIsIGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uZGF0YShlcnIsIGRhdCwgZmluYWwpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNsXzEgKz0gZGF0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY2hrc18xLnB1c2goZGF0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGQgPSBuZXcgdTgoMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2J5dGVzKGRkLCAwLCAweDgwNzRCNTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2J5dGVzKGRkLCA0LCBmaWxlLmNyYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3Ynl0ZXMoZGQsIDgsIGNsXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2J5dGVzKGRkLCAxMiwgZmlsZS5zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoa3NfMS5wdXNoKGRkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVmXzEuYyA9IGNsXzEsIHVmXzEuYiA9IGhsXzEgKyBjbF8xICsgMTYsIHVmXzEuY3JjID0gZmlsZS5jcmMsIHVmXzEuc2l6ZSA9IGZpbGUuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cl8xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVmXzEucigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJfMSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHJfMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHBBbGxfMSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnUucHVzaCh1Zl8xKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRW5kcyB0aGUgcHJvY2VzcyBvZiBhZGRpbmcgZmlsZXMgYW5kIHByZXBhcmVzIHRvIGVtaXQgdGhlIGZpbmFsIGNodW5rcy5cbiAgICAgKiBUaGlzICptdXN0KiBiZSBjYWxsZWQgYWZ0ZXIgYWRkaW5nIGFsbCBkZXNpcmVkIGZpbGVzIGZvciB0aGUgcmVzdWx0aW5nXG4gICAgICogWklQIGZpbGUgdG8gd29yayBwcm9wZXJseS5cbiAgICAgKi9cbiAgICBaaXAucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZCAmIDIpIHtcbiAgICAgICAgICAgIHRoaXMub25kYXRhKGVycig0ICsgKHRoaXMuZCAmIDEpICogOCwgMCwgMSksIG51bGwsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmQpXG4gICAgICAgICAgICB0aGlzLmUoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy51LnB1c2goe1xuICAgICAgICAgICAgICAgIHI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoX3RoaXMuZCAmIDEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy51LnNwbGljZSgtMSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHQ6IGZ1bmN0aW9uICgpIHsgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZCA9IDM7XG4gICAgfTtcbiAgICBaaXAucHJvdG90eXBlLmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidCA9IDAsIGwgPSAwLCB0bCA9IDA7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnU7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZiA9IF9hW19pXTtcbiAgICAgICAgICAgIHRsICs9IDQ2ICsgZi5mLmxlbmd0aCArIGV4ZmwoZi5leHRyYSkgKyAoZi5vID8gZi5vLmxlbmd0aCA6IDApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXQgPSBuZXcgdTgodGwgKyAyMik7XG4gICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSB0aGlzLnU7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICB2YXIgZiA9IF9jW19iXTtcbiAgICAgICAgICAgIHd6aChvdXQsIGJ0LCBmLCBmLmYsIGYudSwgLWYuYyAtIDIsIGwsIGYubyk7XG4gICAgICAgICAgICBidCArPSA0NiArIGYuZi5sZW5ndGggKyBleGZsKGYuZXh0cmEpICsgKGYubyA/IGYuby5sZW5ndGggOiAwKSwgbCArPSBmLmI7XG4gICAgICAgIH1cbiAgICAgICAgd3pmKG91dCwgYnQsIHRoaXMudS5sZW5ndGgsIHRsLCBsKTtcbiAgICAgICAgdGhpcy5vbmRhdGEobnVsbCwgb3V0LCB0cnVlKTtcbiAgICAgICAgdGhpcy5kID0gMjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWV0aG9kIHRvIHRlcm1pbmF0ZSBhbnkgaW50ZXJuYWwgd29ya2VycyB1c2VkIGJ5IHRoZSBzdHJlYW0uIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyB0byBhZGQoKSB3aWxsIGZhaWwuXG4gICAgICovXG4gICAgWmlwLnByb3RvdHlwZS50ZXJtaW5hdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnU7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZiA9IF9hW19pXTtcbiAgICAgICAgICAgIGYudCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZCA9IDI7XG4gICAgfTtcbiAgICByZXR1cm4gWmlwO1xufSgpKTtcbmV4cG9ydCB7IFppcCB9O1xuZXhwb3J0IGZ1bmN0aW9uIHppcChkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgZXJyKDcpO1xuICAgIHZhciByID0ge307XG4gICAgZmx0bihkYXRhLCAnJywgciwgb3B0cyk7XG4gICAgdmFyIGsgPSBPYmplY3Qua2V5cyhyKTtcbiAgICB2YXIgbGZ0ID0gay5sZW5ndGgsIG8gPSAwLCB0b3QgPSAwO1xuICAgIHZhciBzbGZ0ID0gbGZ0LCBmaWxlcyA9IG5ldyBBcnJheShsZnQpO1xuICAgIHZhciB0ZXJtID0gW107XG4gICAgdmFyIHRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVybS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHRlcm1baV0oKTtcbiAgICB9O1xuICAgIHZhciBjYmQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBtdChmdW5jdGlvbiAoKSB7IGNiKGEsIGIpOyB9KTtcbiAgICB9O1xuICAgIG10KGZ1bmN0aW9uICgpIHsgY2JkID0gY2I7IH0pO1xuICAgIHZhciBjYmYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdXQgPSBuZXcgdTgodG90ICsgMjIpLCBvZSA9IG8sIGNkbCA9IHRvdCAtIG87XG4gICAgICAgIHRvdCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xmdDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgZiA9IGZpbGVzW2ldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGYuYy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd3poKG91dCwgdG90LCBmLCBmLmYsIGYudSwgbCk7XG4gICAgICAgICAgICAgICAgdmFyIGJhZGQgPSAzMCArIGYuZi5sZW5ndGggKyBleGZsKGYuZXh0cmEpO1xuICAgICAgICAgICAgICAgIHZhciBsb2MgPSB0b3QgKyBiYWRkO1xuICAgICAgICAgICAgICAgIG91dC5zZXQoZi5jLCBsb2MpO1xuICAgICAgICAgICAgICAgIHd6aChvdXQsIG8sIGYsIGYuZiwgZi51LCBsLCB0b3QsIGYubSksIG8gKz0gMTYgKyBiYWRkICsgKGYubSA/IGYubS5sZW5ndGggOiAwKSwgdG90ID0gbG9jICsgbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiZChlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3emYob3V0LCBvLCBmaWxlcy5sZW5ndGgsIGNkbCwgb2UpO1xuICAgICAgICBjYmQobnVsbCwgb3V0KTtcbiAgICB9O1xuICAgIGlmICghbGZ0KVxuICAgICAgICBjYmYoKTtcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHZhciBmbiA9IGtbaV07XG4gICAgICAgIHZhciBfYSA9IHJbZm5dLCBmaWxlID0gX2FbMF0sIHAgPSBfYVsxXTtcbiAgICAgICAgdmFyIGMgPSBjcmMoKSwgc2l6ZSA9IGZpbGUubGVuZ3RoO1xuICAgICAgICBjLnAoZmlsZSk7XG4gICAgICAgIHZhciBmID0gc3RyVG9VOChmbiksIHMgPSBmLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvbSA9IHAuY29tbWVudCwgbSA9IGNvbSAmJiBzdHJUb1U4KGNvbSksIG1zID0gbSAmJiBtLmxlbmd0aDtcbiAgICAgICAgdmFyIGV4bCA9IGV4ZmwocC5leHRyYSk7XG4gICAgICAgIHZhciBjb21wcmVzc2lvbiA9IHAubGV2ZWwgPT0gMCA/IDAgOiA4O1xuICAgICAgICB2YXIgY2JsID0gZnVuY3Rpb24gKGUsIGQpIHtcbiAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgdEFsbCgpO1xuICAgICAgICAgICAgICAgIGNiZChlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBsID0gZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZmlsZXNbaV0gPSBtcmcocCwge1xuICAgICAgICAgICAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgICAgICAgICAgICBjcmM6IGMuZCgpLFxuICAgICAgICAgICAgICAgICAgICBjOiBkLFxuICAgICAgICAgICAgICAgICAgICBmOiBmLFxuICAgICAgICAgICAgICAgICAgICBtOiBtLFxuICAgICAgICAgICAgICAgICAgICB1OiBzICE9IGZuLmxlbmd0aCB8fCAobSAmJiAoY29tLmxlbmd0aCAhPSBtcykpLFxuICAgICAgICAgICAgICAgICAgICBjb21wcmVzc2lvbjogY29tcHJlc3Npb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvICs9IDMwICsgcyArIGV4bCArIGw7XG4gICAgICAgICAgICAgICAgdG90ICs9IDc2ICsgMiAqIChzICsgZXhsKSArIChtcyB8fCAwKSArIGw7XG4gICAgICAgICAgICAgICAgaWYgKCEtLWxmdClcbiAgICAgICAgICAgICAgICAgICAgY2JmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzID4gNjU1MzUpXG4gICAgICAgICAgICBjYmwoZXJyKDExLCAwLCAxKSwgbnVsbCk7XG4gICAgICAgIGlmICghY29tcHJlc3Npb24pXG4gICAgICAgICAgICBjYmwobnVsbCwgZmlsZSk7XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPCAxNjAwMDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2JsKG51bGwsIGRlZmxhdGVTeW5jKGZpbGUsIHApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY2JsKGUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRlcm0ucHVzaChkZWZsYXRlKGZpbGUsIHAsIGNibCkpO1xuICAgIH07XG4gICAgLy8gQ2Fubm90IHVzZSBsZnQgYmVjYXVzZSBpdCBjYW4gZGVjcmVhc2VcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsZnQ7ICsraSkge1xuICAgICAgICBfbG9vcF8xKGkpO1xuICAgIH1cbiAgICByZXR1cm4gdEFsbDtcbn1cbi8qKlxuICogU3luY2hyb25vdXNseSBjcmVhdGVzIGEgWklQIGZpbGUuIFByZWZlciB1c2luZyBgemlwYCBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG4gKiB3aXRoIG1vcmUgdGhhbiBvbmUgZmlsZS5cbiAqIEBwYXJhbSBkYXRhIFRoZSBkaXJlY3Rvcnkgc3RydWN0dXJlIGZvciB0aGUgWklQIGFyY2hpdmVcbiAqIEBwYXJhbSBvcHRzIFRoZSBtYWluIG9wdGlvbnMsIG1lcmdlZCB3aXRoIHBlci1maWxlIG9wdGlvbnNcbiAqIEByZXR1cm5zIFRoZSBnZW5lcmF0ZWQgWklQIGFyY2hpdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHppcFN5bmMoZGF0YSwgb3B0cykge1xuICAgIGlmICghb3B0cylcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgIHZhciByID0ge307XG4gICAgdmFyIGZpbGVzID0gW107XG4gICAgZmx0bihkYXRhLCAnJywgciwgb3B0cyk7XG4gICAgdmFyIG8gPSAwO1xuICAgIHZhciB0b3QgPSAwO1xuICAgIGZvciAodmFyIGZuIGluIHIpIHtcbiAgICAgICAgdmFyIF9hID0gcltmbl0sIGZpbGUgPSBfYVswXSwgcCA9IF9hWzFdO1xuICAgICAgICB2YXIgY29tcHJlc3Npb24gPSBwLmxldmVsID09IDAgPyAwIDogODtcbiAgICAgICAgdmFyIGYgPSBzdHJUb1U4KGZuKSwgcyA9IGYubGVuZ3RoO1xuICAgICAgICB2YXIgY29tID0gcC5jb21tZW50LCBtID0gY29tICYmIHN0clRvVTgoY29tKSwgbXMgPSBtICYmIG0ubGVuZ3RoO1xuICAgICAgICB2YXIgZXhsID0gZXhmbChwLmV4dHJhKTtcbiAgICAgICAgaWYgKHMgPiA2NTUzNSlcbiAgICAgICAgICAgIGVycigxMSk7XG4gICAgICAgIHZhciBkID0gY29tcHJlc3Npb24gPyBkZWZsYXRlU3luYyhmaWxlLCBwKSA6IGZpbGUsIGwgPSBkLmxlbmd0aDtcbiAgICAgICAgdmFyIGMgPSBjcmMoKTtcbiAgICAgICAgYy5wKGZpbGUpO1xuICAgICAgICBmaWxlcy5wdXNoKG1yZyhwLCB7XG4gICAgICAgICAgICBzaXplOiBmaWxlLmxlbmd0aCxcbiAgICAgICAgICAgIGNyYzogYy5kKCksXG4gICAgICAgICAgICBjOiBkLFxuICAgICAgICAgICAgZjogZixcbiAgICAgICAgICAgIG06IG0sXG4gICAgICAgICAgICB1OiBzICE9IGZuLmxlbmd0aCB8fCAobSAmJiAoY29tLmxlbmd0aCAhPSBtcykpLFxuICAgICAgICAgICAgbzogbyxcbiAgICAgICAgICAgIGNvbXByZXNzaW9uOiBjb21wcmVzc2lvblxuICAgICAgICB9KSk7XG4gICAgICAgIG8gKz0gMzAgKyBzICsgZXhsICsgbDtcbiAgICAgICAgdG90ICs9IDc2ICsgMiAqIChzICsgZXhsKSArIChtcyB8fCAwKSArIGw7XG4gICAgfVxuICAgIHZhciBvdXQgPSBuZXcgdTgodG90ICsgMjIpLCBvZSA9IG8sIGNkbCA9IHRvdCAtIG87XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZiA9IGZpbGVzW2ldO1xuICAgICAgICB3emgob3V0LCBmLm8sIGYsIGYuZiwgZi51LCBmLmMubGVuZ3RoKTtcbiAgICAgICAgdmFyIGJhZGQgPSAzMCArIGYuZi5sZW5ndGggKyBleGZsKGYuZXh0cmEpO1xuICAgICAgICBvdXQuc2V0KGYuYywgZi5vICsgYmFkZCk7XG4gICAgICAgIHd6aChvdXQsIG8sIGYsIGYuZiwgZi51LCBmLmMubGVuZ3RoLCBmLm8sIGYubSksIG8gKz0gMTYgKyBiYWRkICsgKGYubSA/IGYubS5sZW5ndGggOiAwKTtcbiAgICB9XG4gICAgd3pmKG91dCwgbywgZmlsZXMubGVuZ3RoLCBjZGwsIG9lKTtcbiAgICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTdHJlYW1pbmcgcGFzcy10aHJvdWdoIGRlY29tcHJlc3Npb24gZm9yIFpJUCBhcmNoaXZlc1xuICovXG52YXIgVW56aXBQYXNzVGhyb3VnaCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVbnppcFBhc3NUaHJvdWdoKCkge1xuICAgIH1cbiAgICBVbnppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZpbmFsKSB7XG4gICAgICAgIHRoaXMub25kYXRhKG51bGwsIGRhdGEsIGZpbmFsKTtcbiAgICB9O1xuICAgIFVuemlwUGFzc1Rocm91Z2guY29tcHJlc3Npb24gPSAwO1xuICAgIHJldHVybiBVbnppcFBhc3NUaHJvdWdoO1xufSgpKTtcbmV4cG9ydCB7IFVuemlwUGFzc1Rocm91Z2ggfTtcbi8qKlxuICogU3RyZWFtaW5nIERFRkxBVEUgZGVjb21wcmVzc2lvbiBmb3IgWklQIGFyY2hpdmVzLiBQcmVmZXIgQXN5bmNaaXBJbmZsYXRlIGZvclxuICogYmV0dGVyIHBlcmZvcm1hbmNlLlxuICovXG52YXIgVW56aXBJbmZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBERUZMQVRFIGRlY29tcHJlc3Npb24gdGhhdCBjYW4gYmUgdXNlZCBpbiBaSVAgYXJjaGl2ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBVbnppcEluZmxhdGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuaSA9IG5ldyBJbmZsYXRlKGZ1bmN0aW9uIChkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICBfdGhpcy5vbmRhdGEobnVsbCwgZGF0LCBmaW5hbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBVbnppcEluZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgZmluYWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaS5wdXNoKGRhdGEsIGZpbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5vbmRhdGEoZSwgbnVsbCwgZmluYWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVbnppcEluZmxhdGUuY29tcHJlc3Npb24gPSA4O1xuICAgIHJldHVybiBVbnppcEluZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgVW56aXBJbmZsYXRlIH07XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgREVGTEFURSBkZWNvbXByZXNzaW9uIGZvciBaSVAgYXJjaGl2ZXNcbiAqL1xudmFyIEFzeW5jVW56aXBJbmZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBERUZMQVRFIGRlY29tcHJlc3Npb24gdGhhdCBjYW4gYmUgdXNlZCBpbiBaSVAgYXJjaGl2ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBc3luY1VuemlwSW5mbGF0ZShfLCBzeikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoc3ogPCAzMjAwMDApIHtcbiAgICAgICAgICAgIHRoaXMuaSA9IG5ldyBJbmZsYXRlKGZ1bmN0aW9uIChkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25kYXRhKG51bGwsIGRhdCwgZmluYWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmkgPSBuZXcgQXN5bmNJbmZsYXRlKGZ1bmN0aW9uIChlcnIsIGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbmRhdGEoZXJyLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGUgPSB0aGlzLmkudGVybWluYXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFzeW5jVW56aXBJbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZpbmFsKSB7XG4gICAgICAgIGlmICh0aGlzLmkudGVybWluYXRlKVxuICAgICAgICAgICAgZGF0YSA9IHNsYyhkYXRhLCAwKTtcbiAgICAgICAgdGhpcy5pLnB1c2goZGF0YSwgZmluYWwpO1xuICAgIH07XG4gICAgQXN5bmNVbnppcEluZmxhdGUuY29tcHJlc3Npb24gPSA4O1xuICAgIHJldHVybiBBc3luY1VuemlwSW5mbGF0ZTtcbn0oKSk7XG5leHBvcnQgeyBBc3luY1VuemlwSW5mbGF0ZSB9O1xuLyoqXG4gKiBBIFpJUCBhcmNoaXZlIGRlY29tcHJlc3Npb24gc3RyZWFtIHRoYXQgZW1pdHMgZmlsZXMgYXMgdGhleSBhcmUgZGlzY292ZXJlZFxuICovXG52YXIgVW56aXAgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFpJUCBkZWNvbXByZXNzaW9uIHN0cmVhbVxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBhIGZpbGUgaW4gdGhlIFpJUCBhcmNoaXZlIGlzIGZvdW5kXG4gICAgICovXG4gICAgZnVuY3Rpb24gVW56aXAoY2IpIHtcbiAgICAgICAgdGhpcy5vbmZpbGUgPSBjYjtcbiAgICAgICAgdGhpcy5rID0gW107XG4gICAgICAgIHRoaXMubyA9IHtcbiAgICAgICAgICAgIDA6IFVuemlwUGFzc1Rocm91Z2hcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wID0gZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIHVuemlwcGVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIFVuemlwLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMub25maWxlKVxuICAgICAgICAgICAgZXJyKDUpO1xuICAgICAgICBpZiAoIXRoaXMucClcbiAgICAgICAgICAgIGVycig0KTtcbiAgICAgICAgaWYgKHRoaXMuYyA+IDApIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbih0aGlzLmMsIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgdG9BZGQgPSBjaHVuay5zdWJhcnJheSgwLCBsZW4pO1xuICAgICAgICAgICAgdGhpcy5jIC09IGxlbjtcbiAgICAgICAgICAgIGlmICh0aGlzLmQpXG4gICAgICAgICAgICAgICAgdGhpcy5kLnB1c2godG9BZGQsICF0aGlzLmMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMua1swXS5wdXNoKHRvQWRkKTtcbiAgICAgICAgICAgIGNodW5rID0gY2h1bmsuc3ViYXJyYXkobGVuKTtcbiAgICAgICAgICAgIGlmIChjaHVuay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaChjaHVuaywgZmluYWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGYgPSAwLCBpID0gMCwgaXMgPSB2b2lkIDAsIGJ1ZiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICghdGhpcy5wLmxlbmd0aClcbiAgICAgICAgICAgICAgICBidWYgPSBjaHVuaztcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjaHVuay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYnVmID0gdGhpcy5wO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmID0gbmV3IHU4KHRoaXMucC5sZW5ndGggKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJ1Zi5zZXQodGhpcy5wKSwgYnVmLnNldChjaHVuaywgdGhpcy5wLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbCA9IGJ1Zi5sZW5ndGgsIG9jID0gdGhpcy5jLCBhZGQgPSBvYyAmJiB0aGlzLmQ7XG4gICAgICAgICAgICB2YXIgX2xvb3BfMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgdmFyIHNpZyA9IGI0KGJ1ZiwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpZyA9PSAweDQwMzRCNTApIHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IDEsIGlzID0gaTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc18xLmQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzXzEuYyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiZiA9IGIyKGJ1ZiwgaSArIDYpLCBjbXBfMSA9IGIyKGJ1ZiwgaSArIDgpLCB1ID0gYmYgJiAyMDQ4LCBkZCA9IGJmICYgOCwgZm5sID0gYjIoYnVmLCBpICsgMjYpLCBlcyA9IGIyKGJ1ZiwgaSArIDI4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGwgPiBpICsgMzAgKyBmbmwgKyBlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoa3NfMyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLmsudW5zaGlmdChjaGtzXzMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZiA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NfMSA9IGI0KGJ1ZiwgaSArIDE4KSwgc3VfMSA9IGI0KGJ1ZiwgaSArIDIyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbl8xID0gc3RyRnJvbVU4KGJ1Zi5zdWJhcnJheShpICsgMzAsIGkgKz0gMzAgKyBmbmwpLCAhdSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NfMSA9PSA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBkZCA/IFstMl0gOiB6NjRlKGJ1ZiwgaSksIHNjXzEgPSBfYVswXSwgc3VfMSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NfMSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5jID0gc2NfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZV8xID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZuXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHJlc3Npb246IGNtcF8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsZV8xLm9uZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycig1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzY18xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZV8xLm9uZGF0YShudWxsLCBldCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN0ciA9IF90aGlzLm9bY21wXzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdHIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZV8xLm9uZGF0YShlcnIoMTQsICd1bmtub3duIGNvbXByZXNzaW9uIHR5cGUgJyArIGNtcF8xLCAxKSwgbnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZF8xID0gc2NfMSA8IDAgPyBuZXcgY3RyKGZuXzEpIDogbmV3IGN0cihmbl8xLCBzY18xLCBzdV8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRfMS5vbmRhdGEgPSBmdW5jdGlvbiAoZXJyLCBkYXQsIGZpbmFsKSB7IGZpbGVfMS5vbmRhdGEoZXJyLCBkYXQsIGZpbmFsKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgY2hrc180ID0gY2hrc18zOyBfaSA8IGNoa3NfNC5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0ID0gY2hrc180W19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkXzEucHVzaChkYXQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5rWzBdID09IGNoa3NfMyAmJiBfdGhpcy5jKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmQgPSBkXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZF8xLnB1c2goZXQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRfMSAmJiBkXzEudGVybWluYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZF8xLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NfMSA+PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVfMS5zaXplID0gc2NfMSwgZmlsZV8xLm9yaWdpbmFsU2l6ZSA9IHN1XzE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEub25maWxlKGZpbGVfMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZyA9PSAweDgwNzRCNTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzID0gaSArPSAxMiArIChvYyA9PSAtMiAmJiA4KSwgZiA9IDMsIHRoaXNfMS5jID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2lnID09IDB4MjAxNEI1MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXMgPSBpIC09IDQsIGYgPSAzLCB0aGlzXzEuYyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICAgICAgZm9yICg7IGkgPCBsIC0gNDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlXzEgPSBfbG9vcF8yKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlXzEgPT09IFwiYnJlYWtcIilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnAgPSBldDtcbiAgICAgICAgICAgIGlmIChvYyA8IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ID0gZiA/IGJ1Zi5zdWJhcnJheSgwLCBpcyAtIDEyIC0gKG9jID09IC0yICYmIDgpIC0gKGI0KGJ1ZiwgaXMgLSAxNikgPT0gMHg4MDc0QjUwICYmIDQpKSA6IGJ1Zi5zdWJhcnJheSgwLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoYWRkKVxuICAgICAgICAgICAgICAgICAgICBhZGQucHVzaChkYXQsICEhZik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmtbKyhmID09IDIpXS5wdXNoKGRhdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZiAmIDIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaChidWYuc3ViYXJyYXkoaSksIGZpbmFsKTtcbiAgICAgICAgICAgIHRoaXMucCA9IGJ1Zi5zdWJhcnJheShpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmMpXG4gICAgICAgICAgICAgICAgZXJyKDEzKTtcbiAgICAgICAgICAgIHRoaXMucCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGRlY29kZXIgd2l0aCB0aGUgc3RyZWFtLCBhbGxvd2luZyBmb3IgZmlsZXMgY29tcHJlc3NlZCB3aXRoXG4gICAgICogdGhlIGNvbXByZXNzaW9uIHR5cGUgcHJvdmlkZWQgdG8gYmUgZXhwYW5kZWQgY29ycmVjdGx5XG4gICAgICogQHBhcmFtIGRlY29kZXIgVGhlIGRlY29kZXIgY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBVbnppcC5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZGVjb2Rlcikge1xuICAgICAgICB0aGlzLm9bZGVjb2Rlci5jb21wcmVzc2lvbl0gPSBkZWNvZGVyO1xuICAgIH07XG4gICAgcmV0dXJuIFVuemlwO1xufSgpKTtcbmV4cG9ydCB7IFVuemlwIH07XG52YXIgbXQgPSB0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT0gJ2Z1bmN0aW9uJyA/IHF1ZXVlTWljcm90YXNrIDogdHlwZW9mIHNldFRpbWVvdXQgPT0gJ2Z1bmN0aW9uJyA/IHNldFRpbWVvdXQgOiBmdW5jdGlvbiAoZm4pIHsgZm4oKTsgfTtcbmV4cG9ydCBmdW5jdGlvbiB1bnppcChkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgZXJyKDcpO1xuICAgIHZhciB0ZXJtID0gW107XG4gICAgdmFyIHRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVybS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHRlcm1baV0oKTtcbiAgICB9O1xuICAgIHZhciBmaWxlcyA9IHt9O1xuICAgIHZhciBjYmQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBtdChmdW5jdGlvbiAoKSB7IGNiKGEsIGIpOyB9KTtcbiAgICB9O1xuICAgIG10KGZ1bmN0aW9uICgpIHsgY2JkID0gY2I7IH0pO1xuICAgIHZhciBlID0gZGF0YS5sZW5ndGggLSAyMjtcbiAgICBmb3IgKDsgYjQoZGF0YSwgZSkgIT0gMHg2MDU0QjUwOyAtLWUpIHtcbiAgICAgICAgaWYgKCFlIHx8IGRhdGEubGVuZ3RoIC0gZSA+IDY1NTU4KSB7XG4gICAgICAgICAgICBjYmQoZXJyKDEzLCAwLCAxKSwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdEFsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgdmFyIGxmdCA9IGIyKGRhdGEsIGUgKyA4KTtcbiAgICBpZiAobGZ0KSB7XG4gICAgICAgIHZhciBjID0gbGZ0O1xuICAgICAgICB2YXIgbyA9IGI0KGRhdGEsIGUgKyAxNik7XG4gICAgICAgIHZhciB6ID0gbyA9PSA0Mjk0OTY3Mjk1IHx8IGMgPT0gNjU1MzU7XG4gICAgICAgIGlmICh6KSB7XG4gICAgICAgICAgICB2YXIgemUgPSBiNChkYXRhLCBlIC0gMTIpO1xuICAgICAgICAgICAgeiA9IGI0KGRhdGEsIHplKSA9PSAweDYwNjRCNTA7XG4gICAgICAgICAgICBpZiAoeikge1xuICAgICAgICAgICAgICAgIGMgPSBsZnQgPSBiNChkYXRhLCB6ZSArIDMyKTtcbiAgICAgICAgICAgICAgICBvID0gYjQoZGF0YSwgemUgKyA0OCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZsdHIgPSBvcHRzICYmIG9wdHMuZmlsdGVyO1xuICAgICAgICB2YXIgX2xvb3BfMyA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB6aChkYXRhLCBvLCB6KSwgY18xID0gX2FbMF0sIHNjID0gX2FbMV0sIHN1ID0gX2FbMl0sIGZuID0gX2FbM10sIG5vID0gX2FbNF0sIG9mZiA9IF9hWzVdLCBiID0gc2x6aChkYXRhLCBvZmYpO1xuICAgICAgICAgICAgbyA9IG5vO1xuICAgICAgICAgICAgdmFyIGNibCA9IGZ1bmN0aW9uIChlLCBkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdEFsbCgpO1xuICAgICAgICAgICAgICAgICAgICBjYmQoZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzW2ZuXSA9IGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghLS1sZnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjYmQobnVsbCwgZmlsZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIWZsdHIgfHwgZmx0cih7XG4gICAgICAgICAgICAgICAgbmFtZTogZm4sXG4gICAgICAgICAgICAgICAgc2l6ZTogc2MsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxTaXplOiBzdSxcbiAgICAgICAgICAgICAgICBjb21wcmVzc2lvbjogY18xXG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIGlmICghY18xKVxuICAgICAgICAgICAgICAgICAgICBjYmwobnVsbCwgc2xjKGRhdGEsIGIsIGIgKyBzYykpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNfMSA9PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmZsID0gZGF0YS5zdWJhcnJheShiLCBiICsgc2MpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTeW5jaHJvbm91c2x5IGRlY29tcHJlc3MgdW5kZXIgNTEyS0IsIG9yIGJhcmVseS1jb21wcmVzc2VkIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1IDwgNTI0Mjg4IHx8IHNjID4gMC44ICogc3UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2JsKG51bGwsIGluZmxhdGVTeW5jKGluZmwsIHsgb3V0OiBuZXcgdTgoc3UpIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2JsKGUsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm0ucHVzaChpbmZsYXRlKGluZmwsIHsgc2l6ZTogc3UgfSwgY2JsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY2JsKGVycigxNCwgJ3Vua25vd24gY29tcHJlc3Npb24gdHlwZSAnICsgY18xLCAxKSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2JsKG51bGwsIG51bGwpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGM7ICsraSkge1xuICAgICAgICAgICAgX2xvb3BfMyhpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIGNiZChudWxsLCB7fSk7XG4gICAgcmV0dXJuIHRBbGw7XG59XG4vKipcbiAqIFN5bmNocm9ub3VzbHkgZGVjb21wcmVzc2VzIGEgWklQIGFyY2hpdmUuIFByZWZlciB1c2luZyBgdW56aXBgIGZvciBiZXR0ZXJcbiAqIHBlcmZvcm1hbmNlIHdpdGggbW9yZSB0aGFuIG9uZSBmaWxlLlxuICogQHBhcmFtIGRhdGEgVGhlIHJhdyBjb21wcmVzc2VkIFpJUCBmaWxlXG4gKiBAcGFyYW0gb3B0cyBUaGUgWklQIGV4dHJhY3Rpb24gb3B0aW9uc1xuICogQHJldHVybnMgVGhlIGRlY29tcHJlc3NlZCBmaWxlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdW56aXBTeW5jKGRhdGEsIG9wdHMpIHtcbiAgICB2YXIgZmlsZXMgPSB7fTtcbiAgICB2YXIgZSA9IGRhdGEubGVuZ3RoIC0gMjI7XG4gICAgZm9yICg7IGI0KGRhdGEsIGUpICE9IDB4NjA1NEI1MDsgLS1lKSB7XG4gICAgICAgIGlmICghZSB8fCBkYXRhLmxlbmd0aCAtIGUgPiA2NTU1OClcbiAgICAgICAgICAgIGVycigxMyk7XG4gICAgfVxuICAgIDtcbiAgICB2YXIgYyA9IGIyKGRhdGEsIGUgKyA4KTtcbiAgICBpZiAoIWMpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB2YXIgbyA9IGI0KGRhdGEsIGUgKyAxNik7XG4gICAgdmFyIHogPSBvID09IDQyOTQ5NjcyOTUgfHwgYyA9PSA2NTUzNTtcbiAgICBpZiAoeikge1xuICAgICAgICB2YXIgemUgPSBiNChkYXRhLCBlIC0gMTIpO1xuICAgICAgICB6ID0gYjQoZGF0YSwgemUpID09IDB4NjA2NEI1MDtcbiAgICAgICAgaWYgKHopIHtcbiAgICAgICAgICAgIGMgPSBiNChkYXRhLCB6ZSArIDMyKTtcbiAgICAgICAgICAgIG8gPSBiNChkYXRhLCB6ZSArIDQ4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZmx0ciA9IG9wdHMgJiYgb3B0cy5maWx0ZXI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjOyArK2kpIHtcbiAgICAgICAgdmFyIF9hID0gemgoZGF0YSwgbywgeiksIGNfMiA9IF9hWzBdLCBzYyA9IF9hWzFdLCBzdSA9IF9hWzJdLCBmbiA9IF9hWzNdLCBubyA9IF9hWzRdLCBvZmYgPSBfYVs1XSwgYiA9IHNsemgoZGF0YSwgb2ZmKTtcbiAgICAgICAgbyA9IG5vO1xuICAgICAgICBpZiAoIWZsdHIgfHwgZmx0cih7XG4gICAgICAgICAgICBuYW1lOiBmbixcbiAgICAgICAgICAgIHNpemU6IHNjLFxuICAgICAgICAgICAgb3JpZ2luYWxTaXplOiBzdSxcbiAgICAgICAgICAgIGNvbXByZXNzaW9uOiBjXzJcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIGlmICghY18yKVxuICAgICAgICAgICAgICAgIGZpbGVzW2ZuXSA9IHNsYyhkYXRhLCBiLCBiICsgc2MpO1xuICAgICAgICAgICAgZWxzZSBpZiAoY18yID09IDgpXG4gICAgICAgICAgICAgICAgZmlsZXNbZm5dID0gaW5mbGF0ZVN5bmMoZGF0YS5zdWJhcnJheShiLCBiICsgc2MpLCB7IG91dDogbmV3IHU4KHN1KSB9KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBlcnIoMTQsICd1bmtub3duIGNvbXByZXNzaW9uIHR5cGUgJyArIGNfMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbGVzO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fflate/esm/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/compiled/buffer/index.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={675:function(e,r){\"use strict\";r.byteLength=byteLength;r.toByteArray=toByteArray;r.fromByteArray=fromByteArray;var t=[];var f=[];var n=typeof Uint8Array!==\"undefined\"?Uint8Array:Array;var i=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";for(var o=0,u=i.length;o<u;++o){t[o]=i[o];f[i.charCodeAt(o)]=o}f[\"-\".charCodeAt(0)]=62;f[\"_\".charCodeAt(0)]=63;function getLens(e){var r=e.length;if(r%4>0){throw new Error(\"Invalid string. Length must be a multiple of 4\")}var t=e.indexOf(\"=\");if(t===-1)t=r;var f=t===r?0:4-t%4;return[t,f]}function byteLength(e){var r=getLens(e);var t=r[0];var f=r[1];return(t+f)*3/4-f}function _byteLength(e,r,t){return(r+t)*3/4-t}function toByteArray(e){var r;var t=getLens(e);var i=t[0];var o=t[1];var u=new n(_byteLength(e,i,o));var a=0;var s=o>0?i-4:i;var h;for(h=0;h<s;h+=4){r=f[e.charCodeAt(h)]<<18|f[e.charCodeAt(h+1)]<<12|f[e.charCodeAt(h+2)]<<6|f[e.charCodeAt(h+3)];u[a++]=r>>16&255;u[a++]=r>>8&255;u[a++]=r&255}if(o===2){r=f[e.charCodeAt(h)]<<2|f[e.charCodeAt(h+1)]>>4;u[a++]=r&255}if(o===1){r=f[e.charCodeAt(h)]<<10|f[e.charCodeAt(h+1)]<<4|f[e.charCodeAt(h+2)]>>2;u[a++]=r>>8&255;u[a++]=r&255}return u}function tripletToBase64(e){return t[e>>18&63]+t[e>>12&63]+t[e>>6&63]+t[e&63]}function encodeChunk(e,r,t){var f;var n=[];for(var i=r;i<t;i+=3){f=(e[i]<<16&16711680)+(e[i+1]<<8&65280)+(e[i+2]&255);n.push(tripletToBase64(f))}return n.join(\"\")}function fromByteArray(e){var r;var f=e.length;var n=f%3;var i=[];var o=16383;for(var u=0,a=f-n;u<a;u+=o){i.push(encodeChunk(e,u,u+o>a?a:u+o))}if(n===1){r=e[f-1];i.push(t[r>>2]+t[r<<4&63]+\"==\")}else if(n===2){r=(e[f-2]<<8)+e[f-1];i.push(t[r>>10]+t[r>>4&63]+t[r<<2&63]+\"=\")}return i.join(\"\")}},72:function(e,r,t){\"use strict\";\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */var f=t(675);var n=t(783);var i=typeof Symbol===\"function\"&&typeof Symbol.for===\"function\"?Symbol.for(\"nodejs.util.inspect.custom\"):null;r.Buffer=Buffer;r.SlowBuffer=SlowBuffer;r.INSPECT_MAX_BYTES=50;var o=2147483647;r.kMaxLength=o;Buffer.TYPED_ARRAY_SUPPORT=typedArraySupport();if(!Buffer.TYPED_ARRAY_SUPPORT&&typeof console!==\"undefined\"&&typeof console.error===\"function\"){console.error(\"This browser lacks typed array (Uint8Array) support which is required by \"+\"`buffer` v5.x. Use `buffer` v4.x if you require old browser support.\")}function typedArraySupport(){try{var e=new Uint8Array(1);var r={foo:function(){return 42}};Object.setPrototypeOf(r,Uint8Array.prototype);Object.setPrototypeOf(e,r);return e.foo()===42}catch(e){return false}}Object.defineProperty(Buffer.prototype,\"parent\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.buffer}});Object.defineProperty(Buffer.prototype,\"offset\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.byteOffset}});function createBuffer(e){if(e>o){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}var r=new Uint8Array(e);Object.setPrototypeOf(r,Buffer.prototype);return r}function Buffer(e,r,t){if(typeof e===\"number\"){if(typeof r===\"string\"){throw new TypeError('The \"string\" argument must be of type string. Received type number')}return allocUnsafe(e)}return from(e,r,t)}Buffer.poolSize=8192;function from(e,r,t){if(typeof e===\"string\"){return fromString(e,r)}if(ArrayBuffer.isView(e)){return fromArrayLike(e)}if(e==null){throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}if(isInstance(e,ArrayBuffer)||e&&isInstance(e.buffer,ArrayBuffer)){return fromArrayBuffer(e,r,t)}if(typeof SharedArrayBuffer!==\"undefined\"&&(isInstance(e,SharedArrayBuffer)||e&&isInstance(e.buffer,SharedArrayBuffer))){return fromArrayBuffer(e,r,t)}if(typeof e===\"number\"){throw new TypeError('The \"value\" argument must not be of type number. Received type number')}var f=e.valueOf&&e.valueOf();if(f!=null&&f!==e){return Buffer.from(f,r,t)}var n=fromObject(e);if(n)return n;if(typeof Symbol!==\"undefined\"&&Symbol.toPrimitive!=null&&typeof e[Symbol.toPrimitive]===\"function\"){return Buffer.from(e[Symbol.toPrimitive](\"string\"),r,t)}throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}Buffer.from=function(e,r,t){return from(e,r,t)};Object.setPrototypeOf(Buffer.prototype,Uint8Array.prototype);Object.setPrototypeOf(Buffer,Uint8Array);function assertSize(e){if(typeof e!==\"number\"){throw new TypeError('\"size\" argument must be of type number')}else if(e<0){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}}function alloc(e,r,t){assertSize(e);if(e<=0){return createBuffer(e)}if(r!==undefined){return typeof t===\"string\"?createBuffer(e).fill(r,t):createBuffer(e).fill(r)}return createBuffer(e)}Buffer.alloc=function(e,r,t){return alloc(e,r,t)};function allocUnsafe(e){assertSize(e);return createBuffer(e<0?0:checked(e)|0)}Buffer.allocUnsafe=function(e){return allocUnsafe(e)};Buffer.allocUnsafeSlow=function(e){return allocUnsafe(e)};function fromString(e,r){if(typeof r!==\"string\"||r===\"\"){r=\"utf8\"}if(!Buffer.isEncoding(r)){throw new TypeError(\"Unknown encoding: \"+r)}var t=byteLength(e,r)|0;var f=createBuffer(t);var n=f.write(e,r);if(n!==t){f=f.slice(0,n)}return f}function fromArrayLike(e){var r=e.length<0?0:checked(e.length)|0;var t=createBuffer(r);for(var f=0;f<r;f+=1){t[f]=e[f]&255}return t}function fromArrayBuffer(e,r,t){if(r<0||e.byteLength<r){throw new RangeError('\"offset\" is outside of buffer bounds')}if(e.byteLength<r+(t||0)){throw new RangeError('\"length\" is outside of buffer bounds')}var f;if(r===undefined&&t===undefined){f=new Uint8Array(e)}else if(t===undefined){f=new Uint8Array(e,r)}else{f=new Uint8Array(e,r,t)}Object.setPrototypeOf(f,Buffer.prototype);return f}function fromObject(e){if(Buffer.isBuffer(e)){var r=checked(e.length)|0;var t=createBuffer(r);if(t.length===0){return t}e.copy(t,0,0,r);return t}if(e.length!==undefined){if(typeof e.length!==\"number\"||numberIsNaN(e.length)){return createBuffer(0)}return fromArrayLike(e)}if(e.type===\"Buffer\"&&Array.isArray(e.data)){return fromArrayLike(e.data)}}function checked(e){if(e>=o){throw new RangeError(\"Attempt to allocate Buffer larger than maximum \"+\"size: 0x\"+o.toString(16)+\" bytes\")}return e|0}function SlowBuffer(e){if(+e!=e){e=0}return Buffer.alloc(+e)}Buffer.isBuffer=function isBuffer(e){return e!=null&&e._isBuffer===true&&e!==Buffer.prototype};Buffer.compare=function compare(e,r){if(isInstance(e,Uint8Array))e=Buffer.from(e,e.offset,e.byteLength);if(isInstance(r,Uint8Array))r=Buffer.from(r,r.offset,r.byteLength);if(!Buffer.isBuffer(e)||!Buffer.isBuffer(r)){throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array')}if(e===r)return 0;var t=e.length;var f=r.length;for(var n=0,i=Math.min(t,f);n<i;++n){if(e[n]!==r[n]){t=e[n];f=r[n];break}}if(t<f)return-1;if(f<t)return 1;return 0};Buffer.isEncoding=function isEncoding(e){switch(String(e).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return true;default:return false}};Buffer.concat=function concat(e,r){if(!Array.isArray(e)){throw new TypeError('\"list\" argument must be an Array of Buffers')}if(e.length===0){return Buffer.alloc(0)}var t;if(r===undefined){r=0;for(t=0;t<e.length;++t){r+=e[t].length}}var f=Buffer.allocUnsafe(r);var n=0;for(t=0;t<e.length;++t){var i=e[t];if(isInstance(i,Uint8Array)){i=Buffer.from(i)}if(!Buffer.isBuffer(i)){throw new TypeError('\"list\" argument must be an Array of Buffers')}i.copy(f,n);n+=i.length}return f};function byteLength(e,r){if(Buffer.isBuffer(e)){return e.length}if(ArrayBuffer.isView(e)||isInstance(e,ArrayBuffer)){return e.byteLength}if(typeof e!==\"string\"){throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. '+\"Received type \"+typeof e)}var t=e.length;var f=arguments.length>2&&arguments[2]===true;if(!f&&t===0)return 0;var n=false;for(;;){switch(r){case\"ascii\":case\"latin1\":case\"binary\":return t;case\"utf8\":case\"utf-8\":return utf8ToBytes(e).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return t*2;case\"hex\":return t>>>1;case\"base64\":return base64ToBytes(e).length;default:if(n){return f?-1:utf8ToBytes(e).length}r=(\"\"+r).toLowerCase();n=true}}}Buffer.byteLength=byteLength;function slowToString(e,r,t){var f=false;if(r===undefined||r<0){r=0}if(r>this.length){return\"\"}if(t===undefined||t>this.length){t=this.length}if(t<=0){return\"\"}t>>>=0;r>>>=0;if(t<=r){return\"\"}if(!e)e=\"utf8\";while(true){switch(e){case\"hex\":return hexSlice(this,r,t);case\"utf8\":case\"utf-8\":return utf8Slice(this,r,t);case\"ascii\":return asciiSlice(this,r,t);case\"latin1\":case\"binary\":return latin1Slice(this,r,t);case\"base64\":return base64Slice(this,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return utf16leSlice(this,r,t);default:if(f)throw new TypeError(\"Unknown encoding: \"+e);e=(e+\"\").toLowerCase();f=true}}}Buffer.prototype._isBuffer=true;function swap(e,r,t){var f=e[r];e[r]=e[t];e[t]=f}Buffer.prototype.swap16=function swap16(){var e=this.length;if(e%2!==0){throw new RangeError(\"Buffer size must be a multiple of 16-bits\")}for(var r=0;r<e;r+=2){swap(this,r,r+1)}return this};Buffer.prototype.swap32=function swap32(){var e=this.length;if(e%4!==0){throw new RangeError(\"Buffer size must be a multiple of 32-bits\")}for(var r=0;r<e;r+=4){swap(this,r,r+3);swap(this,r+1,r+2)}return this};Buffer.prototype.swap64=function swap64(){var e=this.length;if(e%8!==0){throw new RangeError(\"Buffer size must be a multiple of 64-bits\")}for(var r=0;r<e;r+=8){swap(this,r,r+7);swap(this,r+1,r+6);swap(this,r+2,r+5);swap(this,r+3,r+4)}return this};Buffer.prototype.toString=function toString(){var e=this.length;if(e===0)return\"\";if(arguments.length===0)return utf8Slice(this,0,e);return slowToString.apply(this,arguments)};Buffer.prototype.toLocaleString=Buffer.prototype.toString;Buffer.prototype.equals=function equals(e){if(!Buffer.isBuffer(e))throw new TypeError(\"Argument must be a Buffer\");if(this===e)return true;return Buffer.compare(this,e)===0};Buffer.prototype.inspect=function inspect(){var e=\"\";var t=r.INSPECT_MAX_BYTES;e=this.toString(\"hex\",0,t).replace(/(.{2})/g,\"$1 \").trim();if(this.length>t)e+=\" ... \";return\"<Buffer \"+e+\">\"};if(i){Buffer.prototype[i]=Buffer.prototype.inspect}Buffer.prototype.compare=function compare(e,r,t,f,n){if(isInstance(e,Uint8Array)){e=Buffer.from(e,e.offset,e.byteLength)}if(!Buffer.isBuffer(e)){throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. '+\"Received type \"+typeof e)}if(r===undefined){r=0}if(t===undefined){t=e?e.length:0}if(f===undefined){f=0}if(n===undefined){n=this.length}if(r<0||t>e.length||f<0||n>this.length){throw new RangeError(\"out of range index\")}if(f>=n&&r>=t){return 0}if(f>=n){return-1}if(r>=t){return 1}r>>>=0;t>>>=0;f>>>=0;n>>>=0;if(this===e)return 0;var i=n-f;var o=t-r;var u=Math.min(i,o);var a=this.slice(f,n);var s=e.slice(r,t);for(var h=0;h<u;++h){if(a[h]!==s[h]){i=a[h];o=s[h];break}}if(i<o)return-1;if(o<i)return 1;return 0};function bidirectionalIndexOf(e,r,t,f,n){if(e.length===0)return-1;if(typeof t===\"string\"){f=t;t=0}else if(t>2147483647){t=2147483647}else if(t<-2147483648){t=-2147483648}t=+t;if(numberIsNaN(t)){t=n?0:e.length-1}if(t<0)t=e.length+t;if(t>=e.length){if(n)return-1;else t=e.length-1}else if(t<0){if(n)t=0;else return-1}if(typeof r===\"string\"){r=Buffer.from(r,f)}if(Buffer.isBuffer(r)){if(r.length===0){return-1}return arrayIndexOf(e,r,t,f,n)}else if(typeof r===\"number\"){r=r&255;if(typeof Uint8Array.prototype.indexOf===\"function\"){if(n){return Uint8Array.prototype.indexOf.call(e,r,t)}else{return Uint8Array.prototype.lastIndexOf.call(e,r,t)}}return arrayIndexOf(e,[r],t,f,n)}throw new TypeError(\"val must be string, number or Buffer\")}function arrayIndexOf(e,r,t,f,n){var i=1;var o=e.length;var u=r.length;if(f!==undefined){f=String(f).toLowerCase();if(f===\"ucs2\"||f===\"ucs-2\"||f===\"utf16le\"||f===\"utf-16le\"){if(e.length<2||r.length<2){return-1}i=2;o/=2;u/=2;t/=2}}function read(e,r){if(i===1){return e[r]}else{return e.readUInt16BE(r*i)}}var a;if(n){var s=-1;for(a=t;a<o;a++){if(read(e,a)===read(r,s===-1?0:a-s)){if(s===-1)s=a;if(a-s+1===u)return s*i}else{if(s!==-1)a-=a-s;s=-1}}}else{if(t+u>o)t=o-u;for(a=t;a>=0;a--){var h=true;for(var c=0;c<u;c++){if(read(e,a+c)!==read(r,c)){h=false;break}}if(h)return a}}return-1}Buffer.prototype.includes=function includes(e,r,t){return this.indexOf(e,r,t)!==-1};Buffer.prototype.indexOf=function indexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,true)};Buffer.prototype.lastIndexOf=function lastIndexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,false)};function hexWrite(e,r,t,f){t=Number(t)||0;var n=e.length-t;if(!f){f=n}else{f=Number(f);if(f>n){f=n}}var i=r.length;if(f>i/2){f=i/2}for(var o=0;o<f;++o){var u=parseInt(r.substr(o*2,2),16);if(numberIsNaN(u))return o;e[t+o]=u}return o}function utf8Write(e,r,t,f){return blitBuffer(utf8ToBytes(r,e.length-t),e,t,f)}function asciiWrite(e,r,t,f){return blitBuffer(asciiToBytes(r),e,t,f)}function latin1Write(e,r,t,f){return asciiWrite(e,r,t,f)}function base64Write(e,r,t,f){return blitBuffer(base64ToBytes(r),e,t,f)}function ucs2Write(e,r,t,f){return blitBuffer(utf16leToBytes(r,e.length-t),e,t,f)}Buffer.prototype.write=function write(e,r,t,f){if(r===undefined){f=\"utf8\";t=this.length;r=0}else if(t===undefined&&typeof r===\"string\"){f=r;t=this.length;r=0}else if(isFinite(r)){r=r>>>0;if(isFinite(t)){t=t>>>0;if(f===undefined)f=\"utf8\"}else{f=t;t=undefined}}else{throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\")}var n=this.length-r;if(t===undefined||t>n)t=n;if(e.length>0&&(t<0||r<0)||r>this.length){throw new RangeError(\"Attempt to write outside buffer bounds\")}if(!f)f=\"utf8\";var i=false;for(;;){switch(f){case\"hex\":return hexWrite(this,e,r,t);case\"utf8\":case\"utf-8\":return utf8Write(this,e,r,t);case\"ascii\":return asciiWrite(this,e,r,t);case\"latin1\":case\"binary\":return latin1Write(this,e,r,t);case\"base64\":return base64Write(this,e,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return ucs2Write(this,e,r,t);default:if(i)throw new TypeError(\"Unknown encoding: \"+f);f=(\"\"+f).toLowerCase();i=true}}};Buffer.prototype.toJSON=function toJSON(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};function base64Slice(e,r,t){if(r===0&&t===e.length){return f.fromByteArray(e)}else{return f.fromByteArray(e.slice(r,t))}}function utf8Slice(e,r,t){t=Math.min(e.length,t);var f=[];var n=r;while(n<t){var i=e[n];var o=null;var u=i>239?4:i>223?3:i>191?2:1;if(n+u<=t){var a,s,h,c;switch(u){case 1:if(i<128){o=i}break;case 2:a=e[n+1];if((a&192)===128){c=(i&31)<<6|a&63;if(c>127){o=c}}break;case 3:a=e[n+1];s=e[n+2];if((a&192)===128&&(s&192)===128){c=(i&15)<<12|(a&63)<<6|s&63;if(c>2047&&(c<55296||c>57343)){o=c}}break;case 4:a=e[n+1];s=e[n+2];h=e[n+3];if((a&192)===128&&(s&192)===128&&(h&192)===128){c=(i&15)<<18|(a&63)<<12|(s&63)<<6|h&63;if(c>65535&&c<1114112){o=c}}}}if(o===null){o=65533;u=1}else if(o>65535){o-=65536;f.push(o>>>10&1023|55296);o=56320|o&1023}f.push(o);n+=u}return decodeCodePointsArray(f)}var u=4096;function decodeCodePointsArray(e){var r=e.length;if(r<=u){return String.fromCharCode.apply(String,e)}var t=\"\";var f=0;while(f<r){t+=String.fromCharCode.apply(String,e.slice(f,f+=u))}return t}function asciiSlice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n]&127)}return f}function latin1Slice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n])}return f}function hexSlice(e,r,t){var f=e.length;if(!r||r<0)r=0;if(!t||t<0||t>f)t=f;var n=\"\";for(var i=r;i<t;++i){n+=s[e[i]]}return n}function utf16leSlice(e,r,t){var f=e.slice(r,t);var n=\"\";for(var i=0;i<f.length;i+=2){n+=String.fromCharCode(f[i]+f[i+1]*256)}return n}Buffer.prototype.slice=function slice(e,r){var t=this.length;e=~~e;r=r===undefined?t:~~r;if(e<0){e+=t;if(e<0)e=0}else if(e>t){e=t}if(r<0){r+=t;if(r<0)r=0}else if(r>t){r=t}if(r<e)r=e;var f=this.subarray(e,r);Object.setPrototypeOf(f,Buffer.prototype);return f};function checkOffset(e,r,t){if(e%1!==0||e<0)throw new RangeError(\"offset is not uint\");if(e+r>t)throw new RangeError(\"Trying to access beyond buffer length\")}Buffer.prototype.readUIntLE=function readUIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}return f};Buffer.prototype.readUIntBE=function readUIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t){checkOffset(e,r,this.length)}var f=this[e+--r];var n=1;while(r>0&&(n*=256)){f+=this[e+--r]*n}return f};Buffer.prototype.readUInt8=function readUInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);return this[e]};Buffer.prototype.readUInt16LE=function readUInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]|this[e+1]<<8};Buffer.prototype.readUInt16BE=function readUInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]<<8|this[e+1]};Buffer.prototype.readUInt32LE=function readUInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return(this[e]|this[e+1]<<8|this[e+2]<<16)+this[e+3]*16777216};Buffer.prototype.readUInt32BE=function readUInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]*16777216+(this[e+1]<<16|this[e+2]<<8|this[e+3])};Buffer.prototype.readIntLE=function readIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}n*=128;if(f>=n)f-=Math.pow(2,8*r);return f};Buffer.prototype.readIntBE=function readIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=r;var n=1;var i=this[e+--f];while(f>0&&(n*=256)){i+=this[e+--f]*n}n*=128;if(i>=n)i-=Math.pow(2,8*r);return i};Buffer.prototype.readInt8=function readInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);if(!(this[e]&128))return this[e];return(255-this[e]+1)*-1};Buffer.prototype.readInt16LE=function readInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e]|this[e+1]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt16BE=function readInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e+1]|this[e]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt32LE=function readInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24};Buffer.prototype.readInt32BE=function readInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]};Buffer.prototype.readFloatLE=function readFloatLE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,true,23,4)};Buffer.prototype.readFloatBE=function readFloatBE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,false,23,4)};Buffer.prototype.readDoubleLE=function readDoubleLE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,true,52,8)};Buffer.prototype.readDoubleBE=function readDoubleBE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,false,52,8)};function checkInt(e,r,t,f,n,i){if(!Buffer.isBuffer(e))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(r>n||r<i)throw new RangeError('\"value\" argument is out of bounds');if(t+f>e.length)throw new RangeError(\"Index out of range\")}Buffer.prototype.writeUIntLE=function writeUIntLE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=1;var o=0;this[r]=e&255;while(++o<t&&(i*=256)){this[r+o]=e/i&255}return r+t};Buffer.prototype.writeUIntBE=function writeUIntBE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=t-1;var o=1;this[r+i]=e&255;while(--i>=0&&(o*=256)){this[r+i]=e/o&255}return r+t};Buffer.prototype.writeUInt8=function writeUInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,255,0);this[r]=e&255;return r+1};Buffer.prototype.writeUInt16LE=function writeUInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeUInt16BE=function writeUInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeUInt32LE=function writeUInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r+3]=e>>>24;this[r+2]=e>>>16;this[r+1]=e>>>8;this[r]=e&255;return r+4};Buffer.prototype.writeUInt32BE=function writeUInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};Buffer.prototype.writeIntLE=function writeIntLE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=0;var o=1;var u=0;this[r]=e&255;while(++i<t&&(o*=256)){if(e<0&&u===0&&this[r+i-1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeIntBE=function writeIntBE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=t-1;var o=1;var u=0;this[r+i]=e&255;while(--i>=0&&(o*=256)){if(e<0&&u===0&&this[r+i+1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeInt8=function writeInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,127,-128);if(e<0)e=255+e+1;this[r]=e&255;return r+1};Buffer.prototype.writeInt16LE=function writeInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeInt16BE=function writeInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeInt32LE=function writeInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);this[r]=e&255;this[r+1]=e>>>8;this[r+2]=e>>>16;this[r+3]=e>>>24;return r+4};Buffer.prototype.writeInt32BE=function writeInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);if(e<0)e=4294967295+e+1;this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};function checkIEEE754(e,r,t,f,n,i){if(t+f>e.length)throw new RangeError(\"Index out of range\");if(t<0)throw new RangeError(\"Index out of range\")}function writeFloat(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,4,34028234663852886e22,-34028234663852886e22)}n.write(e,r,t,f,23,4);return t+4}Buffer.prototype.writeFloatLE=function writeFloatLE(e,r,t){return writeFloat(this,e,r,true,t)};Buffer.prototype.writeFloatBE=function writeFloatBE(e,r,t){return writeFloat(this,e,r,false,t)};function writeDouble(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,8,17976931348623157e292,-17976931348623157e292)}n.write(e,r,t,f,52,8);return t+8}Buffer.prototype.writeDoubleLE=function writeDoubleLE(e,r,t){return writeDouble(this,e,r,true,t)};Buffer.prototype.writeDoubleBE=function writeDoubleBE(e,r,t){return writeDouble(this,e,r,false,t)};Buffer.prototype.copy=function copy(e,r,t,f){if(!Buffer.isBuffer(e))throw new TypeError(\"argument should be a Buffer\");if(!t)t=0;if(!f&&f!==0)f=this.length;if(r>=e.length)r=e.length;if(!r)r=0;if(f>0&&f<t)f=t;if(f===t)return 0;if(e.length===0||this.length===0)return 0;if(r<0){throw new RangeError(\"targetStart out of bounds\")}if(t<0||t>=this.length)throw new RangeError(\"Index out of range\");if(f<0)throw new RangeError(\"sourceEnd out of bounds\");if(f>this.length)f=this.length;if(e.length-r<f-t){f=e.length-r+t}var n=f-t;if(this===e&&typeof Uint8Array.prototype.copyWithin===\"function\"){this.copyWithin(r,t,f)}else if(this===e&&t<r&&r<f){for(var i=n-1;i>=0;--i){e[i+r]=this[i+t]}}else{Uint8Array.prototype.set.call(e,this.subarray(t,f),r)}return n};Buffer.prototype.fill=function fill(e,r,t,f){if(typeof e===\"string\"){if(typeof r===\"string\"){f=r;r=0;t=this.length}else if(typeof t===\"string\"){f=t;t=this.length}if(f!==undefined&&typeof f!==\"string\"){throw new TypeError(\"encoding must be a string\")}if(typeof f===\"string\"&&!Buffer.isEncoding(f)){throw new TypeError(\"Unknown encoding: \"+f)}if(e.length===1){var n=e.charCodeAt(0);if(f===\"utf8\"&&n<128||f===\"latin1\"){e=n}}}else if(typeof e===\"number\"){e=e&255}else if(typeof e===\"boolean\"){e=Number(e)}if(r<0||this.length<r||this.length<t){throw new RangeError(\"Out of range index\")}if(t<=r){return this}r=r>>>0;t=t===undefined?this.length:t>>>0;if(!e)e=0;var i;if(typeof e===\"number\"){for(i=r;i<t;++i){this[i]=e}}else{var o=Buffer.isBuffer(e)?e:Buffer.from(e,f);var u=o.length;if(u===0){throw new TypeError('The value \"'+e+'\" is invalid for argument \"value\"')}for(i=0;i<t-r;++i){this[i+r]=o[i%u]}}return this};var a=/[^+/0-9A-Za-z-_]/g;function base64clean(e){e=e.split(\"=\")[0];e=e.trim().replace(a,\"\");if(e.length<2)return\"\";while(e.length%4!==0){e=e+\"=\"}return e}function utf8ToBytes(e,r){r=r||Infinity;var t;var f=e.length;var n=null;var i=[];for(var o=0;o<f;++o){t=e.charCodeAt(o);if(t>55295&&t<57344){if(!n){if(t>56319){if((r-=3)>-1)i.push(239,191,189);continue}else if(o+1===f){if((r-=3)>-1)i.push(239,191,189);continue}n=t;continue}if(t<56320){if((r-=3)>-1)i.push(239,191,189);n=t;continue}t=(n-55296<<10|t-56320)+65536}else if(n){if((r-=3)>-1)i.push(239,191,189)}n=null;if(t<128){if((r-=1)<0)break;i.push(t)}else if(t<2048){if((r-=2)<0)break;i.push(t>>6|192,t&63|128)}else if(t<65536){if((r-=3)<0)break;i.push(t>>12|224,t>>6&63|128,t&63|128)}else if(t<1114112){if((r-=4)<0)break;i.push(t>>18|240,t>>12&63|128,t>>6&63|128,t&63|128)}else{throw new Error(\"Invalid code point\")}}return i}function asciiToBytes(e){var r=[];for(var t=0;t<e.length;++t){r.push(e.charCodeAt(t)&255)}return r}function utf16leToBytes(e,r){var t,f,n;var i=[];for(var o=0;o<e.length;++o){if((r-=2)<0)break;t=e.charCodeAt(o);f=t>>8;n=t%256;i.push(n);i.push(f)}return i}function base64ToBytes(e){return f.toByteArray(base64clean(e))}function blitBuffer(e,r,t,f){for(var n=0;n<f;++n){if(n+t>=r.length||n>=e.length)break;r[n+t]=e[n]}return n}function isInstance(e,r){return e instanceof r||e!=null&&e.constructor!=null&&e.constructor.name!=null&&e.constructor.name===r.name}function numberIsNaN(e){return e!==e}var s=function(){var e=\"0123456789abcdef\";var r=new Array(256);for(var t=0;t<16;++t){var f=t*16;for(var n=0;n<16;++n){r[f+n]=e[t]+e[n]}}return r}()},783:function(e,r){\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nr.read=function(e,r,t,f,n){var i,o;var u=n*8-f-1;var a=(1<<u)-1;var s=a>>1;var h=-7;var c=t?n-1:0;var l=t?-1:1;var p=e[r+c];c+=l;i=p&(1<<-h)-1;p>>=-h;h+=u;for(;h>0;i=i*256+e[r+c],c+=l,h-=8){}o=i&(1<<-h)-1;i>>=-h;h+=f;for(;h>0;o=o*256+e[r+c],c+=l,h-=8){}if(i===0){i=1-s}else if(i===a){return o?NaN:(p?-1:1)*Infinity}else{o=o+Math.pow(2,f);i=i-s}return(p?-1:1)*o*Math.pow(2,i-f)};r.write=function(e,r,t,f,n,i){var o,u,a;var s=i*8-n-1;var h=(1<<s)-1;var c=h>>1;var l=n===23?Math.pow(2,-24)-Math.pow(2,-77):0;var p=f?0:i-1;var y=f?1:-1;var g=r<0||r===0&&1/r<0?1:0;r=Math.abs(r);if(isNaN(r)||r===Infinity){u=isNaN(r)?1:0;o=h}else{o=Math.floor(Math.log(r)/Math.LN2);if(r*(a=Math.pow(2,-o))<1){o--;a*=2}if(o+c>=1){r+=l/a}else{r+=l*Math.pow(2,1-c)}if(r*a>=2){o++;a/=2}if(o+c>=h){u=0;o=h}else if(o+c>=1){u=(r*a-1)*Math.pow(2,n);o=o+c}else{u=r*Math.pow(2,c-1)*Math.pow(2,n);o=0}}for(;n>=8;e[t+p]=u&255,p+=y,u/=256,n-=8){}o=o<<n|u;s+=n;for(;s>0;e[t+p]=o&255,p+=y,o/=256,s-=8){}e[t+p-y]|=g*128}}};var r={};function __nccwpck_require__(t){var f=r[t];if(f!==undefined){return f.exports}var n=r[t]={exports:{}};var i=true;try{e[t](n,n.exports,__nccwpck_require__);i=false}finally{if(i)delete r[t]}return n.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(72);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sa0JBQWtCLGFBQWEsd0JBQXdCLDBCQUEwQiw4QkFBOEIsU0FBUyxTQUFTLHVEQUF1RCx5RUFBeUUsdUJBQXVCLElBQUksS0FBSyxVQUFVLHFCQUFxQix3QkFBd0Isd0JBQXdCLG9CQUFvQixlQUFlLFVBQVUsa0VBQWtFLHFCQUFxQixjQUFjLG9CQUFvQixZQUFZLHVCQUF1QixpQkFBaUIsV0FBVyxXQUFXLGtCQUFrQiw0QkFBNEIsa0JBQWtCLHdCQUF3QixNQUFNLGlCQUFpQixXQUFXLFdBQVcsZ0NBQWdDLFFBQVEsZ0JBQWdCLE1BQU0sUUFBUSxJQUFJLE1BQU0sK0ZBQStGLGlCQUFpQixnQkFBZ0IsYUFBYSxVQUFVLGdEQUFnRCxhQUFhLFVBQVUseUVBQXlFLGdCQUFnQixhQUFhLFNBQVMsNEJBQTRCLGtEQUFrRCw0QkFBNEIsTUFBTSxTQUFTLFlBQVksSUFBSSxNQUFNLHFEQUFxRCwyQkFBMkIsa0JBQWtCLDBCQUEwQixNQUFNLGVBQWUsVUFBVSxTQUFTLFlBQVksa0JBQWtCLElBQUksTUFBTSxxQ0FBcUMsVUFBVSxTQUFTLGdDQUFnQyxlQUFlLHFCQUFxQiwyQ0FBMkMsbUJBQW1CLG9CQUFvQjtBQUM5ckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLCtHQUErRyxnQkFBZ0Isd0JBQXdCLHVCQUF1QixpQkFBaUIsZUFBZSwrQ0FBK0MsaUdBQWlHLGtLQUFrSyw2QkFBNkIsSUFBSSx3QkFBd0IsT0FBTyxlQUFlLFlBQVksOENBQThDLDJCQUEyQixvQkFBb0IsU0FBUyxjQUFjLGlEQUFpRCwrQkFBK0IsMkNBQTJDLG9CQUFvQixFQUFFLGlEQUFpRCwrQkFBK0IsMkNBQTJDLHdCQUF3QixFQUFFLHlCQUF5QixRQUFRLHVFQUF1RSx3QkFBd0IsMENBQTBDLFNBQVMs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Q0FBK0MsY0FBYyxhQUFhLDRCQUE0QixjQUFjLDJCQUEyQixlQUFlLElBQUksS0FBSyxtQ0FBbUMsMkJBQTJCLElBQUksS0FBSyxXQUFXLE9BQU8sS0FBSyxxQkFBcUIsV0FBVyxJQUFJLEtBQUssV0FBVyxJQUFJLElBQUksZ0JBQWdCLHdCQUF3QixNQUFNLEtBQUssa0NBQWtDLEtBQUssS0FBSyxLQUFLLGdDQUFnQyxTQUFTLEtBQUssS0FBSyxJQUFJLGdDQUFnQyxtQkFBbUIsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssOEJBQThCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2J1ZmZlci9pbmRleC5qcz9jNDc3Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXs2NzU6ZnVuY3Rpb24oZSxyKXtcInVzZSBzdHJpY3RcIjtyLmJ5dGVMZW5ndGg9Ynl0ZUxlbmd0aDtyLnRvQnl0ZUFycmF5PXRvQnl0ZUFycmF5O3IuZnJvbUJ5dGVBcnJheT1mcm9tQnl0ZUFycmF5O3ZhciB0PVtdO3ZhciBmPVtdO3ZhciBuPXR5cGVvZiBVaW50OEFycmF5IT09XCJ1bmRlZmluZWRcIj9VaW50OEFycmF5OkFycmF5O3ZhciBpPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO2Zvcih2YXIgbz0wLHU9aS5sZW5ndGg7bzx1Oysrbyl7dFtvXT1pW29dO2ZbaS5jaGFyQ29kZUF0KG8pXT1vfWZbXCItXCIuY2hhckNvZGVBdCgwKV09NjI7ZltcIl9cIi5jaGFyQ29kZUF0KDApXT02MztmdW5jdGlvbiBnZXRMZW5zKGUpe3ZhciByPWUubGVuZ3RoO2lmKHIlND4wKXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0XCIpfXZhciB0PWUuaW5kZXhPZihcIj1cIik7aWYodD09PS0xKXQ9cjt2YXIgZj10PT09cj8wOjQtdCU0O3JldHVyblt0LGZdfWZ1bmN0aW9uIGJ5dGVMZW5ndGgoZSl7dmFyIHI9Z2V0TGVucyhlKTt2YXIgdD1yWzBdO3ZhciBmPXJbMV07cmV0dXJuKHQrZikqMy80LWZ9ZnVuY3Rpb24gX2J5dGVMZW5ndGgoZSxyLHQpe3JldHVybihyK3QpKjMvNC10fWZ1bmN0aW9uIHRvQnl0ZUFycmF5KGUpe3ZhciByO3ZhciB0PWdldExlbnMoZSk7dmFyIGk9dFswXTt2YXIgbz10WzFdO3ZhciB1PW5ldyBuKF9ieXRlTGVuZ3RoKGUsaSxvKSk7dmFyIGE9MDt2YXIgcz1vPjA/aS00Omk7dmFyIGg7Zm9yKGg9MDtoPHM7aCs9NCl7cj1mW2UuY2hhckNvZGVBdChoKV08PDE4fGZbZS5jaGFyQ29kZUF0KGgrMSldPDwxMnxmW2UuY2hhckNvZGVBdChoKzIpXTw8NnxmW2UuY2hhckNvZGVBdChoKzMpXTt1W2ErK109cj4+MTYmMjU1O3VbYSsrXT1yPj44JjI1NTt1W2ErK109ciYyNTV9aWYobz09PTIpe3I9ZltlLmNoYXJDb2RlQXQoaCldPDwyfGZbZS5jaGFyQ29kZUF0KGgrMSldPj40O3VbYSsrXT1yJjI1NX1pZihvPT09MSl7cj1mW2UuY2hhckNvZGVBdChoKV08PDEwfGZbZS5jaGFyQ29kZUF0KGgrMSldPDw0fGZbZS5jaGFyQ29kZUF0KGgrMildPj4yO3VbYSsrXT1yPj44JjI1NTt1W2ErK109ciYyNTV9cmV0dXJuIHV9ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0KGUpe3JldHVybiB0W2U+PjE4JjYzXSt0W2U+PjEyJjYzXSt0W2U+PjYmNjNdK3RbZSY2M119ZnVuY3Rpb24gZW5jb2RlQ2h1bmsoZSxyLHQpe3ZhciBmO3ZhciBuPVtdO2Zvcih2YXIgaT1yO2k8dDtpKz0zKXtmPShlW2ldPDwxNiYxNjcxMTY4MCkrKGVbaSsxXTw8OCY2NTI4MCkrKGVbaSsyXSYyNTUpO24ucHVzaCh0cmlwbGV0VG9CYXNlNjQoZikpfXJldHVybiBuLmpvaW4oXCJcIil9ZnVuY3Rpb24gZnJvbUJ5dGVBcnJheShlKXt2YXIgcjt2YXIgZj1lLmxlbmd0aDt2YXIgbj1mJTM7dmFyIGk9W107dmFyIG89MTYzODM7Zm9yKHZhciB1PTAsYT1mLW47dTxhO3UrPW8pe2kucHVzaChlbmNvZGVDaHVuayhlLHUsdStvPmE/YTp1K28pKX1pZihuPT09MSl7cj1lW2YtMV07aS5wdXNoKHRbcj4+Ml0rdFtyPDw0JjYzXStcIj09XCIpfWVsc2UgaWYobj09PTIpe3I9KGVbZi0yXTw8OCkrZVtmLTFdO2kucHVzaCh0W3I+PjEwXSt0W3I+PjQmNjNdK3Rbcjw8MiY2M10rXCI9XCIpfXJldHVybiBpLmpvaW4oXCJcIil9fSw3MjpmdW5jdGlvbihlLHIsdCl7XCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi92YXIgZj10KDY3NSk7dmFyIG49dCg3ODMpO3ZhciBpPXR5cGVvZiBTeW1ib2w9PT1cImZ1bmN0aW9uXCImJnR5cGVvZiBTeW1ib2wuZm9yPT09XCJmdW5jdGlvblwiP1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKTpudWxsO3IuQnVmZmVyPUJ1ZmZlcjtyLlNsb3dCdWZmZXI9U2xvd0J1ZmZlcjtyLklOU1BFQ1RfTUFYX0JZVEVTPTUwO3ZhciBvPTIxNDc0ODM2NDc7ci5rTWF4TGVuZ3RoPW87QnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQ9dHlwZWRBcnJheVN1cHBvcnQoKTtpZighQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQmJnR5cGVvZiBjb25zb2xlIT09XCJ1bmRlZmluZWRcIiYmdHlwZW9mIGNvbnNvbGUuZXJyb3I9PT1cImZ1bmN0aW9uXCIpe2NvbnNvbGUuZXJyb3IoXCJUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgXCIrXCJgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LlwiKX1mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCgpe3RyeXt2YXIgZT1uZXcgVWludDhBcnJheSgxKTt2YXIgcj17Zm9vOmZ1bmN0aW9uKCl7cmV0dXJuIDQyfX07T2JqZWN0LnNldFByb3RvdHlwZU9mKHIsVWludDhBcnJheS5wcm90b3R5cGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihlLHIpO3JldHVybiBlLmZvbygpPT09NDJ9Y2F0Y2goZSl7cmV0dXJuIGZhbHNlfX1PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSxcInBhcmVudFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7aWYoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLmJ1ZmZlcn19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSxcIm9mZnNldFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7aWYoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLmJ5dGVPZmZzZXR9fSk7ZnVuY3Rpb24gY3JlYXRlQnVmZmVyKGUpe2lmKGU+byl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicrZSsnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyl9dmFyIHI9bmV3IFVpbnQ4QXJyYXkoZSk7T2JqZWN0LnNldFByb3RvdHlwZU9mKHIsQnVmZmVyLnByb3RvdHlwZSk7cmV0dXJuIHJ9ZnVuY3Rpb24gQnVmZmVyKGUscix0KXtpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe2lmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKX1yZXR1cm4gYWxsb2NVbnNhZmUoZSl9cmV0dXJuIGZyb20oZSxyLHQpfUJ1ZmZlci5wb29sU2l6ZT04MTkyO2Z1bmN0aW9uIGZyb20oZSxyLHQpe2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcIil7cmV0dXJuIGZyb21TdHJpbmcoZSxyKX1pZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSkpe3JldHVybiBmcm9tQXJyYXlMaWtlKGUpfWlmKGU9PW51bGwpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBcIitcIm9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX1pZihpc0luc3RhbmNlKGUsQXJyYXlCdWZmZXIpfHxlJiZpc0luc3RhbmNlKGUuYnVmZmVyLEFycmF5QnVmZmVyKSl7cmV0dXJuIGZyb21BcnJheUJ1ZmZlcihlLHIsdCl9aWYodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyIT09XCJ1bmRlZmluZWRcIiYmKGlzSW5zdGFuY2UoZSxTaGFyZWRBcnJheUJ1ZmZlcil8fGUmJmlzSW5zdGFuY2UoZS5idWZmZXIsU2hhcmVkQXJyYXlCdWZmZXIpKSl7cmV0dXJuIGZyb21BcnJheUJ1ZmZlcihlLHIsdCl9aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcicpfXZhciBmPWUudmFsdWVPZiYmZS52YWx1ZU9mKCk7aWYoZiE9bnVsbCYmZiE9PWUpe3JldHVybiBCdWZmZXIuZnJvbShmLHIsdCl9dmFyIG49ZnJvbU9iamVjdChlKTtpZihuKXJldHVybiBuO2lmKHR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiJiZTeW1ib2wudG9QcmltaXRpdmUhPW51bGwmJnR5cGVvZiBlW1N5bWJvbC50b1ByaW1pdGl2ZV09PT1cImZ1bmN0aW9uXCIpe3JldHVybiBCdWZmZXIuZnJvbShlW1N5bWJvbC50b1ByaW1pdGl2ZV0oXCJzdHJpbmdcIikscix0KX10aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgXCIrXCJvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9QnVmZmVyLmZyb209ZnVuY3Rpb24oZSxyLHQpe3JldHVybiBmcm9tKGUscix0KX07T2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsVWludDhBcnJheS5wcm90b3R5cGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsVWludDhBcnJheSk7ZnVuY3Rpb24gYXNzZXJ0U2l6ZShlKXtpZih0eXBlb2YgZSE9PVwibnVtYmVyXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKX1lbHNlIGlmKGU8MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicrZSsnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyl9fWZ1bmN0aW9uIGFsbG9jKGUscix0KXthc3NlcnRTaXplKGUpO2lmKGU8PTApe3JldHVybiBjcmVhdGVCdWZmZXIoZSl9aWYociE9PXVuZGVmaW5lZCl7cmV0dXJuIHR5cGVvZiB0PT09XCJzdHJpbmdcIj9jcmVhdGVCdWZmZXIoZSkuZmlsbChyLHQpOmNyZWF0ZUJ1ZmZlcihlKS5maWxsKHIpfXJldHVybiBjcmVhdGVCdWZmZXIoZSl9QnVmZmVyLmFsbG9jPWZ1bmN0aW9uKGUscix0KXtyZXR1cm4gYWxsb2MoZSxyLHQpfTtmdW5jdGlvbiBhbGxvY1Vuc2FmZShlKXthc3NlcnRTaXplKGUpO3JldHVybiBjcmVhdGVCdWZmZXIoZTwwPzA6Y2hlY2tlZChlKXwwKX1CdWZmZXIuYWxsb2NVbnNhZmU9ZnVuY3Rpb24oZSl7cmV0dXJuIGFsbG9jVW5zYWZlKGUpfTtCdWZmZXIuYWxsb2NVbnNhZmVTbG93PWZ1bmN0aW9uKGUpe3JldHVybiBhbGxvY1Vuc2FmZShlKX07ZnVuY3Rpb24gZnJvbVN0cmluZyhlLHIpe2lmKHR5cGVvZiByIT09XCJzdHJpbmdcInx8cj09PVwiXCIpe3I9XCJ1dGY4XCJ9aWYoIUJ1ZmZlci5pc0VuY29kaW5nKHIpKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrcil9dmFyIHQ9Ynl0ZUxlbmd0aChlLHIpfDA7dmFyIGY9Y3JlYXRlQnVmZmVyKHQpO3ZhciBuPWYud3JpdGUoZSxyKTtpZihuIT09dCl7Zj1mLnNsaWNlKDAsbil9cmV0dXJuIGZ9ZnVuY3Rpb24gZnJvbUFycmF5TGlrZShlKXt2YXIgcj1lLmxlbmd0aDwwPzA6Y2hlY2tlZChlLmxlbmd0aCl8MDt2YXIgdD1jcmVhdGVCdWZmZXIocik7Zm9yKHZhciBmPTA7ZjxyO2YrPTEpe3RbZl09ZVtmXSYyNTV9cmV0dXJuIHR9ZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyKGUscix0KXtpZihyPDB8fGUuYnl0ZUxlbmd0aDxyKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKX1pZihlLmJ5dGVMZW5ndGg8cisodHx8MCkpe3Rocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpfXZhciBmO2lmKHI9PT11bmRlZmluZWQmJnQ9PT11bmRlZmluZWQpe2Y9bmV3IFVpbnQ4QXJyYXkoZSl9ZWxzZSBpZih0PT09dW5kZWZpbmVkKXtmPW5ldyBVaW50OEFycmF5KGUscil9ZWxzZXtmPW5ldyBVaW50OEFycmF5KGUscix0KX1PYmplY3Quc2V0UHJvdG90eXBlT2YoZixCdWZmZXIucHJvdG90eXBlKTtyZXR1cm4gZn1mdW5jdGlvbiBmcm9tT2JqZWN0KGUpe2lmKEJ1ZmZlci5pc0J1ZmZlcihlKSl7dmFyIHI9Y2hlY2tlZChlLmxlbmd0aCl8MDt2YXIgdD1jcmVhdGVCdWZmZXIocik7aWYodC5sZW5ndGg9PT0wKXtyZXR1cm4gdH1lLmNvcHkodCwwLDAscik7cmV0dXJuIHR9aWYoZS5sZW5ndGghPT11bmRlZmluZWQpe2lmKHR5cGVvZiBlLmxlbmd0aCE9PVwibnVtYmVyXCJ8fG51bWJlcklzTmFOKGUubGVuZ3RoKSl7cmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKX1yZXR1cm4gZnJvbUFycmF5TGlrZShlKX1pZihlLnR5cGU9PT1cIkJ1ZmZlclwiJiZBcnJheS5pc0FycmF5KGUuZGF0YSkpe3JldHVybiBmcm9tQXJyYXlMaWtlKGUuZGF0YSl9fWZ1bmN0aW9uIGNoZWNrZWQoZSl7aWYoZT49byl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtIFwiK1wic2l6ZTogMHhcIitvLnRvU3RyaW5nKDE2KStcIiBieXRlc1wiKX1yZXR1cm4gZXwwfWZ1bmN0aW9uIFNsb3dCdWZmZXIoZSl7aWYoK2UhPWUpe2U9MH1yZXR1cm4gQnVmZmVyLmFsbG9jKCtlKX1CdWZmZXIuaXNCdWZmZXI9ZnVuY3Rpb24gaXNCdWZmZXIoZSl7cmV0dXJuIGUhPW51bGwmJmUuX2lzQnVmZmVyPT09dHJ1ZSYmZSE9PUJ1ZmZlci5wcm90b3R5cGV9O0J1ZmZlci5jb21wYXJlPWZ1bmN0aW9uIGNvbXBhcmUoZSxyKXtpZihpc0luc3RhbmNlKGUsVWludDhBcnJheSkpZT1CdWZmZXIuZnJvbShlLGUub2Zmc2V0LGUuYnl0ZUxlbmd0aCk7aWYoaXNJbnN0YW5jZShyLFVpbnQ4QXJyYXkpKXI9QnVmZmVyLmZyb20ocixyLm9mZnNldCxyLmJ5dGVMZW5ndGgpO2lmKCFCdWZmZXIuaXNCdWZmZXIoZSl8fCFCdWZmZXIuaXNCdWZmZXIocikpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknKX1pZihlPT09cilyZXR1cm4gMDt2YXIgdD1lLmxlbmd0aDt2YXIgZj1yLmxlbmd0aDtmb3IodmFyIG49MCxpPU1hdGgubWluKHQsZik7bjxpOysrbil7aWYoZVtuXSE9PXJbbl0pe3Q9ZVtuXTtmPXJbbl07YnJlYWt9fWlmKHQ8ZilyZXR1cm4tMTtpZihmPHQpcmV0dXJuIDE7cmV0dXJuIDB9O0J1ZmZlci5pc0VuY29kaW5nPWZ1bmN0aW9uIGlzRW5jb2RpbmcoZSl7c3dpdGNoKFN0cmluZyhlKS50b0xvd2VyQ2FzZSgpKXtjYXNlXCJoZXhcIjpjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOmNhc2VcImJhc2U2NFwiOmNhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB0cnVlO2RlZmF1bHQ6cmV0dXJuIGZhbHNlfX07QnVmZmVyLmNvbmNhdD1mdW5jdGlvbiBjb25jYXQoZSxyKXtpZighQXJyYXkuaXNBcnJheShlKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyl9aWYoZS5sZW5ndGg9PT0wKXtyZXR1cm4gQnVmZmVyLmFsbG9jKDApfXZhciB0O2lmKHI9PT11bmRlZmluZWQpe3I9MDtmb3IodD0wO3Q8ZS5sZW5ndGg7Kyt0KXtyKz1lW3RdLmxlbmd0aH19dmFyIGY9QnVmZmVyLmFsbG9jVW5zYWZlKHIpO3ZhciBuPTA7Zm9yKHQ9MDt0PGUubGVuZ3RoOysrdCl7dmFyIGk9ZVt0XTtpZihpc0luc3RhbmNlKGksVWludDhBcnJheSkpe2k9QnVmZmVyLmZyb20oaSl9aWYoIUJ1ZmZlci5pc0J1ZmZlcihpKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyl9aS5jb3B5KGYsbik7bis9aS5sZW5ndGh9cmV0dXJuIGZ9O2Z1bmN0aW9uIGJ5dGVMZW5ndGgoZSxyKXtpZihCdWZmZXIuaXNCdWZmZXIoZSkpe3JldHVybiBlLmxlbmd0aH1pZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSl8fGlzSW5zdGFuY2UoZSxBcnJheUJ1ZmZlcikpe3JldHVybiBlLmJ5dGVMZW5ndGh9aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJytcIlJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfXZhciB0PWUubGVuZ3RoO3ZhciBmPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdPT09dHJ1ZTtpZighZiYmdD09PTApcmV0dXJuIDA7dmFyIG49ZmFsc2U7Zm9yKDs7KXtzd2l0Y2gocil7Y2FzZVwiYXNjaWlcIjpjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gdDtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gdXRmOFRvQnl0ZXMoZSkubGVuZ3RoO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB0KjI7Y2FzZVwiaGV4XCI6cmV0dXJuIHQ+Pj4xO2Nhc2VcImJhc2U2NFwiOnJldHVybiBiYXNlNjRUb0J5dGVzKGUpLmxlbmd0aDtkZWZhdWx0OmlmKG4pe3JldHVybiBmPy0xOnV0ZjhUb0J5dGVzKGUpLmxlbmd0aH1yPShcIlwiK3IpLnRvTG93ZXJDYXNlKCk7bj10cnVlfX19QnVmZmVyLmJ5dGVMZW5ndGg9Ynl0ZUxlbmd0aDtmdW5jdGlvbiBzbG93VG9TdHJpbmcoZSxyLHQpe3ZhciBmPWZhbHNlO2lmKHI9PT11bmRlZmluZWR8fHI8MCl7cj0wfWlmKHI+dGhpcy5sZW5ndGgpe3JldHVyblwiXCJ9aWYodD09PXVuZGVmaW5lZHx8dD50aGlzLmxlbmd0aCl7dD10aGlzLmxlbmd0aH1pZih0PD0wKXtyZXR1cm5cIlwifXQ+Pj49MDtyPj4+PTA7aWYodDw9cil7cmV0dXJuXCJcIn1pZighZSllPVwidXRmOFwiO3doaWxlKHRydWUpe3N3aXRjaChlKXtjYXNlXCJoZXhcIjpyZXR1cm4gaGV4U2xpY2UodGhpcyxyLHQpO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiB1dGY4U2xpY2UodGhpcyxyLHQpO2Nhc2VcImFzY2lpXCI6cmV0dXJuIGFzY2lpU2xpY2UodGhpcyxyLHQpO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBsYXRpbjFTbGljZSh0aGlzLHIsdCk7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMscix0KTtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMscix0KTtkZWZhdWx0OmlmKGYpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2UpO2U9KGUrXCJcIikudG9Mb3dlckNhc2UoKTtmPXRydWV9fX1CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlcj10cnVlO2Z1bmN0aW9uIHN3YXAoZSxyLHQpe3ZhciBmPWVbcl07ZVtyXT1lW3RdO2VbdF09Zn1CdWZmZXIucHJvdG90eXBlLnN3YXAxNj1mdW5jdGlvbiBzd2FwMTYoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTIhPT0wKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzXCIpfWZvcih2YXIgcj0wO3I8ZTtyKz0yKXtzd2FwKHRoaXMscixyKzEpfXJldHVybiB0aGlzfTtCdWZmZXIucHJvdG90eXBlLnN3YXAzMj1mdW5jdGlvbiBzd2FwMzIoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTQhPT0wKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzXCIpfWZvcih2YXIgcj0wO3I8ZTtyKz00KXtzd2FwKHRoaXMscixyKzMpO3N3YXAodGhpcyxyKzEscisyKX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS5zd2FwNjQ9ZnVuY3Rpb24gc3dhcDY0KCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZSU4IT09MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0c1wiKX1mb3IodmFyIHI9MDtyPGU7cis9OCl7c3dhcCh0aGlzLHIscis3KTtzd2FwKHRoaXMscisxLHIrNik7c3dhcCh0aGlzLHIrMixyKzUpO3N3YXAodGhpcyxyKzMscis0KX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbiB0b1N0cmluZygpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGU9PT0wKXJldHVyblwiXCI7aWYoYXJndW1lbnRzLmxlbmd0aD09PTApcmV0dXJuIHV0ZjhTbGljZSh0aGlzLDAsZSk7cmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O0J1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmc9QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZztCdWZmZXIucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbiBlcXVhbHMoZSl7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtpZih0aGlzPT09ZSlyZXR1cm4gdHJ1ZTtyZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcyxlKT09PTB9O0J1ZmZlci5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbiBpbnNwZWN0KCl7dmFyIGU9XCJcIjt2YXIgdD1yLklOU1BFQ1RfTUFYX0JZVEVTO2U9dGhpcy50b1N0cmluZyhcImhleFwiLDAsdCkucmVwbGFjZSgvKC57Mn0pL2csXCIkMSBcIikudHJpbSgpO2lmKHRoaXMubGVuZ3RoPnQpZSs9XCIgLi4uIFwiO3JldHVyblwiPEJ1ZmZlciBcIitlK1wiPlwifTtpZihpKXtCdWZmZXIucHJvdG90eXBlW2ldPUJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdH1CdWZmZXIucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24gY29tcGFyZShlLHIsdCxmLG4pe2lmKGlzSW5zdGFuY2UoZSxVaW50OEFycmF5KSl7ZT1CdWZmZXIuZnJvbShlLGUub2Zmc2V0LGUuYnl0ZUxlbmd0aCl9aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJytcIlJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfWlmKHI9PT11bmRlZmluZWQpe3I9MH1pZih0PT09dW5kZWZpbmVkKXt0PWU/ZS5sZW5ndGg6MH1pZihmPT09dW5kZWZpbmVkKXtmPTB9aWYobj09PXVuZGVmaW5lZCl7bj10aGlzLmxlbmd0aH1pZihyPDB8fHQ+ZS5sZW5ndGh8fGY8MHx8bj50aGlzLmxlbmd0aCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmFuZ2UgaW5kZXhcIil9aWYoZj49biYmcj49dCl7cmV0dXJuIDB9aWYoZj49bil7cmV0dXJuLTF9aWYocj49dCl7cmV0dXJuIDF9cj4+Pj0wO3Q+Pj49MDtmPj4+PTA7bj4+Pj0wO2lmKHRoaXM9PT1lKXJldHVybiAwO3ZhciBpPW4tZjt2YXIgbz10LXI7dmFyIHU9TWF0aC5taW4oaSxvKTt2YXIgYT10aGlzLnNsaWNlKGYsbik7dmFyIHM9ZS5zbGljZShyLHQpO2Zvcih2YXIgaD0wO2g8dTsrK2gpe2lmKGFbaF0hPT1zW2hdKXtpPWFbaF07bz1zW2hdO2JyZWFrfX1pZihpPG8pcmV0dXJuLTE7aWYobzxpKXJldHVybiAxO3JldHVybiAwfTtmdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZihlLHIsdCxmLG4pe2lmKGUubGVuZ3RoPT09MClyZXR1cm4tMTtpZih0eXBlb2YgdD09PVwic3RyaW5nXCIpe2Y9dDt0PTB9ZWxzZSBpZih0PjIxNDc0ODM2NDcpe3Q9MjE0NzQ4MzY0N31lbHNlIGlmKHQ8LTIxNDc0ODM2NDgpe3Q9LTIxNDc0ODM2NDh9dD0rdDtpZihudW1iZXJJc05hTih0KSl7dD1uPzA6ZS5sZW5ndGgtMX1pZih0PDApdD1lLmxlbmd0aCt0O2lmKHQ+PWUubGVuZ3RoKXtpZihuKXJldHVybi0xO2Vsc2UgdD1lLmxlbmd0aC0xfWVsc2UgaWYodDwwKXtpZihuKXQ9MDtlbHNlIHJldHVybi0xfWlmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7cj1CdWZmZXIuZnJvbShyLGYpfWlmKEJ1ZmZlci5pc0J1ZmZlcihyKSl7aWYoci5sZW5ndGg9PT0wKXtyZXR1cm4tMX1yZXR1cm4gYXJyYXlJbmRleE9mKGUscix0LGYsbil9ZWxzZSBpZih0eXBlb2Ygcj09PVwibnVtYmVyXCIpe3I9ciYyNTU7aWYodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2Y9PT1cImZ1bmN0aW9uXCIpe2lmKG4pe3JldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoZSxyLHQpfWVsc2V7cmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoZSxyLHQpfX1yZXR1cm4gYXJyYXlJbmRleE9mKGUsW3JdLHQsZixuKX10aHJvdyBuZXcgVHlwZUVycm9yKFwidmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyXCIpfWZ1bmN0aW9uIGFycmF5SW5kZXhPZihlLHIsdCxmLG4pe3ZhciBpPTE7dmFyIG89ZS5sZW5ndGg7dmFyIHU9ci5sZW5ndGg7aWYoZiE9PXVuZGVmaW5lZCl7Zj1TdHJpbmcoZikudG9Mb3dlckNhc2UoKTtpZihmPT09XCJ1Y3MyXCJ8fGY9PT1cInVjcy0yXCJ8fGY9PT1cInV0ZjE2bGVcInx8Zj09PVwidXRmLTE2bGVcIil7aWYoZS5sZW5ndGg8Mnx8ci5sZW5ndGg8Mil7cmV0dXJuLTF9aT0yO28vPTI7dS89Mjt0Lz0yfX1mdW5jdGlvbiByZWFkKGUscil7aWYoaT09PTEpe3JldHVybiBlW3JdfWVsc2V7cmV0dXJuIGUucmVhZFVJbnQxNkJFKHIqaSl9fXZhciBhO2lmKG4pe3ZhciBzPS0xO2ZvcihhPXQ7YTxvO2ErKyl7aWYocmVhZChlLGEpPT09cmVhZChyLHM9PT0tMT8wOmEtcykpe2lmKHM9PT0tMSlzPWE7aWYoYS1zKzE9PT11KXJldHVybiBzKml9ZWxzZXtpZihzIT09LTEpYS09YS1zO3M9LTF9fX1lbHNle2lmKHQrdT5vKXQ9by11O2ZvcihhPXQ7YT49MDthLS0pe3ZhciBoPXRydWU7Zm9yKHZhciBjPTA7Yzx1O2MrKyl7aWYocmVhZChlLGErYykhPT1yZWFkKHIsYykpe2g9ZmFsc2U7YnJlYWt9fWlmKGgpcmV0dXJuIGF9fXJldHVybi0xfUJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXM9ZnVuY3Rpb24gaW5jbHVkZXMoZSxyLHQpe3JldHVybiB0aGlzLmluZGV4T2YoZSxyLHQpIT09LTF9O0J1ZmZlci5wcm90b3R5cGUuaW5kZXhPZj1mdW5jdGlvbiBpbmRleE9mKGUscix0KXtyZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcyxlLHIsdCx0cnVlKX07QnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZj1mdW5jdGlvbiBsYXN0SW5kZXhPZihlLHIsdCl7cmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsZSxyLHQsZmFsc2UpfTtmdW5jdGlvbiBoZXhXcml0ZShlLHIsdCxmKXt0PU51bWJlcih0KXx8MDt2YXIgbj1lLmxlbmd0aC10O2lmKCFmKXtmPW59ZWxzZXtmPU51bWJlcihmKTtpZihmPm4pe2Y9bn19dmFyIGk9ci5sZW5ndGg7aWYoZj5pLzIpe2Y9aS8yfWZvcih2YXIgbz0wO288ZjsrK28pe3ZhciB1PXBhcnNlSW50KHIuc3Vic3RyKG8qMiwyKSwxNik7aWYobnVtYmVySXNOYU4odSkpcmV0dXJuIG87ZVt0K29dPXV9cmV0dXJuIG99ZnVuY3Rpb24gdXRmOFdyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHIsZS5sZW5ndGgtdCksZSx0LGYpfWZ1bmN0aW9uIGFzY2lpV3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHIpLGUsdCxmKX1mdW5jdGlvbiBsYXRpbjFXcml0ZShlLHIsdCxmKXtyZXR1cm4gYXNjaWlXcml0ZShlLHIsdCxmKX1mdW5jdGlvbiBiYXNlNjRXcml0ZShlLHIsdCxmKXtyZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHIpLGUsdCxmKX1mdW5jdGlvbiB1Y3MyV3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMocixlLmxlbmd0aC10KSxlLHQsZil9QnVmZmVyLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbiB3cml0ZShlLHIsdCxmKXtpZihyPT09dW5kZWZpbmVkKXtmPVwidXRmOFwiO3Q9dGhpcy5sZW5ndGg7cj0wfWVsc2UgaWYodD09PXVuZGVmaW5lZCYmdHlwZW9mIHI9PT1cInN0cmluZ1wiKXtmPXI7dD10aGlzLmxlbmd0aDtyPTB9ZWxzZSBpZihpc0Zpbml0ZShyKSl7cj1yPj4+MDtpZihpc0Zpbml0ZSh0KSl7dD10Pj4+MDtpZihmPT09dW5kZWZpbmVkKWY9XCJ1dGY4XCJ9ZWxzZXtmPXQ7dD11bmRlZmluZWR9fWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWRcIil9dmFyIG49dGhpcy5sZW5ndGgtcjtpZih0PT09dW5kZWZpbmVkfHx0Pm4pdD1uO2lmKGUubGVuZ3RoPjAmJih0PDB8fHI8MCl8fHI+dGhpcy5sZW5ndGgpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHNcIil9aWYoIWYpZj1cInV0ZjhcIjt2YXIgaT1mYWxzZTtmb3IoOzspe3N3aXRjaChmKXtjYXNlXCJoZXhcIjpyZXR1cm4gaGV4V3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIHV0ZjhXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJhc2NpaVwiOnJldHVybiBhc2NpaVdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBsYXRpbjFXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gYmFzZTY0V3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHVjczJXcml0ZSh0aGlzLGUscix0KTtkZWZhdWx0OmlmKGkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2YpO2Y9KFwiXCIrZikudG9Mb3dlckNhc2UoKTtpPXRydWV9fX07QnVmZmVyLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24gdG9KU09OKCl7cmV0dXJue3R5cGU6XCJCdWZmZXJcIixkYXRhOkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2Fycnx8dGhpcywwKX19O2Z1bmN0aW9uIGJhc2U2NFNsaWNlKGUscix0KXtpZihyPT09MCYmdD09PWUubGVuZ3RoKXtyZXR1cm4gZi5mcm9tQnl0ZUFycmF5KGUpfWVsc2V7cmV0dXJuIGYuZnJvbUJ5dGVBcnJheShlLnNsaWNlKHIsdCkpfX1mdW5jdGlvbiB1dGY4U2xpY2UoZSxyLHQpe3Q9TWF0aC5taW4oZS5sZW5ndGgsdCk7dmFyIGY9W107dmFyIG49cjt3aGlsZShuPHQpe3ZhciBpPWVbbl07dmFyIG89bnVsbDt2YXIgdT1pPjIzOT80Omk+MjIzPzM6aT4xOTE/MjoxO2lmKG4rdTw9dCl7dmFyIGEscyxoLGM7c3dpdGNoKHUpe2Nhc2UgMTppZihpPDEyOCl7bz1pfWJyZWFrO2Nhc2UgMjphPWVbbisxXTtpZigoYSYxOTIpPT09MTI4KXtjPShpJjMxKTw8NnxhJjYzO2lmKGM+MTI3KXtvPWN9fWJyZWFrO2Nhc2UgMzphPWVbbisxXTtzPWVbbisyXTtpZigoYSYxOTIpPT09MTI4JiYocyYxOTIpPT09MTI4KXtjPShpJjE1KTw8MTJ8KGEmNjMpPDw2fHMmNjM7aWYoYz4yMDQ3JiYoYzw1NTI5Nnx8Yz41NzM0Mykpe289Y319YnJlYWs7Y2FzZSA0OmE9ZVtuKzFdO3M9ZVtuKzJdO2g9ZVtuKzNdO2lmKChhJjE5Mik9PT0xMjgmJihzJjE5Mik9PT0xMjgmJihoJjE5Mik9PT0xMjgpe2M9KGkmMTUpPDwxOHwoYSY2Myk8PDEyfChzJjYzKTw8NnxoJjYzO2lmKGM+NjU1MzUmJmM8MTExNDExMil7bz1jfX19fWlmKG89PT1udWxsKXtvPTY1NTMzO3U9MX1lbHNlIGlmKG8+NjU1MzUpe28tPTY1NTM2O2YucHVzaChvPj4+MTAmMTAyM3w1NTI5Nik7bz01NjMyMHxvJjEwMjN9Zi5wdXNoKG8pO24rPXV9cmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShmKX12YXIgdT00MDk2O2Z1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheShlKXt2YXIgcj1lLmxlbmd0aDtpZihyPD11KXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZSl9dmFyIHQ9XCJcIjt2YXIgZj0wO3doaWxlKGY8cil7dCs9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZS5zbGljZShmLGYrPXUpKX1yZXR1cm4gdH1mdW5jdGlvbiBhc2NpaVNsaWNlKGUscix0KXt2YXIgZj1cIlwiO3Q9TWF0aC5taW4oZS5sZW5ndGgsdCk7Zm9yKHZhciBuPXI7bjx0Oysrbil7Zis9U3RyaW5nLmZyb21DaGFyQ29kZShlW25dJjEyNyl9cmV0dXJuIGZ9ZnVuY3Rpb24gbGF0aW4xU2xpY2UoZSxyLHQpe3ZhciBmPVwiXCI7dD1NYXRoLm1pbihlLmxlbmd0aCx0KTtmb3IodmFyIG49cjtuPHQ7KytuKXtmKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGVbbl0pfXJldHVybiBmfWZ1bmN0aW9uIGhleFNsaWNlKGUscix0KXt2YXIgZj1lLmxlbmd0aDtpZighcnx8cjwwKXI9MDtpZighdHx8dDwwfHx0PmYpdD1mO3ZhciBuPVwiXCI7Zm9yKHZhciBpPXI7aTx0OysraSl7bis9c1tlW2ldXX1yZXR1cm4gbn1mdW5jdGlvbiB1dGYxNmxlU2xpY2UoZSxyLHQpe3ZhciBmPWUuc2xpY2Uocix0KTt2YXIgbj1cIlwiO2Zvcih2YXIgaT0wO2k8Zi5sZW5ndGg7aSs9Mil7bis9U3RyaW5nLmZyb21DaGFyQ29kZShmW2ldK2ZbaSsxXSoyNTYpfXJldHVybiBufUJ1ZmZlci5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24gc2xpY2UoZSxyKXt2YXIgdD10aGlzLmxlbmd0aDtlPX5+ZTtyPXI9PT11bmRlZmluZWQ/dDp+fnI7aWYoZTwwKXtlKz10O2lmKGU8MCllPTB9ZWxzZSBpZihlPnQpe2U9dH1pZihyPDApe3IrPXQ7aWYocjwwKXI9MH1lbHNlIGlmKHI+dCl7cj10fWlmKHI8ZSlyPWU7dmFyIGY9dGhpcy5zdWJhcnJheShlLHIpO09iamVjdC5zZXRQcm90b3R5cGVPZihmLEJ1ZmZlci5wcm90b3R5cGUpO3JldHVybiBmfTtmdW5jdGlvbiBjaGVja09mZnNldChlLHIsdCl7aWYoZSUxIT09MHx8ZTwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwib2Zmc2V0IGlzIG5vdCB1aW50XCIpO2lmKGUrcj50KXRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKX1CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEU9ZnVuY3Rpb24gcmVhZFVJbnRMRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KWNoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCk7dmFyIGY9dGhpc1tlXTt2YXIgbj0xO3ZhciBpPTA7d2hpbGUoKytpPHImJihuKj0yNTYpKXtmKz10aGlzW2UraV0qbn1yZXR1cm4gZn07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFPWZ1bmN0aW9uIHJlYWRVSW50QkUoZSxyLHQpe2U9ZT4+PjA7cj1yPj4+MDtpZighdCl7Y2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKX12YXIgZj10aGlzW2UrLS1yXTt2YXIgbj0xO3doaWxlKHI+MCYmKG4qPTI1Nikpe2YrPXRoaXNbZSstLXJdKm59cmV0dXJuIGZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4PWZ1bmN0aW9uIHJlYWRVSW50OChlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwxLHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEU9ZnVuY3Rpb24gcmVhZFVJbnQxNkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdfHRoaXNbZSsxXTw8OH07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkU9ZnVuY3Rpb24gcmVhZFVJbnQxNkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdPDw4fHRoaXNbZSsxXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEU9ZnVuY3Rpb24gcmVhZFVJbnQzMkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybih0aGlzW2VdfHRoaXNbZSsxXTw8OHx0aGlzW2UrMl08PDE2KSt0aGlzW2UrM10qMTY3NzcyMTZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFPWZ1bmN0aW9uIHJlYWRVSW50MzJCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXSoxNjc3NzIxNisodGhpc1tlKzFdPDwxNnx0aGlzW2UrMl08PDh8dGhpc1tlKzNdKX07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEU9ZnVuY3Rpb24gcmVhZEludExFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpY2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKTt2YXIgZj10aGlzW2VdO3ZhciBuPTE7dmFyIGk9MDt3aGlsZSgrK2k8ciYmKG4qPTI1Nikpe2YrPXRoaXNbZStpXSpufW4qPTEyODtpZihmPj1uKWYtPU1hdGgucG93KDIsOCpyKTtyZXR1cm4gZn07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkU9ZnVuY3Rpb24gcmVhZEludEJFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpY2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKTt2YXIgZj1yO3ZhciBuPTE7dmFyIGk9dGhpc1tlKy0tZl07d2hpbGUoZj4wJiYobio9MjU2KSl7aSs9dGhpc1tlKy0tZl0qbn1uKj0xMjg7aWYoaT49bilpLT1NYXRoLnBvdygyLDgqcik7cmV0dXJuIGl9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24gcmVhZEludDgoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMSx0aGlzLmxlbmd0aCk7aWYoISh0aGlzW2VdJjEyOCkpcmV0dXJuIHRoaXNbZV07cmV0dXJuKDI1NS10aGlzW2VdKzEpKi0xfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFPWZ1bmN0aW9uIHJlYWRJbnQxNkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3ZhciB0PXRoaXNbZV18dGhpc1tlKzFdPDw4O3JldHVybiB0JjMyNzY4P3R8NDI5NDkwMTc2MDp0fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFPWZ1bmN0aW9uIHJlYWRJbnQxNkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3ZhciB0PXRoaXNbZSsxXXx0aGlzW2VdPDw4O3JldHVybiB0JjMyNzY4P3R8NDI5NDkwMTc2MDp0fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFPWZ1bmN0aW9uIHJlYWRJbnQzMkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdfHRoaXNbZSsxXTw8OHx0aGlzW2UrMl08PDE2fHRoaXNbZSszXTw8MjR9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkU9ZnVuY3Rpb24gcmVhZEludDMyQkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV08PDI0fHRoaXNbZSsxXTw8MTZ8dGhpc1tlKzJdPDw4fHRoaXNbZSszXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRT1mdW5jdGlvbiByZWFkRmxvYXRMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSx0cnVlLDIzLDQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFPWZ1bmN0aW9uIHJlYWRGbG9hdEJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLGZhbHNlLDIzLDQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRT1mdW5jdGlvbiByZWFkRG91YmxlTEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsOCx0aGlzLmxlbmd0aCk7cmV0dXJuIG4ucmVhZCh0aGlzLGUsdHJ1ZSw1Miw4KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkU9ZnVuY3Rpb24gcmVhZERvdWJsZUJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDgsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLGZhbHNlLDUyLDgpfTtmdW5jdGlvbiBjaGVja0ludChlLHIsdCxmLG4saSl7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTtpZihyPm58fHI8aSl0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKTtpZih0K2Y+ZS5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRT1mdW5jdGlvbiB3cml0ZVVJbnRMRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7dD10Pj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQpLTE7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLDApfXZhciBpPTE7dmFyIG89MDt0aGlzW3JdPWUmMjU1O3doaWxlKCsrbzx0JiYoaSo9MjU2KSl7dGhpc1tyK29dPWUvaSYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRT1mdW5jdGlvbiB3cml0ZVVJbnRCRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7dD10Pj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQpLTE7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLDApfXZhciBpPXQtMTt2YXIgbz0xO3RoaXNbcitpXT1lJjI1NTt3aGlsZSgtLWk+PTAmJihvKj0yNTYpKXt0aGlzW3IraV09ZS9vJjI1NX1yZXR1cm4gcit0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDg9ZnVuY3Rpb24gd3JpdGVVSW50OChlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDEsMjU1LDApO3RoaXNbcl09ZSYyNTU7cmV0dXJuIHIrMX07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFPWZ1bmN0aW9uIHdyaXRlVUludDE2TEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDY1NTM1LDApO3RoaXNbcl09ZSYyNTU7dGhpc1tyKzFdPWU+Pj44O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRT1mdW5jdGlvbiB3cml0ZVVJbnQxNkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiw2NTUzNSwwKTt0aGlzW3JdPWU+Pj44O3RoaXNbcisxXT1lJjI1NTtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEU9ZnVuY3Rpb24gd3JpdGVVSW50MzJMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsNDI5NDk2NzI5NSwwKTt0aGlzW3IrM109ZT4+PjI0O3RoaXNbcisyXT1lPj4+MTY7dGhpc1tyKzFdPWU+Pj44O3RoaXNbcl09ZSYyNTU7cmV0dXJuIHIrNH07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFPWZ1bmN0aW9uIHdyaXRlVUludDMyQkUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDQyOTQ5NjcyOTUsMCk7dGhpc1tyXT1lPj4+MjQ7dGhpc1tyKzFdPWU+Pj4xNjt0aGlzW3IrMl09ZT4+Pjg7dGhpc1tyKzNdPWUmMjU1O3JldHVybiByKzR9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRT1mdW5jdGlvbiB3cml0ZUludExFKGUscix0LGYpe2U9K2U7cj1yPj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQtMSk7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLTEsLW4pfXZhciBpPTA7dmFyIG89MTt2YXIgdT0wO3RoaXNbcl09ZSYyNTU7d2hpbGUoKytpPHQmJihvKj0yNTYpKXtpZihlPDAmJnU9PT0wJiZ0aGlzW3IraS0xXSE9PTApe3U9MX10aGlzW3IraV09KGUvbz4+MCktdSYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFPWZ1bmN0aW9uIHdyaXRlSW50QkUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO2lmKCFmKXt2YXIgbj1NYXRoLnBvdygyLDgqdC0xKTtjaGVja0ludCh0aGlzLGUscix0LG4tMSwtbil9dmFyIGk9dC0xO3ZhciBvPTE7dmFyIHU9MDt0aGlzW3IraV09ZSYyNTU7d2hpbGUoLS1pPj0wJiYobyo9MjU2KSl7aWYoZTwwJiZ1PT09MCYmdGhpc1tyK2krMV0hPT0wKXt1PTF9dGhpc1tyK2ldPShlL28+PjApLXUmMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4PWZ1bmN0aW9uIHdyaXRlSW50OChlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDEsMTI3LC0xMjgpO2lmKGU8MCllPTI1NStlKzE7dGhpc1tyXT1lJjI1NTtyZXR1cm4gcisxfTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRT1mdW5jdGlvbiB3cml0ZUludDE2TEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDMyNzY3LC0zMjc2OCk7dGhpc1tyXT1lJjI1NTt0aGlzW3IrMV09ZT4+Pjg7cmV0dXJuIHIrMn07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkU9ZnVuY3Rpb24gd3JpdGVJbnQxNkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiwzMjc2NywtMzI3NjgpO3RoaXNbcl09ZT4+Pjg7dGhpc1tyKzFdPWUmMjU1O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFPWZ1bmN0aW9uIHdyaXRlSW50MzJMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCk7dGhpc1tyXT1lJjI1NTt0aGlzW3IrMV09ZT4+Pjg7dGhpc1tyKzJdPWU+Pj4xNjt0aGlzW3IrM109ZT4+PjI0O3JldHVybiByKzR9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFPWZ1bmN0aW9uIHdyaXRlSW50MzJCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCk7aWYoZTwwKWU9NDI5NDk2NzI5NStlKzE7dGhpc1tyXT1lPj4+MjQ7dGhpc1tyKzFdPWU+Pj4xNjt0aGlzW3IrMl09ZT4+Pjg7dGhpc1tyKzNdPWUmMjU1O3JldHVybiByKzR9O2Z1bmN0aW9uIGNoZWNrSUVFRTc1NChlLHIsdCxmLG4saSl7aWYodCtmPmUubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO2lmKHQ8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKX1mdW5jdGlvbiB3cml0ZUZsb2F0KGUscix0LGYsaSl7cj0rcjt0PXQ+Pj4wO2lmKCFpKXtjaGVja0lFRUU3NTQoZSxyLHQsNCwzNDAyODIzNDY2Mzg1Mjg4NmUyMiwtMzQwMjgyMzQ2NjM4NTI4ODZlMjIpfW4ud3JpdGUoZSxyLHQsZiwyMyw0KTtyZXR1cm4gdCs0fUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFPWZ1bmN0aW9uIHdyaXRlRmxvYXRMRShlLHIsdCl7cmV0dXJuIHdyaXRlRmxvYXQodGhpcyxlLHIsdHJ1ZSx0KX07QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkU9ZnVuY3Rpb24gd3JpdGVGbG9hdEJFKGUscix0KXtyZXR1cm4gd3JpdGVGbG9hdCh0aGlzLGUscixmYWxzZSx0KX07ZnVuY3Rpb24gd3JpdGVEb3VibGUoZSxyLHQsZixpKXtyPStyO3Q9dD4+PjA7aWYoIWkpe2NoZWNrSUVFRTc1NChlLHIsdCw4LDE3OTc2OTMxMzQ4NjIzMTU3ZTI5MiwtMTc5NzY5MzEzNDg2MjMxNTdlMjkyKX1uLndyaXRlKGUscix0LGYsNTIsOCk7cmV0dXJuIHQrOH1CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEU9ZnVuY3Rpb24gd3JpdGVEb3VibGVMRShlLHIsdCl7cmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsZSxyLHRydWUsdCl9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRT1mdW5jdGlvbiB3cml0ZURvdWJsZUJFKGUscix0KXtyZXR1cm4gd3JpdGVEb3VibGUodGhpcyxlLHIsZmFsc2UsdCl9O0J1ZmZlci5wcm90b3R5cGUuY29weT1mdW5jdGlvbiBjb3B5KGUscix0LGYpe2lmKCFCdWZmZXIuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlclwiKTtpZighdCl0PTA7aWYoIWYmJmYhPT0wKWY9dGhpcy5sZW5ndGg7aWYocj49ZS5sZW5ndGgpcj1lLmxlbmd0aDtpZighcilyPTA7aWYoZj4wJiZmPHQpZj10O2lmKGY9PT10KXJldHVybiAwO2lmKGUubGVuZ3RoPT09MHx8dGhpcy5sZW5ndGg9PT0wKXJldHVybiAwO2lmKHI8MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzXCIpfWlmKHQ8MHx8dD49dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7aWYoZjwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwic291cmNlRW5kIG91dCBvZiBib3VuZHNcIik7aWYoZj50aGlzLmxlbmd0aClmPXRoaXMubGVuZ3RoO2lmKGUubGVuZ3RoLXI8Zi10KXtmPWUubGVuZ3RoLXIrdH12YXIgbj1mLXQ7aWYodGhpcz09PWUmJnR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluPT09XCJmdW5jdGlvblwiKXt0aGlzLmNvcHlXaXRoaW4ocix0LGYpfWVsc2UgaWYodGhpcz09PWUmJnQ8ciYmcjxmKXtmb3IodmFyIGk9bi0xO2k+PTA7LS1pKXtlW2krcl09dGhpc1tpK3RdfX1lbHNle1VpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKGUsdGhpcy5zdWJhcnJheSh0LGYpLHIpfXJldHVybiBufTtCdWZmZXIucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24gZmlsbChlLHIsdCxmKXtpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe2lmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7Zj1yO3I9MDt0PXRoaXMubGVuZ3RofWVsc2UgaWYodHlwZW9mIHQ9PT1cInN0cmluZ1wiKXtmPXQ7dD10aGlzLmxlbmd0aH1pZihmIT09dW5kZWZpbmVkJiZ0eXBlb2YgZiE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nXCIpfWlmKHR5cGVvZiBmPT09XCJzdHJpbmdcIiYmIUJ1ZmZlci5pc0VuY29kaW5nKGYpKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrZil9aWYoZS5sZW5ndGg9PT0xKXt2YXIgbj1lLmNoYXJDb2RlQXQoMCk7aWYoZj09PVwidXRmOFwiJiZuPDEyOHx8Zj09PVwibGF0aW4xXCIpe2U9bn19fWVsc2UgaWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtlPWUmMjU1fWVsc2UgaWYodHlwZW9mIGU9PT1cImJvb2xlYW5cIil7ZT1OdW1iZXIoZSl9aWYocjwwfHx0aGlzLmxlbmd0aDxyfHx0aGlzLmxlbmd0aDx0KXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk91dCBvZiByYW5nZSBpbmRleFwiKX1pZih0PD1yKXtyZXR1cm4gdGhpc31yPXI+Pj4wO3Q9dD09PXVuZGVmaW5lZD90aGlzLmxlbmd0aDp0Pj4+MDtpZighZSllPTA7dmFyIGk7aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtmb3IoaT1yO2k8dDsrK2kpe3RoaXNbaV09ZX19ZWxzZXt2YXIgbz1CdWZmZXIuaXNCdWZmZXIoZSk/ZTpCdWZmZXIuZnJvbShlLGYpO3ZhciB1PW8ubGVuZ3RoO2lmKHU9PT0wKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInK2UrJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpfWZvcihpPTA7aTx0LXI7KytpKXt0aGlzW2krcl09b1tpJXVdfX1yZXR1cm4gdGhpc307dmFyIGE9L1teKy8wLTlBLVphLXotX10vZztmdW5jdGlvbiBiYXNlNjRjbGVhbihlKXtlPWUuc3BsaXQoXCI9XCIpWzBdO2U9ZS50cmltKCkucmVwbGFjZShhLFwiXCIpO2lmKGUubGVuZ3RoPDIpcmV0dXJuXCJcIjt3aGlsZShlLmxlbmd0aCU0IT09MCl7ZT1lK1wiPVwifXJldHVybiBlfWZ1bmN0aW9uIHV0ZjhUb0J5dGVzKGUscil7cj1yfHxJbmZpbml0eTt2YXIgdDt2YXIgZj1lLmxlbmd0aDt2YXIgbj1udWxsO3ZhciBpPVtdO2Zvcih2YXIgbz0wO288ZjsrK28pe3Q9ZS5jaGFyQ29kZUF0KG8pO2lmKHQ+NTUyOTUmJnQ8NTczNDQpe2lmKCFuKXtpZih0PjU2MzE5KXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1lbHNlIGlmKG8rMT09PWYpe2lmKChyLT0zKT4tMSlpLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfW49dDtjb250aW51ZX1pZih0PDU2MzIwKXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KTtuPXQ7Y29udGludWV9dD0obi01NTI5Njw8MTB8dC01NjMyMCkrNjU1MzZ9ZWxzZSBpZihuKXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KX1uPW51bGw7aWYodDwxMjgpe2lmKChyLT0xKTwwKWJyZWFrO2kucHVzaCh0KX1lbHNlIGlmKHQ8MjA0OCl7aWYoKHItPTIpPDApYnJlYWs7aS5wdXNoKHQ+PjZ8MTkyLHQmNjN8MTI4KX1lbHNlIGlmKHQ8NjU1MzYpe2lmKChyLT0zKTwwKWJyZWFrO2kucHVzaCh0Pj4xMnwyMjQsdD4+NiY2M3wxMjgsdCY2M3wxMjgpfWVsc2UgaWYodDwxMTE0MTEyKXtpZigoci09NCk8MClicmVhaztpLnB1c2godD4+MTh8MjQwLHQ+PjEyJjYzfDEyOCx0Pj42JjYzfDEyOCx0JjYzfDEyOCl9ZWxzZXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvZGUgcG9pbnRcIil9fXJldHVybiBpfWZ1bmN0aW9uIGFzY2lpVG9CeXRlcyhlKXt2YXIgcj1bXTtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoOysrdCl7ci5wdXNoKGUuY2hhckNvZGVBdCh0KSYyNTUpfXJldHVybiByfWZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzKGUscil7dmFyIHQsZixuO3ZhciBpPVtdO2Zvcih2YXIgbz0wO288ZS5sZW5ndGg7KytvKXtpZigoci09Mik8MClicmVhazt0PWUuY2hhckNvZGVBdChvKTtmPXQ+Pjg7bj10JTI1NjtpLnB1c2gobik7aS5wdXNoKGYpfXJldHVybiBpfWZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoZSl7cmV0dXJuIGYudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oZSkpfWZ1bmN0aW9uIGJsaXRCdWZmZXIoZSxyLHQsZil7Zm9yKHZhciBuPTA7bjxmOysrbil7aWYobit0Pj1yLmxlbmd0aHx8bj49ZS5sZW5ndGgpYnJlYWs7cltuK3RdPWVbbl19cmV0dXJuIG59ZnVuY3Rpb24gaXNJbnN0YW5jZShlLHIpe3JldHVybiBlIGluc3RhbmNlb2Ygcnx8ZSE9bnVsbCYmZS5jb25zdHJ1Y3RvciE9bnVsbCYmZS5jb25zdHJ1Y3Rvci5uYW1lIT1udWxsJiZlLmNvbnN0cnVjdG9yLm5hbWU9PT1yLm5hbWV9ZnVuY3Rpb24gbnVtYmVySXNOYU4oZSl7cmV0dXJuIGUhPT1lfXZhciBzPWZ1bmN0aW9uKCl7dmFyIGU9XCIwMTIzNDU2Nzg5YWJjZGVmXCI7dmFyIHI9bmV3IEFycmF5KDI1Nik7Zm9yKHZhciB0PTA7dDwxNjsrK3Qpe3ZhciBmPXQqMTY7Zm9yKHZhciBuPTA7bjwxNjsrK24pe3JbZituXT1lW3RdK2Vbbl19fXJldHVybiByfSgpfSw3ODM6ZnVuY3Rpb24oZSxyKXtcbi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5yLnJlYWQ9ZnVuY3Rpb24oZSxyLHQsZixuKXt2YXIgaSxvO3ZhciB1PW4qOC1mLTE7dmFyIGE9KDE8PHUpLTE7dmFyIHM9YT4+MTt2YXIgaD0tNzt2YXIgYz10P24tMTowO3ZhciBsPXQ/LTE6MTt2YXIgcD1lW3IrY107Yys9bDtpPXAmKDE8PC1oKS0xO3A+Pj0taDtoKz11O2Zvcig7aD4wO2k9aSoyNTYrZVtyK2NdLGMrPWwsaC09OCl7fW89aSYoMTw8LWgpLTE7aT4+PS1oO2grPWY7Zm9yKDtoPjA7bz1vKjI1NitlW3IrY10sYys9bCxoLT04KXt9aWYoaT09PTApe2k9MS1zfWVsc2UgaWYoaT09PWEpe3JldHVybiBvP05hTjoocD8tMToxKSpJbmZpbml0eX1lbHNle289bytNYXRoLnBvdygyLGYpO2k9aS1zfXJldHVybihwPy0xOjEpKm8qTWF0aC5wb3coMixpLWYpfTtyLndyaXRlPWZ1bmN0aW9uKGUscix0LGYsbixpKXt2YXIgbyx1LGE7dmFyIHM9aSo4LW4tMTt2YXIgaD0oMTw8cyktMTt2YXIgYz1oPj4xO3ZhciBsPW49PT0yMz9NYXRoLnBvdygyLC0yNCktTWF0aC5wb3coMiwtNzcpOjA7dmFyIHA9Zj8wOmktMTt2YXIgeT1mPzE6LTE7dmFyIGc9cjwwfHxyPT09MCYmMS9yPDA/MTowO3I9TWF0aC5hYnMocik7aWYoaXNOYU4ocil8fHI9PT1JbmZpbml0eSl7dT1pc05hTihyKT8xOjA7bz1ofWVsc2V7bz1NYXRoLmZsb29yKE1hdGgubG9nKHIpL01hdGguTE4yKTtpZihyKihhPU1hdGgucG93KDIsLW8pKTwxKXtvLS07YSo9Mn1pZihvK2M+PTEpe3IrPWwvYX1lbHNle3IrPWwqTWF0aC5wb3coMiwxLWMpfWlmKHIqYT49Mil7bysrO2EvPTJ9aWYobytjPj1oKXt1PTA7bz1ofWVsc2UgaWYobytjPj0xKXt1PShyKmEtMSkqTWF0aC5wb3coMixuKTtvPW8rY31lbHNle3U9cipNYXRoLnBvdygyLGMtMSkqTWF0aC5wb3coMixuKTtvPTB9fWZvcig7bj49ODtlW3QrcF09dSYyNTUscCs9eSx1Lz0yNTYsbi09OCl7fW89bzw8bnx1O3MrPW47Zm9yKDtzPjA7ZVt0K3BdPW8mMjU1LHArPXksby89MjU2LHMtPTgpe31lW3QrcC15XXw9ZyoxMjh9fX07dmFyIHI9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyh0KXt2YXIgZj1yW3RdO2lmKGYhPT11bmRlZmluZWQpe3JldHVybiBmLmV4cG9ydHN9dmFyIG49clt0XT17ZXhwb3J0czp7fX07dmFyIGk9dHJ1ZTt0cnl7ZVt0XShuLG4uZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtpPWZhbHNlfWZpbmFsbHl7aWYoaSlkZWxldGUgclt0XX1yZXR1cm4gbi5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgdD1fX25jY3dwY2tfcmVxdWlyZV9fKDcyKTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/native-url/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/native-url/index.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={452:function(e){\"use strict\";e.exports=__webpack_require__(/*! next/dist/compiled/querystring-es3 */ \"(app-pages-browser)/./node_modules/next/dist/compiled/querystring-es3/index.js\")}};var t={};function __nccwpck_require__(o){var a=t[o];if(a!==undefined){return a.exports}var s=t[o]={exports:{}};var n=true;try{e[o](s,s.exports,__nccwpck_require__);n=false}finally{if(n)delete t[o]}return s.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var o={};!function(){var e=o;var t,a=(t=__nccwpck_require__(452))&&\"object\"==typeof t&&\"default\"in t?t.default:t,s=/https?|ftp|gopher|file/;function r(e){\"string\"==typeof e&&(e=d(e));var t=function(e,t,o){var a=e.auth,s=e.hostname,n=e.protocol||\"\",p=e.pathname||\"\",c=e.hash||\"\",i=e.query||\"\",u=!1;a=a?encodeURIComponent(a).replace(/%3A/i,\":\")+\"@\":\"\",e.host?u=a+e.host:s&&(u=a+(~s.indexOf(\":\")?\"[\"+s+\"]\":s),e.port&&(u+=\":\"+e.port)),i&&\"object\"==typeof i&&(i=t.encode(i));var f=e.search||i&&\"?\"+i||\"\";return n&&\":\"!==n.substr(-1)&&(n+=\":\"),e.slashes||(!n||o.test(n))&&!1!==u?(u=\"//\"+(u||\"\"),p&&\"/\"!==p[0]&&(p=\"/\"+p)):u||(u=\"\"),c&&\"#\"!==c[0]&&(c=\"#\"+c),f&&\"?\"!==f[0]&&(f=\"?\"+f),{protocol:n,host:u,pathname:p=p.replace(/[?#]/g,encodeURIComponent),search:f=f.replace(\"#\",\"%23\"),hash:c}}(e,a,s);return\"\"+t.protocol+t.host+t.pathname+t.search+t.hash}var n=\"http://\",p=\"w.w\",c=n+p,i=/^([a-z0-9.+-]*:\\/\\/\\/)([a-z0-9.+-]:\\/*)?/i,u=/https?|ftp|gopher|file/;function h(e,t){var o=\"string\"==typeof e?d(e):e;e=\"object\"==typeof e?r(e):e;var a=d(t),s=\"\";o.protocol&&!o.slashes&&(s=o.protocol,e=e.replace(o.protocol,\"\"),s+=\"/\"===t[0]||\"/\"===e[0]?\"/\":\"\"),s&&a.protocol&&(s=\"\",a.slashes||(s=a.protocol,t=t.replace(a.protocol,\"\")));var p=e.match(i);p&&!a.protocol&&(e=e.substr((s=p[1]+(p[2]||\"\")).length),/^\\/\\/[^/]/.test(t)&&(s=s.slice(0,-1)));var f=new URL(e,c+\"/\"),m=new URL(t,f).toString().replace(c,\"\"),v=a.protocol||o.protocol;return v+=o.slashes||a.slashes?\"//\":\"\",!s&&v?m=m.replace(n,v):s&&(m=m.replace(n,\"\")),u.test(m)||~t.indexOf(\".\")||\"/\"===e.slice(-1)||\"/\"===t.slice(-1)||\"/\"!==m.slice(-1)||(m=m.slice(0,-1)),s&&(m=s+(\"/\"===m[0]?m.substr(1):m)),m}function l(){}l.prototype.parse=d,l.prototype.format=r,l.prototype.resolve=h,l.prototype.resolveObject=h;var f=/^https?|ftp|gopher|file/,m=/^(.*?)([#?].*)/,v=/^([a-z0-9.+-]*:)(\\/{0,3})(.*)/i,_=/^([a-z0-9.+-]*:)?\\/\\/\\/*/i,b=/^([a-z0-9.+-]*:)(\\/{0,2})\\[(.*)\\]$/i;function d(e,t,o){if(void 0===t&&(t=!1),void 0===o&&(o=!1),e&&\"object\"==typeof e&&e instanceof l)return e;var s=(e=e.trim()).match(m);e=s?s[1].replace(/\\\\/g,\"/\")+s[2]:e.replace(/\\\\/g,\"/\"),b.test(e)&&\"/\"!==e.slice(-1)&&(e+=\"/\");var n=!/(^javascript)/.test(e)&&e.match(v),i=_.test(e),u=\"\";n&&(f.test(n[1])||(u=n[1].toLowerCase(),e=\"\"+n[2]+n[3]),n[2]||(i=!1,f.test(n[1])?(u=n[1],e=\"\"+n[3]):e=\"//\"+n[3]),3!==n[2].length&&1!==n[2].length||(u=n[1],e=\"/\"+n[3]));var g,y=(s?s[1]:e).match(/^https?:\\/\\/[^/]+(:[0-9]+)(?=\\/|$)/),w=y&&y[1],x=new l,C=\"\",U=\"\";try{g=new URL(e)}catch(t){C=t,u||o||!/^\\/\\//.test(e)||/^\\/\\/.+[@.]/.test(e)||(U=\"/\",e=e.substr(1));try{g=new URL(e,c)}catch(e){return x.protocol=u,x.href=u,x}}x.slashes=i&&!U,x.host=g.host===p?\"\":g.host,x.hostname=g.hostname===p?\"\":g.hostname.replace(/(\\[|\\])/g,\"\"),x.protocol=C?u||null:g.protocol,x.search=g.search.replace(/\\\\/g,\"%5C\"),x.hash=g.hash.replace(/\\\\/g,\"%5C\");var j=e.split(\"#\");!x.search&&~j[0].indexOf(\"?\")&&(x.search=\"?\"),x.hash||\"\"!==j[1]||(x.hash=\"#\"),x.query=t?a.decode(g.search.substr(1)):x.search.substr(1),x.pathname=U+(n?function(e){return e.replace(/['^|`]/g,(function(e){return\"%\"+e.charCodeAt().toString(16).toUpperCase()})).replace(/((?:%[0-9A-F]{2})+)/g,(function(e,t){try{return decodeURIComponent(t).split(\"\").map((function(e){var t=e.charCodeAt();return t>256||/^[a-z0-9]$/i.test(e)?e:\"%\"+t.toString(16).toUpperCase()})).join(\"\")}catch(e){return t}}))}(g.pathname):g.pathname),\"about:\"===x.protocol&&\"blank\"===x.pathname&&(x.protocol=\"\",x.pathname=\"\"),C&&\"/\"!==e[0]&&(x.pathname=x.pathname.substr(1)),u&&!f.test(u)&&\"/\"!==e.slice(-1)&&\"/\"===x.pathname&&(x.pathname=\"\"),x.path=x.pathname+x.search,x.auth=[g.username,g.password].map(decodeURIComponent).filter(Boolean).join(\":\"),x.port=g.port,w&&!x.host.endsWith(w)&&(x.host+=w,x.port=w.slice(1)),x.href=U?\"\"+x.pathname+x.search+x.hash:r(x);var q=/^(file)/.test(x.href)?[\"host\",\"hostname\"]:[];return Object.keys(x).forEach((function(e){~q.indexOf(e)||(x[e]=x[e]||null)})),x}e.parse=d,e.format=r,e.resolve=h,e.resolveObject=function(e,t){return d(h(e,t))},e.Url=l}();module.exports=o})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbmF0aXZlLXVybC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsWUFBWSxPQUFPLGdCQUFnQixhQUFhLFVBQVUsbUJBQU8sQ0FBQywwSEFBb0MsSUFBSSxTQUFTLGdDQUFnQyxXQUFXLGtCQUFrQixpQkFBaUIsWUFBWSxZQUFZLFdBQVcsSUFBSSxzQ0FBc0MsUUFBUSxRQUFRLGlCQUFpQixpQkFBaUIsbUVBQW1FLFNBQVMsS0FBSyxTQUFTLFlBQVksUUFBUSwrR0FBK0csY0FBYyw2QkFBNkIsc0JBQXNCLDRGQUE0Riw2S0FBNkssNkJBQTZCLGlMQUFpTCx5R0FBeUcsUUFBUSxzREFBc0QsdUdBQXVHLGdCQUFnQixnQ0FBZ0MsNEJBQTRCLGdCQUFnQiw4S0FBOEssaUJBQWlCLGdHQUFnRyx3RkFBd0Ysa09BQWtPLGNBQWMsMkZBQTJGLDBFQUEwRSxJQUFJLDZEQUE2RCxJQUFJLGFBQWEsa0JBQWtCLHdGQUF3Riw0QkFBNEIsNkZBQTZGLDREQUE0RCx3S0FBd0ssMkZBQTJGLElBQUksYUFBYSxTQUFTLHlFQUF5RSxJQUFJLGVBQWUsU0FBUyxnQ0FBZ0MscU5BQXFOLG1CQUFtQixvS0FBb0ssd0NBQXdDLG9EQUFvRCwwQkFBMEIsRUFBRSxxQkFBcUIsSUFBSSx3REFBd0QscUJBQXFCLHVFQUF1RSxZQUFZLFNBQVMsVUFBVSxHQUFHLHFiQUFxYixvREFBb0QsMkNBQTJDLGlDQUFpQyxLQUFLLCtEQUErRCxpQkFBaUIsU0FBUyxHQUFHLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL25hdGl2ZS11cmwvaW5kZXguanM/NWUwNSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXt2YXIgZT17NDUyOmZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1yZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3F1ZXJ5c3RyaW5nLWVzM1wiKX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18obyl7dmFyIGE9dFtvXTtpZihhIT09dW5kZWZpbmVkKXtyZXR1cm4gYS5leHBvcnRzfXZhciBzPXRbb109e2V4cG9ydHM6e319O3ZhciBuPXRydWU7dHJ5e2Vbb10ocyxzLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bj1mYWxzZX1maW5hbGx5e2lmKG4pZGVsZXRlIHRbb119cmV0dXJuIHMuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIG89e307IWZ1bmN0aW9uKCl7dmFyIGU9bzt2YXIgdCxhPSh0PV9fbmNjd3Bja19yZXF1aXJlX18oNDUyKSkmJlwib2JqZWN0XCI9PXR5cGVvZiB0JiZcImRlZmF1bHRcImluIHQ/dC5kZWZhdWx0OnQscz0vaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS87ZnVuY3Rpb24gcihlKXtcInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9ZChlKSk7dmFyIHQ9ZnVuY3Rpb24oZSx0LG8pe3ZhciBhPWUuYXV0aCxzPWUuaG9zdG5hbWUsbj1lLnByb3RvY29sfHxcIlwiLHA9ZS5wYXRobmFtZXx8XCJcIixjPWUuaGFzaHx8XCJcIixpPWUucXVlcnl8fFwiXCIsdT0hMTthPWE/ZW5jb2RlVVJJQ29tcG9uZW50KGEpLnJlcGxhY2UoLyUzQS9pLFwiOlwiKStcIkBcIjpcIlwiLGUuaG9zdD91PWErZS5ob3N0OnMmJih1PWErKH5zLmluZGV4T2YoXCI6XCIpP1wiW1wiK3MrXCJdXCI6cyksZS5wb3J0JiYodSs9XCI6XCIrZS5wb3J0KSksaSYmXCJvYmplY3RcIj09dHlwZW9mIGkmJihpPXQuZW5jb2RlKGkpKTt2YXIgZj1lLnNlYXJjaHx8aSYmXCI/XCIraXx8XCJcIjtyZXR1cm4gbiYmXCI6XCIhPT1uLnN1YnN0cigtMSkmJihuKz1cIjpcIiksZS5zbGFzaGVzfHwoIW58fG8udGVzdChuKSkmJiExIT09dT8odT1cIi8vXCIrKHV8fFwiXCIpLHAmJlwiL1wiIT09cFswXSYmKHA9XCIvXCIrcCkpOnV8fCh1PVwiXCIpLGMmJlwiI1wiIT09Y1swXSYmKGM9XCIjXCIrYyksZiYmXCI/XCIhPT1mWzBdJiYoZj1cIj9cIitmKSx7cHJvdG9jb2w6bixob3N0OnUscGF0aG5hbWU6cD1wLnJlcGxhY2UoL1s/I10vZyxlbmNvZGVVUklDb21wb25lbnQpLHNlYXJjaDpmPWYucmVwbGFjZShcIiNcIixcIiUyM1wiKSxoYXNoOmN9fShlLGEscyk7cmV0dXJuXCJcIit0LnByb3RvY29sK3QuaG9zdCt0LnBhdGhuYW1lK3Quc2VhcmNoK3QuaGFzaH12YXIgbj1cImh0dHA6Ly9cIixwPVwidy53XCIsYz1uK3AsaT0vXihbYS16MC05ListXSo6XFwvXFwvXFwvKShbYS16MC05ListXTpcXC8qKT8vaSx1PS9odHRwcz98ZnRwfGdvcGhlcnxmaWxlLztmdW5jdGlvbiBoKGUsdCl7dmFyIG89XCJzdHJpbmdcIj09dHlwZW9mIGU/ZChlKTplO2U9XCJvYmplY3RcIj09dHlwZW9mIGU/cihlKTplO3ZhciBhPWQodCkscz1cIlwiO28ucHJvdG9jb2wmJiFvLnNsYXNoZXMmJihzPW8ucHJvdG9jb2wsZT1lLnJlcGxhY2Uoby5wcm90b2NvbCxcIlwiKSxzKz1cIi9cIj09PXRbMF18fFwiL1wiPT09ZVswXT9cIi9cIjpcIlwiKSxzJiZhLnByb3RvY29sJiYocz1cIlwiLGEuc2xhc2hlc3x8KHM9YS5wcm90b2NvbCx0PXQucmVwbGFjZShhLnByb3RvY29sLFwiXCIpKSk7dmFyIHA9ZS5tYXRjaChpKTtwJiYhYS5wcm90b2NvbCYmKGU9ZS5zdWJzdHIoKHM9cFsxXSsocFsyXXx8XCJcIikpLmxlbmd0aCksL15cXC9cXC9bXi9dLy50ZXN0KHQpJiYocz1zLnNsaWNlKDAsLTEpKSk7dmFyIGY9bmV3IFVSTChlLGMrXCIvXCIpLG09bmV3IFVSTCh0LGYpLnRvU3RyaW5nKCkucmVwbGFjZShjLFwiXCIpLHY9YS5wcm90b2NvbHx8by5wcm90b2NvbDtyZXR1cm4gdis9by5zbGFzaGVzfHxhLnNsYXNoZXM/XCIvL1wiOlwiXCIsIXMmJnY/bT1tLnJlcGxhY2Uobix2KTpzJiYobT1tLnJlcGxhY2UobixcIlwiKSksdS50ZXN0KG0pfHx+dC5pbmRleE9mKFwiLlwiKXx8XCIvXCI9PT1lLnNsaWNlKC0xKXx8XCIvXCI9PT10LnNsaWNlKC0xKXx8XCIvXCIhPT1tLnNsaWNlKC0xKXx8KG09bS5zbGljZSgwLC0xKSkscyYmKG09cysoXCIvXCI9PT1tWzBdP20uc3Vic3RyKDEpOm0pKSxtfWZ1bmN0aW9uIGwoKXt9bC5wcm90b3R5cGUucGFyc2U9ZCxsLnByb3RvdHlwZS5mb3JtYXQ9cixsLnByb3RvdHlwZS5yZXNvbHZlPWgsbC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdD1oO3ZhciBmPS9eaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS8sbT0vXiguKj8pKFsjP10uKikvLHY9L14oW2EtejAtOS4rLV0qOikoXFwvezAsM30pKC4qKS9pLF89L14oW2EtejAtOS4rLV0qOik/XFwvXFwvXFwvKi9pLGI9L14oW2EtejAtOS4rLV0qOikoXFwvezAsMn0pXFxbKC4qKVxcXSQvaTtmdW5jdGlvbiBkKGUsdCxvKXtpZih2b2lkIDA9PT10JiYodD0hMSksdm9pZCAwPT09byYmKG89ITEpLGUmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZlIGluc3RhbmNlb2YgbClyZXR1cm4gZTt2YXIgcz0oZT1lLnRyaW0oKSkubWF0Y2gobSk7ZT1zP3NbMV0ucmVwbGFjZSgvXFxcXC9nLFwiL1wiKStzWzJdOmUucmVwbGFjZSgvXFxcXC9nLFwiL1wiKSxiLnRlc3QoZSkmJlwiL1wiIT09ZS5zbGljZSgtMSkmJihlKz1cIi9cIik7dmFyIG49IS8oXmphdmFzY3JpcHQpLy50ZXN0KGUpJiZlLm1hdGNoKHYpLGk9Xy50ZXN0KGUpLHU9XCJcIjtuJiYoZi50ZXN0KG5bMV0pfHwodT1uWzFdLnRvTG93ZXJDYXNlKCksZT1cIlwiK25bMl0rblszXSksblsyXXx8KGk9ITEsZi50ZXN0KG5bMV0pPyh1PW5bMV0sZT1cIlwiK25bM10pOmU9XCIvL1wiK25bM10pLDMhPT1uWzJdLmxlbmd0aCYmMSE9PW5bMl0ubGVuZ3RofHwodT1uWzFdLGU9XCIvXCIrblszXSkpO3ZhciBnLHk9KHM/c1sxXTplKS5tYXRjaCgvXmh0dHBzPzpcXC9cXC9bXi9dKyg6WzAtOV0rKSg/PVxcL3wkKS8pLHc9eSYmeVsxXSx4PW5ldyBsLEM9XCJcIixVPVwiXCI7dHJ5e2c9bmV3IFVSTChlKX1jYXRjaCh0KXtDPXQsdXx8b3x8IS9eXFwvXFwvLy50ZXN0KGUpfHwvXlxcL1xcLy4rW0AuXS8udGVzdChlKXx8KFU9XCIvXCIsZT1lLnN1YnN0cigxKSk7dHJ5e2c9bmV3IFVSTChlLGMpfWNhdGNoKGUpe3JldHVybiB4LnByb3RvY29sPXUseC5ocmVmPXUseH19eC5zbGFzaGVzPWkmJiFVLHguaG9zdD1nLmhvc3Q9PT1wP1wiXCI6Zy5ob3N0LHguaG9zdG5hbWU9Zy5ob3N0bmFtZT09PXA/XCJcIjpnLmhvc3RuYW1lLnJlcGxhY2UoLyhcXFt8XFxdKS9nLFwiXCIpLHgucHJvdG9jb2w9Qz91fHxudWxsOmcucHJvdG9jb2wseC5zZWFyY2g9Zy5zZWFyY2gucmVwbGFjZSgvXFxcXC9nLFwiJTVDXCIpLHguaGFzaD1nLmhhc2gucmVwbGFjZSgvXFxcXC9nLFwiJTVDXCIpO3ZhciBqPWUuc3BsaXQoXCIjXCIpOyF4LnNlYXJjaCYmfmpbMF0uaW5kZXhPZihcIj9cIikmJih4LnNlYXJjaD1cIj9cIikseC5oYXNofHxcIlwiIT09alsxXXx8KHguaGFzaD1cIiNcIikseC5xdWVyeT10P2EuZGVjb2RlKGcuc2VhcmNoLnN1YnN0cigxKSk6eC5zZWFyY2guc3Vic3RyKDEpLHgucGF0aG5hbWU9VSsobj9mdW5jdGlvbihlKXtyZXR1cm4gZS5yZXBsYWNlKC9bJ158YF0vZywoZnVuY3Rpb24oZSl7cmV0dXJuXCIlXCIrZS5jaGFyQ29kZUF0KCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCl9KSkucmVwbGFjZSgvKCg/OiVbMC05QS1GXXsyfSkrKS9nLChmdW5jdGlvbihlLHQpe3RyeXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHQpLnNwbGl0KFwiXCIpLm1hcCgoZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jaGFyQ29kZUF0KCk7cmV0dXJuIHQ+MjU2fHwvXlthLXowLTldJC9pLnRlc3QoZSk/ZTpcIiVcIit0LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpfSkpLmpvaW4oXCJcIil9Y2F0Y2goZSl7cmV0dXJuIHR9fSkpfShnLnBhdGhuYW1lKTpnLnBhdGhuYW1lKSxcImFib3V0OlwiPT09eC5wcm90b2NvbCYmXCJibGFua1wiPT09eC5wYXRobmFtZSYmKHgucHJvdG9jb2w9XCJcIix4LnBhdGhuYW1lPVwiXCIpLEMmJlwiL1wiIT09ZVswXSYmKHgucGF0aG5hbWU9eC5wYXRobmFtZS5zdWJzdHIoMSkpLHUmJiFmLnRlc3QodSkmJlwiL1wiIT09ZS5zbGljZSgtMSkmJlwiL1wiPT09eC5wYXRobmFtZSYmKHgucGF0aG5hbWU9XCJcIikseC5wYXRoPXgucGF0aG5hbWUreC5zZWFyY2gseC5hdXRoPVtnLnVzZXJuYW1lLGcucGFzc3dvcmRdLm1hcChkZWNvZGVVUklDb21wb25lbnQpLmZpbHRlcihCb29sZWFuKS5qb2luKFwiOlwiKSx4LnBvcnQ9Zy5wb3J0LHcmJiF4Lmhvc3QuZW5kc1dpdGgodykmJih4Lmhvc3QrPXcseC5wb3J0PXcuc2xpY2UoMSkpLHguaHJlZj1VP1wiXCIreC5wYXRobmFtZSt4LnNlYXJjaCt4Lmhhc2g6cih4KTt2YXIgcT0vXihmaWxlKS8udGVzdCh4LmhyZWYpP1tcImhvc3RcIixcImhvc3RuYW1lXCJdOltdO3JldHVybiBPYmplY3Qua2V5cyh4KS5mb3JFYWNoKChmdW5jdGlvbihlKXt+cS5pbmRleE9mKGUpfHwoeFtlXT14W2VdfHxudWxsKX0pKSx4fWUucGFyc2U9ZCxlLmZvcm1hdD1yLGUucmVzb2x2ZT1oLGUucmVzb2x2ZU9iamVjdD1mdW5jdGlvbihlLHQpe3JldHVybiBkKGgoZSx0KSl9LGUuVXJsPWx9KCk7bW9kdWxlLmV4cG9ydHM9b30pKCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/native-url/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/querystring-es3/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/querystring-es3/index.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){\"use strict\";var e={815:function(e){function hasOwnProperty(e,r){return Object.prototype.hasOwnProperty.call(e,r)}e.exports=function(e,n,t,o){n=n||\"&\";t=t||\"=\";var a={};if(typeof e!==\"string\"||e.length===0){return a}var i=/\\+/g;e=e.split(n);var u=1e3;if(o&&typeof o.maxKeys===\"number\"){u=o.maxKeys}var c=e.length;if(u>0&&c>u){c=u}for(var p=0;p<c;++p){var f=e[p].replace(i,\"%20\"),s=f.indexOf(t),_,l,y,d;if(s>=0){_=f.substr(0,s);l=f.substr(s+1)}else{_=f;l=\"\"}y=decodeURIComponent(_);d=decodeURIComponent(l);if(!hasOwnProperty(a,y)){a[y]=d}else if(r(a[y])){a[y].push(d)}else{a[y]=[a[y],d]}}return a};var r=Array.isArray||function(e){return Object.prototype.toString.call(e)===\"[object Array]\"}},577:function(e){var stringifyPrimitive=function(e){switch(typeof e){case\"string\":return e;case\"boolean\":return e?\"true\":\"false\";case\"number\":return isFinite(e)?e:\"\";default:return\"\"}};e.exports=function(e,t,o,a){t=t||\"&\";o=o||\"=\";if(e===null){e=undefined}if(typeof e===\"object\"){return map(n(e),(function(n){var a=encodeURIComponent(stringifyPrimitive(n))+o;if(r(e[n])){return map(e[n],(function(e){return a+encodeURIComponent(stringifyPrimitive(e))})).join(t)}else{return a+encodeURIComponent(stringifyPrimitive(e[n]))}})).join(t)}if(!a)return\"\";return encodeURIComponent(stringifyPrimitive(a))+o+encodeURIComponent(stringifyPrimitive(e))};var r=Array.isArray||function(e){return Object.prototype.toString.call(e)===\"[object Array]\"};function map(e,r){if(e.map)return e.map(r);var n=[];for(var t=0;t<e.length;t++){n.push(r(e[t],t))}return n}var n=Object.keys||function(e){var r=[];for(var n in e){if(Object.prototype.hasOwnProperty.call(e,n))r.push(n)}return r}}};var r={};function __nccwpck_require__(n){var t=r[n];if(t!==undefined){return t.exports}var o=r[n]={exports:{}};var a=true;try{e[n](o,o.exports,__nccwpck_require__);a=false}finally{if(a)delete r[n]}return o.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var n={};!function(){var e=n;e.decode=e.parse=__nccwpck_require__(815);e.encode=e.stringify=__nccwpck_require__(577)}();module.exports=n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLGFBQWEsT0FBTyxnQkFBZ0IsNkJBQTZCLGlEQUFpRCw0QkFBNEIsU0FBUyxTQUFTLFNBQVMsc0NBQXNDLFNBQVMsWUFBWSxhQUFhLFVBQVUsbUNBQW1DLFlBQVksZUFBZSxhQUFhLElBQUksWUFBWSxJQUFJLEtBQUssbURBQW1ELFNBQVMsZ0JBQWdCLGdCQUFnQixLQUFLLElBQUksS0FBSyx3QkFBd0Isd0JBQXdCLHlCQUF5QixPQUFPLGlCQUFpQixhQUFhLEtBQUssZUFBZSxVQUFVLGlDQUFpQyw2REFBNkQsaUJBQWlCLG1DQUFtQyxpQkFBaUIsc0JBQXNCLHNDQUFzQyxxQ0FBcUMsbUJBQW1CLDRCQUE0QixTQUFTLFNBQVMsYUFBYSxZQUFZLHdCQUF3Qiw2QkFBNkIsa0RBQWtELFlBQVksNkJBQTZCLG1EQUFtRCxXQUFXLEtBQUssdURBQXVELFdBQVcsZUFBZSw4RkFBOEYsaUNBQWlDLDZEQUE2RCxrQkFBa0IseUJBQXlCLFNBQVMsWUFBWSxXQUFXLEtBQUssa0JBQWtCLFNBQVMsK0JBQStCLFNBQVMsZ0JBQWdCLHVEQUF1RCxZQUFZLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLFNBQVMsWUFBWSxRQUFRLDBDQUEwQyw4Q0FBOEMsR0FBRyxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9xdWVyeXN0cmluZy1lczMvaW5kZXguanM/ZjMzYyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgZT17ODE1OmZ1bmN0aW9uKGUpe2Z1bmN0aW9uIGhhc093blByb3BlcnR5KGUscil7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpfWUuZXhwb3J0cz1mdW5jdGlvbihlLG4sdCxvKXtuPW58fFwiJlwiO3Q9dHx8XCI9XCI7dmFyIGE9e307aWYodHlwZW9mIGUhPT1cInN0cmluZ1wifHxlLmxlbmd0aD09PTApe3JldHVybiBhfXZhciBpPS9cXCsvZztlPWUuc3BsaXQobik7dmFyIHU9MWUzO2lmKG8mJnR5cGVvZiBvLm1heEtleXM9PT1cIm51bWJlclwiKXt1PW8ubWF4S2V5c312YXIgYz1lLmxlbmd0aDtpZih1PjAmJmM+dSl7Yz11fWZvcih2YXIgcD0wO3A8YzsrK3Ape3ZhciBmPWVbcF0ucmVwbGFjZShpLFwiJTIwXCIpLHM9Zi5pbmRleE9mKHQpLF8sbCx5LGQ7aWYocz49MCl7Xz1mLnN1YnN0cigwLHMpO2w9Zi5zdWJzdHIocysxKX1lbHNle189ZjtsPVwiXCJ9eT1kZWNvZGVVUklDb21wb25lbnQoXyk7ZD1kZWNvZGVVUklDb21wb25lbnQobCk7aWYoIWhhc093blByb3BlcnR5KGEseSkpe2FbeV09ZH1lbHNlIGlmKHIoYVt5XSkpe2FbeV0ucHVzaChkKX1lbHNle2FbeV09W2FbeV0sZF19fXJldHVybiBhfTt2YXIgcj1BcnJheS5pc0FycmF5fHxmdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpPT09XCJbb2JqZWN0IEFycmF5XVwifX0sNTc3OmZ1bmN0aW9uKGUpe3ZhciBzdHJpbmdpZnlQcmltaXRpdmU9ZnVuY3Rpb24oZSl7c3dpdGNoKHR5cGVvZiBlKXtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gZTtjYXNlXCJib29sZWFuXCI6cmV0dXJuIGU/XCJ0cnVlXCI6XCJmYWxzZVwiO2Nhc2VcIm51bWJlclwiOnJldHVybiBpc0Zpbml0ZShlKT9lOlwiXCI7ZGVmYXVsdDpyZXR1cm5cIlwifX07ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxvLGEpe3Q9dHx8XCImXCI7bz1vfHxcIj1cIjtpZihlPT09bnVsbCl7ZT11bmRlZmluZWR9aWYodHlwZW9mIGU9PT1cIm9iamVjdFwiKXtyZXR1cm4gbWFwKG4oZSksKGZ1bmN0aW9uKG4pe3ZhciBhPWVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobikpK287aWYocihlW25dKSl7cmV0dXJuIG1hcChlW25dLChmdW5jdGlvbihlKXtyZXR1cm4gYStlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGUpKX0pKS5qb2luKHQpfWVsc2V7cmV0dXJuIGErZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShlW25dKSl9fSkpLmpvaW4odCl9aWYoIWEpcmV0dXJuXCJcIjtyZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShhKSkrbytlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGUpKX07dmFyIHI9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKT09PVwiW29iamVjdCBBcnJheV1cIn07ZnVuY3Rpb24gbWFwKGUscil7aWYoZS5tYXApcmV0dXJuIGUubWFwKHIpO3ZhciBuPVtdO2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtuLnB1c2gocihlW3RdLHQpKX1yZXR1cm4gbn12YXIgbj1PYmplY3Qua2V5c3x8ZnVuY3Rpb24oZSl7dmFyIHI9W107Zm9yKHZhciBuIGluIGUpe2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pKXIucHVzaChuKX1yZXR1cm4gcn19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKG4pe3ZhciB0PXJbbl07aWYodCE9PXVuZGVmaW5lZCl7cmV0dXJuIHQuZXhwb3J0c312YXIgbz1yW25dPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW25dKG8sby5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW25dfXJldHVybiBvLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciBuPXt9OyFmdW5jdGlvbigpe3ZhciBlPW47ZS5kZWNvZGU9ZS5wYXJzZT1fX25jY3dwY2tfcmVxdWlyZV9fKDgxNSk7ZS5lbmNvZGU9ZS5zdHJpbmdpZnk9X19uY2N3cGNrX3JlcXVpcmVfXyg1NzcpfSgpO21vZHVsZS5leHBvcnRzPW59KSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/querystring-es3/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/xml-utils/count-substring.js":
/*!***************************************************!*\
  !*** ./node_modules/xml-utils/count-substring.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function countSubstring(string, substring) {\n  const pattern = new RegExp(substring, \"g\");\n  const match = string.match(pattern);\n  return match ? match.length : 0;\n}\n\nmodule.exports = countSubstring;\nmodule.exports[\"default\"] = countSubstring;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy94bWwtdXRpbHMvY291bnQtc3Vic3RyaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3htbC11dGlscy9jb3VudC1zdWJzdHJpbmcuanM/MGRiNiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBjb3VudFN1YnN0cmluZyhzdHJpbmcsIHN1YnN0cmluZykge1xuICBjb25zdCBwYXR0ZXJuID0gbmV3IFJlZ0V4cChzdWJzdHJpbmcsIFwiZ1wiKTtcbiAgY29uc3QgbWF0Y2ggPSBzdHJpbmcubWF0Y2gocGF0dGVybik7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoLmxlbmd0aCA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY291bnRTdWJzdHJpbmc7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gY291bnRTdWJzdHJpbmc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/xml-utils/count-substring.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/xml-utils/find-tag-by-name.js":
/*!****************************************************!*\
  !*** ./node_modules/xml-utils/find-tag-by-name.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("const indexOfMatch = __webpack_require__(/*! ./index-of-match.js */ \"(app-pages-browser)/./node_modules/xml-utils/index-of-match.js\");\nconst indexOfMatchEnd = __webpack_require__(/*! ./index-of-match-end.js */ \"(app-pages-browser)/./node_modules/xml-utils/index-of-match-end.js\");\nconst countSubstring = __webpack_require__(/*! ./count-substring.js */ \"(app-pages-browser)/./node_modules/xml-utils/count-substring.js\");\n\nfunction findTagByName(xml, tagName, options) {\n  const debug = (options && options.debug) || false;\n  const nested = !(options && typeof options.nested === false);\n\n  const startIndex = (options && options.startIndex) || 0;\n\n  if (debug) console.log(\"[xml-utils] starting findTagByName with\", tagName, \" and \", options);\n\n  const start = indexOfMatch(xml, `\\<${tagName}[ \\n\\>\\/]`, startIndex);\n  if (debug) console.log(\"[xml-utils] start:\", start);\n  if (start === -1) return undefined;\n\n  const afterStart = xml.slice(start + tagName.length);\n\n  let relativeEnd = indexOfMatchEnd(afterStart, \"^[^<]*[ /]>\", 0);\n\n  const selfClosing = relativeEnd !== -1 && afterStart[relativeEnd - 1] === \"/\";\n  if (debug) console.log(\"[xml-utils] selfClosing:\", selfClosing);\n\n  if (selfClosing === false) {\n    // check if tag has subtags with the same name\n    if (nested) {\n      let startIndex = 0;\n      let openings = 1;\n      let closings = 0;\n      while ((relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", startIndex)) !== -1) {\n        const clip = afterStart.substring(startIndex, relativeEnd + 1);\n        openings += countSubstring(clip, \"<\" + tagName + \"[ \\n\\t>]\");\n        closings += countSubstring(clip, \"</\" + tagName + \">\");\n        // we can't have more openings than closings\n        if (closings >= openings) break;\n        startIndex = relativeEnd;\n      }\n    } else {\n      relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", 0);\n    }\n  }\n\n  const end = start + tagName.length + relativeEnd + 1;\n  if (debug) console.log(\"[xml-utils] end:\", end);\n  if (end === -1) return undefined;\n\n  const outer = xml.slice(start, end);\n  // tag is like <gml:identifier codeSpace=\"OGP\">urn:ogc:def:crs:EPSG::32617</gml:identifier>\n\n  let inner;\n  if (selfClosing) {\n    inner = null;\n  } else {\n    inner = outer.slice(outer.indexOf(\">\") + 1, outer.lastIndexOf(\"<\"));\n  }\n\n  return { inner, outer, start, end };\n}\n\nmodule.exports = findTagByName;\nmodule.exports[\"default\"] = findTagByName;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy94bWwtdXRpbHMvZmluZC10YWctYnktbmFtZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxQkFBcUIsbUJBQU8sQ0FBQywyRkFBcUI7QUFDbEQsd0JBQXdCLG1CQUFPLENBQUMsbUdBQXlCO0FBQ3pELHVCQUF1QixtQkFBTyxDQUFDLDZGQUFzQjs7QUFFckQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQSx5QkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3htbC11dGlscy9maW5kLXRhZy1ieS1uYW1lLmpzPzYwN2YiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgaW5kZXhPZk1hdGNoID0gcmVxdWlyZShcIi4vaW5kZXgtb2YtbWF0Y2guanNcIik7XG5jb25zdCBpbmRleE9mTWF0Y2hFbmQgPSByZXF1aXJlKFwiLi9pbmRleC1vZi1tYXRjaC1lbmQuanNcIik7XG5jb25zdCBjb3VudFN1YnN0cmluZyA9IHJlcXVpcmUoXCIuL2NvdW50LXN1YnN0cmluZy5qc1wiKTtcblxuZnVuY3Rpb24gZmluZFRhZ0J5TmFtZSh4bWwsIHRhZ05hbWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGVidWcgPSAob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnKSB8fCBmYWxzZTtcbiAgY29uc3QgbmVzdGVkID0gIShvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm5lc3RlZCA9PT0gZmFsc2UpO1xuXG4gIGNvbnN0IHN0YXJ0SW5kZXggPSAob3B0aW9ucyAmJiBvcHRpb25zLnN0YXJ0SW5kZXgpIHx8IDA7XG5cbiAgaWYgKGRlYnVnKSBjb25zb2xlLmxvZyhcIlt4bWwtdXRpbHNdIHN0YXJ0aW5nIGZpbmRUYWdCeU5hbWUgd2l0aFwiLCB0YWdOYW1lLCBcIiBhbmQgXCIsIG9wdGlvbnMpO1xuXG4gIGNvbnN0IHN0YXJ0ID0gaW5kZXhPZk1hdGNoKHhtbCwgYFxcPCR7dGFnTmFtZX1bIFxcblxcPlxcL11gLCBzdGFydEluZGV4KTtcbiAgaWYgKGRlYnVnKSBjb25zb2xlLmxvZyhcIlt4bWwtdXRpbHNdIHN0YXJ0OlwiLCBzdGFydCk7XG4gIGlmIChzdGFydCA9PT0gLTEpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgY29uc3QgYWZ0ZXJTdGFydCA9IHhtbC5zbGljZShzdGFydCArIHRhZ05hbWUubGVuZ3RoKTtcblxuICBsZXQgcmVsYXRpdmVFbmQgPSBpbmRleE9mTWF0Y2hFbmQoYWZ0ZXJTdGFydCwgXCJeW148XSpbIC9dPlwiLCAwKTtcblxuICBjb25zdCBzZWxmQ2xvc2luZyA9IHJlbGF0aXZlRW5kICE9PSAtMSAmJiBhZnRlclN0YXJ0W3JlbGF0aXZlRW5kIC0gMV0gPT09IFwiL1wiO1xuICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwiW3htbC11dGlsc10gc2VsZkNsb3Npbmc6XCIsIHNlbGZDbG9zaW5nKTtcblxuICBpZiAoc2VsZkNsb3NpbmcgPT09IGZhbHNlKSB7XG4gICAgLy8gY2hlY2sgaWYgdGFnIGhhcyBzdWJ0YWdzIHdpdGggdGhlIHNhbWUgbmFtZVxuICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgIGxldCBzdGFydEluZGV4ID0gMDtcbiAgICAgIGxldCBvcGVuaW5ncyA9IDE7XG4gICAgICBsZXQgY2xvc2luZ3MgPSAwO1xuICAgICAgd2hpbGUgKChyZWxhdGl2ZUVuZCA9IGluZGV4T2ZNYXRjaEVuZChhZnRlclN0YXJ0LCBcIlsgL11cIiArIHRhZ05hbWUgKyBcIj5cIiwgc3RhcnRJbmRleCkpICE9PSAtMSkge1xuICAgICAgICBjb25zdCBjbGlwID0gYWZ0ZXJTdGFydC5zdWJzdHJpbmcoc3RhcnRJbmRleCwgcmVsYXRpdmVFbmQgKyAxKTtcbiAgICAgICAgb3BlbmluZ3MgKz0gY291bnRTdWJzdHJpbmcoY2xpcCwgXCI8XCIgKyB0YWdOYW1lICsgXCJbIFxcblxcdD5dXCIpO1xuICAgICAgICBjbG9zaW5ncyArPSBjb3VudFN1YnN0cmluZyhjbGlwLCBcIjwvXCIgKyB0YWdOYW1lICsgXCI+XCIpO1xuICAgICAgICAvLyB3ZSBjYW4ndCBoYXZlIG1vcmUgb3BlbmluZ3MgdGhhbiBjbG9zaW5nc1xuICAgICAgICBpZiAoY2xvc2luZ3MgPj0gb3BlbmluZ3MpIGJyZWFrO1xuICAgICAgICBzdGFydEluZGV4ID0gcmVsYXRpdmVFbmQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbGF0aXZlRW5kID0gaW5kZXhPZk1hdGNoRW5kKGFmdGVyU3RhcnQsIFwiWyAvXVwiICsgdGFnTmFtZSArIFwiPlwiLCAwKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBlbmQgPSBzdGFydCArIHRhZ05hbWUubGVuZ3RoICsgcmVsYXRpdmVFbmQgKyAxO1xuICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwiW3htbC11dGlsc10gZW5kOlwiLCBlbmQpO1xuICBpZiAoZW5kID09PSAtMSkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICBjb25zdCBvdXRlciA9IHhtbC5zbGljZShzdGFydCwgZW5kKTtcbiAgLy8gdGFnIGlzIGxpa2UgPGdtbDppZGVudGlmaWVyIGNvZGVTcGFjZT1cIk9HUFwiPnVybjpvZ2M6ZGVmOmNyczpFUFNHOjozMjYxNzwvZ21sOmlkZW50aWZpZXI+XG5cbiAgbGV0IGlubmVyO1xuICBpZiAoc2VsZkNsb3NpbmcpIHtcbiAgICBpbm5lciA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgaW5uZXIgPSBvdXRlci5zbGljZShvdXRlci5pbmRleE9mKFwiPlwiKSArIDEsIG91dGVyLmxhc3RJbmRleE9mKFwiPFwiKSk7XG4gIH1cblxuICByZXR1cm4geyBpbm5lciwgb3V0ZXIsIHN0YXJ0LCBlbmQgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kVGFnQnlOYW1lO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGZpbmRUYWdCeU5hbWU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/xml-utils/find-tag-by-name.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/xml-utils/find-tags-by-name.js":
/*!*****************************************************!*\
  !*** ./node_modules/xml-utils/find-tags-by-name.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("const findTagByName = __webpack_require__(/*! ./find-tag-by-name.js */ \"(app-pages-browser)/./node_modules/xml-utils/find-tag-by-name.js\");\n\nfunction findTagsByName(xml, tagName, options) {\n  const tags = [];\n  const debug = (options && options.debug) || false;\n  const nested = options && typeof options.nested === \"boolean\" ? options.nested : true;\n  let startIndex = (options && options.startIndex) || 0;\n  let tag;\n  while ((tag = findTagByName(xml, tagName, { debug, startIndex }))) {\n    if (nested) {\n      startIndex = tag.start + 1 + tagName.length;\n    } else {\n      startIndex = tag.end;\n    }\n    tags.push(tag);\n  }\n  if (debug) console.log(\"findTagsByName found\", tags.length, \"tags\");\n  return tags;\n}\n\nmodule.exports = findTagsByName;\nmodule.exports[\"default\"] = findTagsByName;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy94bWwtdXRpbHMvZmluZC10YWdzLWJ5LW5hbWUuanMiLCJtYXBwaW5ncyI6IkFBQUEsc0JBQXNCLG1CQUFPLENBQUMsK0ZBQXVCOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsbUJBQW1CO0FBQ2pFO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3htbC11dGlscy9maW5kLXRhZ3MtYnktbmFtZS5qcz80N2E3Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGZpbmRUYWdCeU5hbWUgPSByZXF1aXJlKFwiLi9maW5kLXRhZy1ieS1uYW1lLmpzXCIpO1xuXG5mdW5jdGlvbiBmaW5kVGFnc0J5TmFtZSh4bWwsIHRhZ05hbWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgdGFncyA9IFtdO1xuICBjb25zdCBkZWJ1ZyA9IChvcHRpb25zICYmIG9wdGlvbnMuZGVidWcpIHx8IGZhbHNlO1xuICBjb25zdCBuZXN0ZWQgPSBvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm5lc3RlZCA9PT0gXCJib29sZWFuXCIgPyBvcHRpb25zLm5lc3RlZCA6IHRydWU7XG4gIGxldCBzdGFydEluZGV4ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5zdGFydEluZGV4KSB8fCAwO1xuICBsZXQgdGFnO1xuICB3aGlsZSAoKHRhZyA9IGZpbmRUYWdCeU5hbWUoeG1sLCB0YWdOYW1lLCB7IGRlYnVnLCBzdGFydEluZGV4IH0pKSkge1xuICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgIHN0YXJ0SW5kZXggPSB0YWcuc3RhcnQgKyAxICsgdGFnTmFtZS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0SW5kZXggPSB0YWcuZW5kO1xuICAgIH1cbiAgICB0YWdzLnB1c2godGFnKTtcbiAgfVxuICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwiZmluZFRhZ3NCeU5hbWUgZm91bmRcIiwgdGFncy5sZW5ndGgsIFwidGFnc1wiKTtcbiAgcmV0dXJuIHRhZ3M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZFRhZ3NCeU5hbWU7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZmluZFRhZ3NCeU5hbWU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/xml-utils/find-tags-by-name.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/xml-utils/get-attribute.js":
/*!*************************************************!*\
  !*** ./node_modules/xml-utils/get-attribute.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function getAttribute(tag, attributeName, options) {\n  const debug = (options && options.debug) || false;\n  if (debug) console.log(\"[xml-utils] getting \" + attributeName + \" in \" + tag);\n\n  const xml = typeof tag === \"object\" ? tag.outer : tag;\n\n  // only search for attributes in the opening tag\n  const opening = xml.slice(0, xml.indexOf(\">\") + 1);\n\n  const quotechars = ['\"', \"'\"];\n  for (let i = 0; i < quotechars.length; i++) {\n    const char = quotechars[i];\n    const pattern = attributeName + \"\\\\=\" + char + \"([^\" + char + \"]*)\" + char;\n    if (debug) console.log(\"[xml-utils] pattern:\", pattern);\n\n    const re = new RegExp(pattern);\n    const match = re.exec(opening);\n    if (debug) console.log(\"[xml-utils] match:\", match);\n    if (match) return match[1];\n  }\n}\n\nmodule.exports = getAttribute;\nmodule.exports[\"default\"] = getAttribute;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy94bWwtdXRpbHMvZ2V0LWF0dHJpYnV0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2dldC1hdHRyaWJ1dGUuanM/ZTEzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBnZXRBdHRyaWJ1dGUodGFnLCBhdHRyaWJ1dGVOYW1lLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRlYnVnID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1ZykgfHwgZmFsc2U7XG4gIGlmIChkZWJ1ZykgY29uc29sZS5sb2coXCJbeG1sLXV0aWxzXSBnZXR0aW5nIFwiICsgYXR0cmlidXRlTmFtZSArIFwiIGluIFwiICsgdGFnKTtcblxuICBjb25zdCB4bWwgPSB0eXBlb2YgdGFnID09PSBcIm9iamVjdFwiID8gdGFnLm91dGVyIDogdGFnO1xuXG4gIC8vIG9ubHkgc2VhcmNoIGZvciBhdHRyaWJ1dGVzIGluIHRoZSBvcGVuaW5nIHRhZ1xuICBjb25zdCBvcGVuaW5nID0geG1sLnNsaWNlKDAsIHhtbC5pbmRleE9mKFwiPlwiKSArIDEpO1xuXG4gIGNvbnN0IHF1b3RlY2hhcnMgPSBbJ1wiJywgXCInXCJdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHF1b3RlY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gcXVvdGVjaGFyc1tpXTtcbiAgICBjb25zdCBwYXR0ZXJuID0gYXR0cmlidXRlTmFtZSArIFwiXFxcXD1cIiArIGNoYXIgKyBcIihbXlwiICsgY2hhciArIFwiXSopXCIgKyBjaGFyO1xuICAgIGlmIChkZWJ1ZykgY29uc29sZS5sb2coXCJbeG1sLXV0aWxzXSBwYXR0ZXJuOlwiLCBwYXR0ZXJuKTtcblxuICAgIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChwYXR0ZXJuKTtcbiAgICBjb25zdCBtYXRjaCA9IHJlLmV4ZWMob3BlbmluZyk7XG4gICAgaWYgKGRlYnVnKSBjb25zb2xlLmxvZyhcIlt4bWwtdXRpbHNdIG1hdGNoOlwiLCBtYXRjaCk7XG4gICAgaWYgKG1hdGNoKSByZXR1cm4gbWF0Y2hbMV07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBdHRyaWJ1dGU7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0QXR0cmlidXRlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/xml-utils/get-attribute.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/xml-utils/index-of-match-end.js":
/*!******************************************************!*\
  !*** ./node_modules/xml-utils/index-of-match-end.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function indexOfMatchEnd(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index + match[0].length - 1;\n  else return -1;\n}\n\nmodule.exports = indexOfMatchEnd;\nmodule.exports[\"default\"] = indexOfMatchEnd;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy94bWwtdXRpbHMvaW5kZXgtb2YtbWF0Y2gtZW5kLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2luZGV4LW9mLW1hdGNoLWVuZC5qcz85MTAxIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGluZGV4T2ZNYXRjaEVuZCh4bWwsIHBhdHRlcm4sIHN0YXJ0SW5kZXgpIHtcbiAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKHBhdHRlcm4pO1xuICBjb25zdCBtYXRjaCA9IHJlLmV4ZWMoeG1sLnNsaWNlKHN0YXJ0SW5kZXgpKTtcbiAgaWYgKG1hdGNoKSByZXR1cm4gc3RhcnRJbmRleCArIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIC0gMTtcbiAgZWxzZSByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5kZXhPZk1hdGNoRW5kO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGluZGV4T2ZNYXRjaEVuZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/xml-utils/index-of-match-end.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/xml-utils/index-of-match.js":
/*!**************************************************!*\
  !*** ./node_modules/xml-utils/index-of-match.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function indexOfMatch(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index;\n  else return -1;\n}\n\nmodule.exports = indexOfMatch;\nmodule.exports[\"default\"] = indexOfMatch;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy94bWwtdXRpbHMvaW5kZXgtb2YtbWF0Y2guanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy94bWwtdXRpbHMvaW5kZXgtb2YtbWF0Y2guanM/MzliYiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBpbmRleE9mTWF0Y2goeG1sLCBwYXR0ZXJuLCBzdGFydEluZGV4KSB7XG4gIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChwYXR0ZXJuKTtcbiAgY29uc3QgbWF0Y2ggPSByZS5leGVjKHhtbC5zbGljZShzdGFydEluZGV4KSk7XG4gIGlmIChtYXRjaCkgcmV0dXJuIHN0YXJ0SW5kZXggKyBtYXRjaC5pbmRleDtcbiAgZWxzZSByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5kZXhPZk1hdGNoO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGluZGV4T2ZNYXRjaDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/xml-utils/index-of-match.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/RadarOverlay.tsx":
/*!*****************************************!*\
  !*** ./src/components/RadarOverlay.tsx ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ RadarOverlay; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_leaflet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-leaflet */ \"(app-pages-browser)/./node_modules/react-leaflet/lib/hooks.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! leaflet */ \"(app-pages-browser)/./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var geotiff__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! geotiff */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/geotiff.js\");\n/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fflate */ \"(app-pages-browser)/./node_modules/fflate/esm/browser.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ var _s = $RefreshSig$();\n\n\n\n\n\nasync function fetchLatestMeta() {\n    const res = await fetch(\"/api/radar/latest?ts=\".concat(Date.now()), {\n        cache: \"no-store\"\n    });\n    if (!res.ok) throw new Error(\"Failed to load latest MRMS meta\");\n    return res.json();\n}\nasync function fetchArrayBuffer(url) {\n    const bust = url.includes(\"?\") ? \"&ts=\".concat(Date.now()) : \"?ts=\".concat(Date.now());\n    const res = await fetch(url + bust, {\n        cache: \"no-store\"\n    });\n    if (!res.ok) throw new Error(\"Failed to fetch data: \".concat(res.status));\n    return await res.arrayBuffer();\n}\nfunction RadarOverlay() {\n    _s();\n    const map = (0,react_leaflet__WEBPACK_IMPORTED_MODULE_2__.useMap)();\n    const overlayRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [lastUpdated, setLastUpdated] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const refreshIntervalMs = 2 * 60 * 1000; // ~2 minutes\n    const boundsToLatLngBounds = (b)=>leaflet__WEBPACK_IMPORTED_MODULE_1___default().latLngBounds(leaflet__WEBPACK_IMPORTED_MODULE_1___default().latLng(b[0][0], b[0][1]), leaflet__WEBPACK_IMPORTED_MODULE_1___default().latLng(b[1][0], b[1][1]));\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let cancelled = false;\n        async function loadAndRender() {\n            try {\n                const meta = await fetchLatestMeta();\n                const arrayBuffer = await fetchArrayBuffer(meta.url);\n                const raw = meta.isGzip ? (0,fflate__WEBPACK_IMPORTED_MODULE_3__.gunzipSync)(new Uint8Array(arrayBuffer)).buffer : arrayBuffer;\n                // Attempt GeoTIFF decode; if fails, just display image as-is\n                let blobUrl = null;\n                try {\n                    const tiff = await (0,geotiff__WEBPACK_IMPORTED_MODULE_4__.fromArrayBuffer)(raw);\n                    const image = await tiff.getImage();\n                    const width = image.getWidth();\n                    const height = image.getHeight();\n                    const rasters = await image.readRasters({\n                        interleave: true\n                    });\n                    const canvas = document.createElement(\"canvas\");\n                    canvas.width = width;\n                    canvas.height = height;\n                    const ctx = canvas.getContext(\"2d\");\n                    if (!ctx) throw new Error(\"No canvas context\");\n                    // Simple reflectivity color scale (dBZ). Adjust as needed.\n                    const toRGBA = (v)=>{\n                        // Assume value in dBZ 0..75; NaN/noData mapped to transparent\n                        if (!Number.isFinite(v) || v < 0) return [\n                            0,\n                            0,\n                            0,\n                            0\n                        ];\n                        const stops = [\n                            {\n                                v: 5,\n                                c: [\n                                    4,\n                                    233,\n                                    231\n                                ]\n                            },\n                            {\n                                v: 20,\n                                c: [\n                                    1,\n                                    159,\n                                    244\n                                ]\n                            },\n                            {\n                                v: 30,\n                                c: [\n                                    3,\n                                    0,\n                                    244\n                                ]\n                            },\n                            {\n                                v: 40,\n                                c: [\n                                    2,\n                                    253,\n                                    2\n                                ]\n                            },\n                            {\n                                v: 45,\n                                c: [\n                                    1,\n                                    197,\n                                    1\n                                ]\n                            },\n                            {\n                                v: 50,\n                                c: [\n                                    0,\n                                    142,\n                                    0\n                                ]\n                            },\n                            {\n                                v: 55,\n                                c: [\n                                    253,\n                                    248,\n                                    2\n                                ]\n                            },\n                            {\n                                v: 60,\n                                c: [\n                                    229,\n                                    188,\n                                    0\n                                ]\n                            },\n                            {\n                                v: 65,\n                                c: [\n                                    253,\n                                    149,\n                                    0\n                                ]\n                            },\n                            {\n                                v: 70,\n                                c: [\n                                    253,\n                                    0,\n                                    0\n                                ]\n                            },\n                            {\n                                v: 75,\n                                c: [\n                                    153,\n                                    0,\n                                    0\n                                ]\n                            }\n                        ];\n                        let color = [\n                            0,\n                            0,\n                            0\n                        ];\n                        for(let i = 0; i < stops.length; i++){\n                            if (v <= stops[i].v) {\n                                color = stops[i].c;\n                                break;\n                            }\n                            if (i === stops.length - 1) color = stops[i].c;\n                        }\n                        return [\n                            ...color,\n                            200\n                        ];\n                    };\n                    const imgData = ctx.createImageData(width, height);\n                    const data = imgData.data;\n                    if (rasters instanceof Float32Array || rasters instanceof Uint16Array) {\n                        // Single-band float/uint16 assumed\n                        for(let i = 0; i < rasters.length; i++){\n                            const [r, g, b, a] = toRGBA(Number(rasters[i]));\n                            const j = i * 4;\n                            data[j] = r;\n                            data[j + 1] = g;\n                            data[j + 2] = b;\n                            data[j + 3] = a;\n                        }\n                    } else {\n                        // If already RGB(A) interleaved, copy\n                        for(let i = 0, j = 0; i < data.length && j < rasters.length; i += 4, j += 4){\n                            data[i] = rasters[j];\n                            data[i + 1] = rasters[j + 1] || rasters[j];\n                            data[i + 2] = rasters[j + 2] || rasters[j];\n                            var _rasters_;\n                            data[i + 3] = (_rasters_ = rasters[j + 3]) !== null && _rasters_ !== void 0 ? _rasters_ : 200;\n                        }\n                    }\n                    ctx.putImageData(imgData, 0, 0);\n                    blobUrl = canvas.toDataURL(\"image/png\");\n                } catch (e) {\n                    // Fallback: assume the URL is a directly usable image\n                    blobUrl = meta.url;\n                }\n                if (cancelled) return;\n                // Replace overlay\n                const bounds = boundsToLatLngBounds(meta.bounds);\n                const newOverlay = leaflet__WEBPACK_IMPORTED_MODULE_1___default().imageOverlay(blobUrl, bounds, {\n                    opacity: 0.8,\n                    interactive: false,\n                    zIndex: 500\n                });\n                if (overlayRef.current) {\n                    overlayRef.current.remove();\n                }\n                overlayRef.current = newOverlay.addTo(map);\n                setLastUpdated(Date.now());\n            } catch (e) {\n                // eslint-disable-next-line no-console\n                console.error(e);\n            }\n        }\n        loadAndRender();\n        const id = setInterval(loadAndRender, refreshIntervalMs);\n        return ()=>{\n            cancelled = true;\n            clearInterval(id);\n        };\n    }, [\n        map\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            if (overlayRef.current) overlayRef.current.remove();\n        };\n    }, []);\n    return null;\n}\n_s(RadarOverlay, \"YSep+IoWTI9XNE+wGbrRv4vmM38=\", false, function() {\n    return [\n        react_leaflet__WEBPACK_IMPORTED_MODULE_2__.useMap\n    ];\n});\n_c = RadarOverlay;\nvar _c;\n$RefreshReg$(_c, \"RadarOverlay\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1JhZGFyT3ZlcmxheS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRTZEO0FBQ3RCO0FBQ2Y7QUFDa0I7QUFDTjtBQVFwQyxlQUFlTztJQUNiLE1BQU1DLE1BQU0sTUFBTUMsTUFBTSx3QkFBbUMsT0FBWEMsS0FBS0MsR0FBRyxLQUFNO1FBQUVDLE9BQU87SUFBVztJQUNsRixJQUFJLENBQUNKLElBQUlLLEVBQUUsRUFBRSxNQUFNLElBQUlDLE1BQU07SUFDN0IsT0FBT04sSUFBSU8sSUFBSTtBQUNqQjtBQUVBLGVBQWVDLGlCQUFpQkMsR0FBVztJQUN6QyxNQUFNQyxPQUFPRCxJQUFJRSxRQUFRLENBQUMsT0FBTyxPQUFrQixPQUFYVCxLQUFLQyxHQUFHLE1BQU8sT0FBa0IsT0FBWEQsS0FBS0MsR0FBRztJQUN0RSxNQUFNSCxNQUFNLE1BQU1DLE1BQU1RLE1BQU1DLE1BQU07UUFBRU4sT0FBTztJQUFXO0lBQ3hELElBQUksQ0FBQ0osSUFBSUssRUFBRSxFQUFFLE1BQU0sSUFBSUMsTUFBTSx5QkFBb0MsT0FBWE4sSUFBSVksTUFBTTtJQUNoRSxPQUFPLE1BQU1aLElBQUlhLFdBQVc7QUFDOUI7QUFFZSxTQUFTQzs7SUFDdEIsTUFBTUMsTUFBTXBCLHFEQUFNQTtJQUNsQixNQUFNcUIsYUFBYXZCLDZDQUFNQSxDQUF3QjtJQUNqRCxNQUFNLENBQUN3QixhQUFhQyxlQUFlLEdBQUd4QiwrQ0FBUUEsQ0FBUztJQUV2RCxNQUFNeUIsb0JBQW9CLElBQUksS0FBSyxNQUFNLGFBQWE7SUFFdEQsTUFBTUMsdUJBQXVCLENBQUNDLElBQzVCekIsMkRBQWMsQ0FBQ0EscURBQVEsQ0FBQ3lCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFQSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBR3pCLHFEQUFRLENBQUN5QixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRUEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO0lBRXRFN0IsZ0RBQVNBLENBQUM7UUFDUixJQUFJZ0MsWUFBWTtRQUVoQixlQUFlQztZQUNiLElBQUk7Z0JBQ0YsTUFBTUMsT0FBTyxNQUFNM0I7Z0JBQ25CLE1BQU1jLGNBQWMsTUFBTUwsaUJBQWlCa0IsS0FBS2pCLEdBQUc7Z0JBQ25ELE1BQU1rQixNQUFNRCxLQUFLRSxNQUFNLEdBQUc5QixrREFBVUEsQ0FBQyxJQUFJK0IsV0FBV2hCLGNBQWNpQixNQUFNLEdBQUdqQjtnQkFFM0UsNkRBQTZEO2dCQUM3RCxJQUFJa0IsVUFBeUI7Z0JBQzdCLElBQUk7b0JBQ0YsTUFBTUMsT0FBTyxNQUFNbkMsd0RBQWVBLENBQUM4QjtvQkFDbkMsTUFBTU0sUUFBUSxNQUFNRCxLQUFLRSxRQUFRO29CQUNqQyxNQUFNQyxRQUFRRixNQUFNRyxRQUFRO29CQUM1QixNQUFNQyxTQUFTSixNQUFNSyxTQUFTO29CQUM5QixNQUFNQyxVQUFXLE1BQU1OLE1BQU1PLFdBQVcsQ0FBQzt3QkFBRUMsWUFBWTtvQkFBSztvQkFFNUQsTUFBTUMsU0FBU0MsU0FBU0MsYUFBYSxDQUFDO29CQUN0Q0YsT0FBT1AsS0FBSyxHQUFHQTtvQkFDZk8sT0FBT0wsTUFBTSxHQUFHQTtvQkFDaEIsTUFBTVEsTUFBTUgsT0FBT0ksVUFBVSxDQUFDO29CQUM5QixJQUFJLENBQUNELEtBQUssTUFBTSxJQUFJdkMsTUFBTTtvQkFFMUIsMkRBQTJEO29CQUMzRCxNQUFNeUMsU0FBUyxDQUFDQzt3QkFDZCw4REFBOEQ7d0JBQzlELElBQUksQ0FBQ0MsT0FBT0MsUUFBUSxDQUFDRixNQUFNQSxJQUFJLEdBQUcsT0FBTzs0QkFBQzs0QkFBRzs0QkFBRzs0QkFBRzt5QkFBRTt3QkFDckQsTUFBTUcsUUFBUTs0QkFDWjtnQ0FBRUgsR0FBRztnQ0FBR0ksR0FBRztvQ0FBQztvQ0FBRztvQ0FBSztpQ0FBSTs0QkFBQzs0QkFDekI7Z0NBQUVKLEdBQUc7Z0NBQUlJLEdBQUc7b0NBQUM7b0NBQUc7b0NBQUs7aUNBQUk7NEJBQUM7NEJBQzFCO2dDQUFFSixHQUFHO2dDQUFJSSxHQUFHO29DQUFDO29DQUFHO29DQUFHO2lDQUFJOzRCQUFDOzRCQUN4QjtnQ0FBRUosR0FBRztnQ0FBSUksR0FBRztvQ0FBQztvQ0FBRztvQ0FBSztpQ0FBRTs0QkFBQzs0QkFDeEI7Z0NBQUVKLEdBQUc7Z0NBQUlJLEdBQUc7b0NBQUM7b0NBQUc7b0NBQUs7aUNBQUU7NEJBQUM7NEJBQ3hCO2dDQUFFSixHQUFHO2dDQUFJSSxHQUFHO29DQUFDO29DQUFHO29DQUFLO2lDQUFFOzRCQUFDOzRCQUN4QjtnQ0FBRUosR0FBRztnQ0FBSUksR0FBRztvQ0FBQztvQ0FBSztvQ0FBSztpQ0FBRTs0QkFBQzs0QkFDMUI7Z0NBQUVKLEdBQUc7Z0NBQUlJLEdBQUc7b0NBQUM7b0NBQUs7b0NBQUs7aUNBQUU7NEJBQUM7NEJBQzFCO2dDQUFFSixHQUFHO2dDQUFJSSxHQUFHO29DQUFDO29DQUFLO29DQUFLO2lDQUFFOzRCQUFDOzRCQUMxQjtnQ0FBRUosR0FBRztnQ0FBSUksR0FBRztvQ0FBQztvQ0FBSztvQ0FBRztpQ0FBRTs0QkFBQzs0QkFDeEI7Z0NBQUVKLEdBQUc7Z0NBQUlJLEdBQUc7b0NBQUM7b0NBQUs7b0NBQUc7aUNBQUU7NEJBQUM7eUJBQ3pCO3dCQUNELElBQUlDLFFBQVE7NEJBQUM7NEJBQUc7NEJBQUc7eUJBQUU7d0JBQ3JCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSCxNQUFNSSxNQUFNLEVBQUVELElBQUs7NEJBQ3JDLElBQUlOLEtBQUtHLEtBQUssQ0FBQ0csRUFBRSxDQUFDTixDQUFDLEVBQUU7Z0NBQUVLLFFBQVFGLEtBQUssQ0FBQ0csRUFBRSxDQUFDRixDQUFDO2dDQUFFOzRCQUFPOzRCQUNsRCxJQUFJRSxNQUFNSCxNQUFNSSxNQUFNLEdBQUcsR0FBR0YsUUFBUUYsS0FBSyxDQUFDRyxFQUFFLENBQUNGLENBQUM7d0JBQ2hEO3dCQUNBLE9BQU87K0JBQUlDOzRCQUFPO3lCQUFJO29CQUN4QjtvQkFFQSxNQUFNRyxVQUFVWCxJQUFJWSxlQUFlLENBQUN0QixPQUFPRTtvQkFDM0MsTUFBTXFCLE9BQU9GLFFBQVFFLElBQUk7b0JBRXpCLElBQUluQixtQkFBbUJvQixnQkFBZ0JwQixtQkFBbUJxQixhQUFhO3dCQUNyRSxtQ0FBbUM7d0JBQ25DLElBQUssSUFBSU4sSUFBSSxHQUFHQSxJQUFJZixRQUFRZ0IsTUFBTSxFQUFFRCxJQUFLOzRCQUN2QyxNQUFNLENBQUNPLEdBQUdDLEdBQUd6QyxHQUFHMEMsRUFBRSxHQUFHaEIsT0FBT0UsT0FBT1YsT0FBTyxDQUFDZSxFQUFFOzRCQUM3QyxNQUFNVSxJQUFJVixJQUFJOzRCQUNkSSxJQUFJLENBQUNNLEVBQUUsR0FBR0g7NEJBQUdILElBQUksQ0FBQ00sSUFBSSxFQUFFLEdBQUdGOzRCQUFHSixJQUFJLENBQUNNLElBQUksRUFBRSxHQUFHM0M7NEJBQUdxQyxJQUFJLENBQUNNLElBQUksRUFBRSxHQUFHRDt3QkFDL0Q7b0JBQ0YsT0FBTzt3QkFDTCxzQ0FBc0M7d0JBQ3RDLElBQUssSUFBSVQsSUFBSSxHQUFHVSxJQUFJLEdBQUdWLElBQUlJLEtBQUtILE1BQU0sSUFBSVMsSUFBSXpCLFFBQVFnQixNQUFNLEVBQUVELEtBQUssR0FBR1UsS0FBSyxFQUFHOzRCQUM1RU4sSUFBSSxDQUFDSixFQUFFLEdBQUdmLE9BQU8sQ0FBQ3lCLEVBQUU7NEJBQ3BCTixJQUFJLENBQUNKLElBQUksRUFBRSxHQUFHZixPQUFPLENBQUN5QixJQUFJLEVBQUUsSUFBSXpCLE9BQU8sQ0FBQ3lCLEVBQUU7NEJBQzFDTixJQUFJLENBQUNKLElBQUksRUFBRSxHQUFHZixPQUFPLENBQUN5QixJQUFJLEVBQUUsSUFBSXpCLE9BQU8sQ0FBQ3lCLEVBQUU7Z0NBQzVCekI7NEJBQWRtQixJQUFJLENBQUNKLElBQUksRUFBRSxHQUFHZixDQUFBQSxZQUFBQSxPQUFPLENBQUN5QixJQUFJLEVBQUUsY0FBZHpCLHVCQUFBQSxZQUFrQjt3QkFDbEM7b0JBQ0Y7b0JBRUFNLElBQUlvQixZQUFZLENBQUNULFNBQVMsR0FBRztvQkFDN0J6QixVQUFVVyxPQUFPd0IsU0FBUyxDQUFDO2dCQUM3QixFQUFFLFVBQU07b0JBQ04sc0RBQXNEO29CQUN0RG5DLFVBQVVMLEtBQUtqQixHQUFHO2dCQUNwQjtnQkFFQSxJQUFJZSxXQUFXO2dCQUVmLGtCQUFrQjtnQkFDbEIsTUFBTTJDLFNBQVMvQyxxQkFBcUJNLEtBQUt5QyxNQUFNO2dCQUMvQyxNQUFNQyxhQUFheEUsMkRBQWMsQ0FBQ21DLFNBQVVvQyxRQUFRO29CQUFFRyxTQUFTO29CQUFLQyxhQUFhO29CQUFPQyxRQUFRO2dCQUFJO2dCQUNwRyxJQUFJeEQsV0FBV3lELE9BQU8sRUFBRTtvQkFDdEJ6RCxXQUFXeUQsT0FBTyxDQUFDQyxNQUFNO2dCQUMzQjtnQkFDQTFELFdBQVd5RCxPQUFPLEdBQUdMLFdBQVdPLEtBQUssQ0FBQzVEO2dCQUN0Q0csZUFBZWhCLEtBQUtDLEdBQUc7WUFDekIsRUFBRSxPQUFPeUUsR0FBRztnQkFDVixzQ0FBc0M7Z0JBQ3RDQyxRQUFRQyxLQUFLLENBQUNGO1lBQ2hCO1FBQ0Y7UUFFQW5EO1FBQ0EsTUFBTXNELEtBQUtDLFlBQVl2RCxlQUFlTjtRQUN0QyxPQUFPO1lBQVFLLFlBQVk7WUFBTXlELGNBQWNGO1FBQUs7SUFDdEQsR0FBRztRQUFDaEU7S0FBSTtJQUVSdkIsZ0RBQVNBLENBQUM7UUFDUixPQUFPO1lBQ0wsSUFBSXdCLFdBQVd5RCxPQUFPLEVBQUV6RCxXQUFXeUQsT0FBTyxDQUFDQyxNQUFNO1FBQ25EO0lBQ0YsR0FBRyxFQUFFO0lBRUwsT0FBTztBQUNUO0dBbEh3QjVEOztRQUNWbkIsaURBQU1BOzs7S0FESW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL1JhZGFyT3ZlcmxheS50c3g/OGEzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcclxuXHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgdXNlTWFwIH0gZnJvbSAncmVhY3QtbGVhZmxldCc7XHJcbmltcG9ydCBMIGZyb20gJ2xlYWZsZXQnO1xyXG5pbXBvcnQgeyBmcm9tQXJyYXlCdWZmZXIgfSBmcm9tICdnZW90aWZmJztcclxuaW1wb3J0IHsgZ3VuemlwU3luYyB9IGZyb20gJ2ZmbGF0ZSc7XHJcblxyXG50eXBlIExhdGVzdE1ldGEgPSB7XHJcbiAgdXJsOiBzdHJpbmc7XHJcbiAgYm91bmRzOiBbW251bWJlciwgbnVtYmVyXSwgW251bWJlciwgbnVtYmVyXV07IC8vIFtbc291dGgsIHdlc3RdLCBbbm9ydGgsIGVhc3RdXVxyXG4gIGlzR3ppcDogYm9vbGVhbjtcclxufTtcclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGZldGNoTGF0ZXN0TWV0YSgpOiBQcm9taXNlPExhdGVzdE1ldGE+IHtcclxuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgL2FwaS9yYWRhci9sYXRlc3Q/dHM9JHtEYXRlLm5vdygpfWAsIHsgY2FjaGU6ICduby1zdG9yZScgfSk7XHJcbiAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgbGF0ZXN0IE1STVMgbWV0YScpO1xyXG4gIHJldHVybiByZXMuanNvbigpO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBmZXRjaEFycmF5QnVmZmVyKHVybDogc3RyaW5nKTogUHJvbWlzZTxBcnJheUJ1ZmZlcj4ge1xyXG4gIGNvbnN0IGJ1c3QgPSB1cmwuaW5jbHVkZXMoJz8nKSA/IGAmdHM9JHtEYXRlLm5vdygpfWAgOiBgP3RzPSR7RGF0ZS5ub3coKX1gO1xyXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybCArIGJ1c3QsIHsgY2FjaGU6ICduby1zdG9yZScgfSk7XHJcbiAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIGRhdGE6ICR7cmVzLnN0YXR1c31gKTtcclxuICByZXR1cm4gYXdhaXQgcmVzLmFycmF5QnVmZmVyKCk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJhZGFyT3ZlcmxheSgpIHtcclxuICBjb25zdCBtYXAgPSB1c2VNYXAoKTtcclxuICBjb25zdCBvdmVybGF5UmVmID0gdXNlUmVmPEwuSW1hZ2VPdmVybGF5IHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgW2xhc3RVcGRhdGVkLCBzZXRMYXN0VXBkYXRlZF0gPSB1c2VTdGF0ZTxudW1iZXI+KDApO1xyXG5cclxuICBjb25zdCByZWZyZXNoSW50ZXJ2YWxNcyA9IDIgKiA2MCAqIDEwMDA7IC8vIH4yIG1pbnV0ZXNcclxuXHJcbiAgY29uc3QgYm91bmRzVG9MYXRMbmdCb3VuZHMgPSAoYjogTGF0ZXN0TWV0YVsnYm91bmRzJ10pID0+XHJcbiAgICBMLmxhdExuZ0JvdW5kcyhMLmxhdExuZyhiWzBdWzBdLCBiWzBdWzFdKSwgTC5sYXRMbmcoYlsxXVswXSwgYlsxXVsxXSkpO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xyXG5cclxuICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRBbmRSZW5kZXIoKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgbWV0YSA9IGF3YWl0IGZldGNoTGF0ZXN0TWV0YSgpO1xyXG4gICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgZmV0Y2hBcnJheUJ1ZmZlcihtZXRhLnVybCk7XHJcbiAgICAgICAgY29uc3QgcmF3ID0gbWV0YS5pc0d6aXAgPyBndW56aXBTeW5jKG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSkuYnVmZmVyIDogYXJyYXlCdWZmZXI7XHJcblxyXG4gICAgICAgIC8vIEF0dGVtcHQgR2VvVElGRiBkZWNvZGU7IGlmIGZhaWxzLCBqdXN0IGRpc3BsYXkgaW1hZ2UgYXMtaXNcclxuICAgICAgICBsZXQgYmxvYlVybDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHRpZmYgPSBhd2FpdCBmcm9tQXJyYXlCdWZmZXIocmF3KTtcclxuICAgICAgICAgIGNvbnN0IGltYWdlID0gYXdhaXQgdGlmZi5nZXRJbWFnZSgpO1xyXG4gICAgICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZS5nZXRXaWR0aCgpO1xyXG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgICBjb25zdCByYXN0ZXJzID0gKGF3YWl0IGltYWdlLnJlYWRSYXN0ZXJzKHsgaW50ZXJsZWF2ZTogdHJ1ZSB9KSkgYXMgVWludDhBcnJheSB8IFVpbnQxNkFycmF5IHwgRmxvYXQzMkFycmF5O1xyXG5cclxuICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICBpZiAoIWN0eCkgdGhyb3cgbmV3IEVycm9yKCdObyBjYW52YXMgY29udGV4dCcpO1xyXG5cclxuICAgICAgICAgIC8vIFNpbXBsZSByZWZsZWN0aXZpdHkgY29sb3Igc2NhbGUgKGRCWikuIEFkanVzdCBhcyBuZWVkZWQuXHJcbiAgICAgICAgICBjb25zdCB0b1JHQkEgPSAodjogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEFzc3VtZSB2YWx1ZSBpbiBkQlogMC4uNzU7IE5hTi9ub0RhdGEgbWFwcGVkIHRvIHRyYW5zcGFyZW50XHJcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHYpIHx8IHYgPCAwKSByZXR1cm4gWzAsIDAsIDAsIDBdO1xyXG4gICAgICAgICAgICBjb25zdCBzdG9wcyA9IFtcclxuICAgICAgICAgICAgICB7IHY6IDUsIGM6IFs0LCAyMzMsIDIzMV0gfSxcclxuICAgICAgICAgICAgICB7IHY6IDIwLCBjOiBbMSwgMTU5LCAyNDRdIH0sXHJcbiAgICAgICAgICAgICAgeyB2OiAzMCwgYzogWzMsIDAsIDI0NF0gfSxcclxuICAgICAgICAgICAgICB7IHY6IDQwLCBjOiBbMiwgMjUzLCAyXSB9LFxyXG4gICAgICAgICAgICAgIHsgdjogNDUsIGM6IFsxLCAxOTcsIDFdIH0sXHJcbiAgICAgICAgICAgICAgeyB2OiA1MCwgYzogWzAsIDE0MiwgMF0gfSxcclxuICAgICAgICAgICAgICB7IHY6IDU1LCBjOiBbMjUzLCAyNDgsIDJdIH0sXHJcbiAgICAgICAgICAgICAgeyB2OiA2MCwgYzogWzIyOSwgMTg4LCAwXSB9LFxyXG4gICAgICAgICAgICAgIHsgdjogNjUsIGM6IFsyNTMsIDE0OSwgMF0gfSxcclxuICAgICAgICAgICAgICB7IHY6IDcwLCBjOiBbMjUzLCAwLCAwXSB9LFxyXG4gICAgICAgICAgICAgIHsgdjogNzUsIGM6IFsxNTMsIDAsIDBdIH1cclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgbGV0IGNvbG9yID0gWzAsIDAsIDBdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0b3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHYgPD0gc3RvcHNbaV0udikgeyBjb2xvciA9IHN0b3BzW2ldLmM7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgaWYgKGkgPT09IHN0b3BzLmxlbmd0aCAtIDEpIGNvbG9yID0gc3RvcHNbaV0uYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gWy4uLmNvbG9yLCAyMDBdO1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICBjb25zdCBpbWdEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgIGNvbnN0IGRhdGEgPSBpbWdEYXRhLmRhdGE7XHJcblxyXG4gICAgICAgICAgaWYgKHJhc3RlcnMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHwgcmFzdGVycyBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KSB7XHJcbiAgICAgICAgICAgIC8vIFNpbmdsZS1iYW5kIGZsb2F0L3VpbnQxNiBhc3N1bWVkXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFzdGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIGNvbnN0IFtyLCBnLCBiLCBhXSA9IHRvUkdCQShOdW1iZXIocmFzdGVyc1tpXSkpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGogPSBpICogNDtcclxuICAgICAgICAgICAgICBkYXRhW2pdID0gcjsgZGF0YVtqICsgMV0gPSBnOyBkYXRhW2ogKyAyXSA9IGI7IGRhdGFbaiArIDNdID0gYTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSWYgYWxyZWFkeSBSR0IoQSkgaW50ZXJsZWF2ZWQsIGNvcHlcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgZGF0YS5sZW5ndGggJiYgaiA8IHJhc3RlcnMubGVuZ3RoOyBpICs9IDQsIGogKz0gNCkge1xyXG4gICAgICAgICAgICAgIGRhdGFbaV0gPSByYXN0ZXJzW2pdO1xyXG4gICAgICAgICAgICAgIGRhdGFbaSArIDFdID0gcmFzdGVyc1tqICsgMV0gfHwgcmFzdGVyc1tqXTtcclxuICAgICAgICAgICAgICBkYXRhW2kgKyAyXSA9IHJhc3RlcnNbaiArIDJdIHx8IHJhc3RlcnNbal07XHJcbiAgICAgICAgICAgICAgZGF0YVtpICsgM10gPSByYXN0ZXJzW2ogKyAzXSA/PyAyMDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGltZ0RhdGEsIDAsIDApO1xyXG4gICAgICAgICAgYmxvYlVybCA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xyXG4gICAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgICAgLy8gRmFsbGJhY2s6IGFzc3VtZSB0aGUgVVJMIGlzIGEgZGlyZWN0bHkgdXNhYmxlIGltYWdlXHJcbiAgICAgICAgICBibG9iVXJsID0gbWV0YS51cmw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIFJlcGxhY2Ugb3ZlcmxheVxyXG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IGJvdW5kc1RvTGF0TG5nQm91bmRzKG1ldGEuYm91bmRzKTtcclxuICAgICAgICBjb25zdCBuZXdPdmVybGF5ID0gTC5pbWFnZU92ZXJsYXkoYmxvYlVybCEsIGJvdW5kcywgeyBvcGFjaXR5OiAwLjgsIGludGVyYWN0aXZlOiBmYWxzZSwgekluZGV4OiA1MDAgfSk7XHJcbiAgICAgICAgaWYgKG92ZXJsYXlSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgb3ZlcmxheVJlZi5jdXJyZW50LnJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvdmVybGF5UmVmLmN1cnJlbnQgPSBuZXdPdmVybGF5LmFkZFRvKG1hcCk7XHJcbiAgICAgICAgc2V0TGFzdFVwZGF0ZWQoRGF0ZS5ub3coKSk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsb2FkQW5kUmVuZGVyKCk7XHJcbiAgICBjb25zdCBpZCA9IHNldEludGVydmFsKGxvYWRBbmRSZW5kZXIsIHJlZnJlc2hJbnRlcnZhbE1zKTtcclxuICAgIHJldHVybiAoKSA9PiB7IGNhbmNlbGxlZCA9IHRydWU7IGNsZWFySW50ZXJ2YWwoaWQpOyB9O1xyXG4gIH0sIFttYXBdKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGlmIChvdmVybGF5UmVmLmN1cnJlbnQpIG92ZXJsYXlSZWYuY3VycmVudC5yZW1vdmUoKTtcclxuICAgIH07XHJcbiAgfSwgW10pO1xyXG5cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuXHJcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZU1hcCIsIkwiLCJmcm9tQXJyYXlCdWZmZXIiLCJndW56aXBTeW5jIiwiZmV0Y2hMYXRlc3RNZXRhIiwicmVzIiwiZmV0Y2giLCJEYXRlIiwibm93IiwiY2FjaGUiLCJvayIsIkVycm9yIiwianNvbiIsImZldGNoQXJyYXlCdWZmZXIiLCJ1cmwiLCJidXN0IiwiaW5jbHVkZXMiLCJzdGF0dXMiLCJhcnJheUJ1ZmZlciIsIlJhZGFyT3ZlcmxheSIsIm1hcCIsIm92ZXJsYXlSZWYiLCJsYXN0VXBkYXRlZCIsInNldExhc3RVcGRhdGVkIiwicmVmcmVzaEludGVydmFsTXMiLCJib3VuZHNUb0xhdExuZ0JvdW5kcyIsImIiLCJsYXRMbmdCb3VuZHMiLCJsYXRMbmciLCJjYW5jZWxsZWQiLCJsb2FkQW5kUmVuZGVyIiwibWV0YSIsInJhdyIsImlzR3ppcCIsIlVpbnQ4QXJyYXkiLCJidWZmZXIiLCJibG9iVXJsIiwidGlmZiIsImltYWdlIiwiZ2V0SW1hZ2UiLCJ3aWR0aCIsImdldFdpZHRoIiwiaGVpZ2h0IiwiZ2V0SGVpZ2h0IiwicmFzdGVycyIsInJlYWRSYXN0ZXJzIiwiaW50ZXJsZWF2ZSIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImN0eCIsImdldENvbnRleHQiLCJ0b1JHQkEiLCJ2IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJzdG9wcyIsImMiLCJjb2xvciIsImkiLCJsZW5ndGgiLCJpbWdEYXRhIiwiY3JlYXRlSW1hZ2VEYXRhIiwiZGF0YSIsIkZsb2F0MzJBcnJheSIsIlVpbnQxNkFycmF5IiwiciIsImciLCJhIiwiaiIsInB1dEltYWdlRGF0YSIsInRvRGF0YVVSTCIsImJvdW5kcyIsIm5ld092ZXJsYXkiLCJpbWFnZU92ZXJsYXkiLCJvcGFjaXR5IiwiaW50ZXJhY3RpdmUiLCJ6SW5kZXgiLCJjdXJyZW50IiwicmVtb3ZlIiwiYWRkVG8iLCJlIiwiY29uc29sZSIsImVycm9yIiwiaWQiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/RadarOverlay.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@petamoriken/float16/src/DataView.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@petamoriken/float16/src/DataView.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFloat16: function() { return /* binding */ getFloat16; },\n/* harmony export */   setFloat16: function() { return /* binding */ setFloat16; }\n/* harmony export */ });\n/* harmony import */ var _util_arrayIterator_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_util/arrayIterator.mjs */ \"(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/arrayIterator.mjs\");\n/* harmony import */ var _util_converter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_util/converter.mjs */ \"(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/converter.mjs\");\n/* harmony import */ var _util_primordials_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_util/primordials.mjs */ \"(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/primordials.mjs\");\n\n\n\n\n/**\n * returns an unsigned 16-bit float at the specified byte offset from the start of the DataView\n * @param {DataView} dataView\n * @param {number} byteOffset\n * @param {[boolean]} opts\n * @returns {number}\n */\nfunction getFloat16(dataView, byteOffset, ...opts) {\n  return (0,_util_converter_mjs__WEBPACK_IMPORTED_MODULE_0__.convertToNumber)(\n    (0,_util_primordials_mjs__WEBPACK_IMPORTED_MODULE_1__.DataViewPrototypeGetUint16)(dataView, byteOffset, ...(0,_util_arrayIterator_mjs__WEBPACK_IMPORTED_MODULE_2__.safeIfNeeded)(opts))\n  );\n}\n\n/**\n * stores an unsigned 16-bit float value at the specified byte offset from the start of the DataView\n * @param {DataView} dataView\n * @param {number} byteOffset\n * @param {number} value\n * @param {[boolean]} opts\n */\nfunction setFloat16(dataView, byteOffset, value, ...opts) {\n  return (0,_util_primordials_mjs__WEBPACK_IMPORTED_MODULE_1__.DataViewPrototypeSetUint16)(\n    dataView,\n    byteOffset,\n    (0,_util_converter_mjs__WEBPACK_IMPORTED_MODULE_0__.roundToFloat16Bits)(value),\n    ...(0,_util_arrayIterator_mjs__WEBPACK_IMPORTED_MODULE_2__.safeIfNeeded)(opts)\n  );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGV0YW1vcmlrZW4vZmxvYXQxNi9zcmMvRGF0YVZpZXcubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXlEO0FBQ21CO0FBSTNDOztBQUVqQztBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFdBQVc7QUFDdEIsYUFBYTtBQUNiO0FBQ087QUFDUCxTQUFTLG9FQUFlO0FBQ3hCLElBQUksaUZBQTBCLDBCQUEwQixxRUFBWTtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFdBQVc7QUFDdEI7QUFDTztBQUNQLFNBQVMsaUZBQTBCO0FBQ25DO0FBQ0E7QUFDQSxJQUFJLHVFQUFrQjtBQUN0QixPQUFPLHFFQUFZO0FBQ25CO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BwZXRhbW9yaWtlbi9mbG9hdDE2L3NyYy9EYXRhVmlldy5tanM/NmVlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzYWZlSWZOZWVkZWQgfSBmcm9tIFwiLi9fdXRpbC9hcnJheUl0ZXJhdG9yLm1qc1wiO1xuaW1wb3J0IHsgY29udmVydFRvTnVtYmVyLCByb3VuZFRvRmxvYXQxNkJpdHMgfSBmcm9tIFwiLi9fdXRpbC9jb252ZXJ0ZXIubWpzXCI7XG5pbXBvcnQge1xuICBEYXRhVmlld1Byb3RvdHlwZUdldFVpbnQxNixcbiAgRGF0YVZpZXdQcm90b3R5cGVTZXRVaW50MTYsXG59IGZyb20gXCIuL191dGlsL3ByaW1vcmRpYWxzLm1qc1wiO1xuXG4vKipcbiAqIHJldHVybnMgYW4gdW5zaWduZWQgMTYtYml0IGZsb2F0IGF0IHRoZSBzcGVjaWZpZWQgYnl0ZSBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIERhdGFWaWV3XG4gKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhVmlld1xuICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVPZmZzZXRcbiAqIEBwYXJhbSB7W2Jvb2xlYW5dfSBvcHRzXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmxvYXQxNihkYXRhVmlldywgYnl0ZU9mZnNldCwgLi4ub3B0cykge1xuICByZXR1cm4gY29udmVydFRvTnVtYmVyKFxuICAgIERhdGFWaWV3UHJvdG90eXBlR2V0VWludDE2KGRhdGFWaWV3LCBieXRlT2Zmc2V0LCAuLi5zYWZlSWZOZWVkZWQob3B0cykpXG4gICk7XG59XG5cbi8qKlxuICogc3RvcmVzIGFuIHVuc2lnbmVkIDE2LWJpdCBmbG9hdCB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIGJ5dGUgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBEYXRhVmlld1xuICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVZpZXdcbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlT2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7W2Jvb2xlYW5dfSBvcHRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRGbG9hdDE2KGRhdGFWaWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgLi4ub3B0cykge1xuICByZXR1cm4gRGF0YVZpZXdQcm90b3R5cGVTZXRVaW50MTYoXG4gICAgZGF0YVZpZXcsXG4gICAgYnl0ZU9mZnNldCxcbiAgICByb3VuZFRvRmxvYXQxNkJpdHModmFsdWUpLFxuICAgIC4uLnNhZmVJZk5lZWRlZChvcHRzKVxuICApO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@petamoriken/float16/src/DataView.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/arrayIterator.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@petamoriken/float16/src/_util/arrayIterator.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   safeIfNeeded: function() { return /* binding */ safeIfNeeded; },\n/* harmony export */   wrap: function() { return /* binding */ wrap; }\n/* harmony export */ });\n/* harmony import */ var _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./primordials.mjs */ \"(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/primordials.mjs\");\n\n\n/** @type {WeakMap<{}, IterableIterator<any>>} */\nconst arrayIterators = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeWeakMap();\n\nconst SafeIteratorPrototype = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ObjectCreate)(null, {\n  next: {\n    value: function next() {\n      const arrayIterator = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.WeakMapPrototypeGet)(arrayIterators, this);\n      return (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayIteratorPrototypeNext)(arrayIterator);\n    },\n  },\n\n  [_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.SymbolIterator]: {\n    value: function values() {\n      return this;\n    },\n  },\n});\n\n/**\n * Wrap the Array around the SafeIterator If Array.prototype [@@iterator] has been modified\n * @type {<T>(array: T[]) => Iterable<T>}\n */\nfunction safeIfNeeded(array) {\n  if (\n    array[_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.SymbolIterator] === _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeArrayPrototypeSymbolIterator &&\n    _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayIteratorPrototype.next === _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayIteratorPrototypeNext\n  ) {\n    return array;\n  }\n\n  const safe = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ObjectCreate)(SafeIteratorPrototype);\n  (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.WeakMapPrototypeSet)(arrayIterators, safe, (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayPrototypeSymbolIterator)(array));\n  return safe;\n}\n\n/** @type {WeakMap<{}, Generator<any>>} */\nconst generators = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeWeakMap();\n\n/** @see https://tc39.es/ecma262/#sec-%arrayiteratorprototype%-object */\nconst DummyArrayIteratorPrototype = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ObjectCreate)(_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.IteratorPrototype, {\n  next: {\n    value: function next() {\n      const generator = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.WeakMapPrototypeGet)(generators, this);\n      return (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.GeneratorPrototypeNext)(generator);\n    },\n    writable: true,\n    configurable: true,\n  },\n});\n\nfor (const key of (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ReflectOwnKeys)(_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayIteratorPrototype)) {\n  // next method has already defined\n  if (key === \"next\") {\n    continue;\n  }\n\n  // Copy ArrayIteratorPrototype descriptors to DummyArrayIteratorPrototype\n  (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ObjectDefineProperty)(DummyArrayIteratorPrototype, key, (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ReflectGetOwnPropertyDescriptor)(_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayIteratorPrototype, key));\n}\n\n/**\n * Wrap the Generator around the dummy ArrayIterator\n * @type {<T>(generator: Generator<T>) => IterableIterator<T>}\n */\nfunction wrap(generator) {\n  const dummy = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ObjectCreate)(DummyArrayIteratorPrototype);\n  (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.WeakMapPrototypeSet)(generators, dummy, generator);\n  return dummy;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGV0YW1vcmlrZW4vZmxvYXQxNi9zcmMvX3V0aWwvYXJyYXlJdGVyYXRvci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBZTJCOztBQUUzQixXQUFXLFVBQVUsMEJBQTBCO0FBQy9DLDJCQUEyQiwyREFBYTs7QUFFeEMsOEJBQThCLDhEQUFZO0FBQzFDO0FBQ0E7QUFDQSw0QkFBNEIscUVBQW1CO0FBQy9DLGFBQWEsNEVBQTBCO0FBQ3ZDLEtBQUs7QUFDTCxHQUFHOztBQUVILEdBQUcsNERBQWM7QUFDakI7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087QUFDUDtBQUNBLFVBQVUsNERBQWMsTUFBTSxnRkFBa0M7QUFDaEUsSUFBSSxvRUFBc0IsVUFBVSx3RUFBMEI7QUFDOUQ7QUFDQTtBQUNBOztBQUVBLGVBQWUsOERBQVk7QUFDM0IsRUFBRSxxRUFBbUIsdUJBQXVCLDhFQUE0QjtBQUN4RTtBQUNBOztBQUVBLFdBQVcsVUFBVSxtQkFBbUI7QUFDeEMsdUJBQXVCLDJEQUFhOztBQUVwQztBQUNBLG9DQUFvQyw4REFBWSxDQUFDLCtEQUFpQjtBQUNsRTtBQUNBO0FBQ0Esd0JBQXdCLHFFQUFtQjtBQUMzQyxhQUFhLHdFQUFzQjtBQUNuQyxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVELGtCQUFrQixnRUFBYyxDQUFDLG9FQUFzQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUUsc0VBQW9CLG1DQUFtQyxpRkFBK0IsQ0FBQyxvRUFBc0I7QUFDL0c7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ1AsZ0JBQWdCLDhEQUFZO0FBQzVCLEVBQUUscUVBQW1CO0FBQ3JCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BwZXRhbW9yaWtlbi9mbG9hdDE2L3NyYy9fdXRpbC9hcnJheUl0ZXJhdG9yLm1qcz8wODkxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFycmF5SXRlcmF0b3JQcm90b3R5cGUsXG4gIEFycmF5SXRlcmF0b3JQcm90b3R5cGVOZXh0LFxuICBBcnJheVByb3RvdHlwZVN5bWJvbEl0ZXJhdG9yLFxuICBHZW5lcmF0b3JQcm90b3R5cGVOZXh0LFxuICBJdGVyYXRvclByb3RvdHlwZSxcbiAgTmF0aXZlQXJyYXlQcm90b3R5cGVTeW1ib2xJdGVyYXRvcixcbiAgTmF0aXZlV2Vha01hcCxcbiAgT2JqZWN0Q3JlYXRlLFxuICBPYmplY3REZWZpbmVQcm9wZXJ0eSxcbiAgUmVmbGVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgUmVmbGVjdE93bktleXMsXG4gIFN5bWJvbEl0ZXJhdG9yLFxuICBXZWFrTWFwUHJvdG90eXBlR2V0LFxuICBXZWFrTWFwUHJvdG90eXBlU2V0LFxufSBmcm9tIFwiLi9wcmltb3JkaWFscy5tanNcIjtcblxuLyoqIEB0eXBlIHtXZWFrTWFwPHt9LCBJdGVyYWJsZUl0ZXJhdG9yPGFueT4+fSAqL1xuY29uc3QgYXJyYXlJdGVyYXRvcnMgPSBuZXcgTmF0aXZlV2Vha01hcCgpO1xuXG5jb25zdCBTYWZlSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3RDcmVhdGUobnVsbCwge1xuICBuZXh0OiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICBjb25zdCBhcnJheUl0ZXJhdG9yID0gV2Vha01hcFByb3RvdHlwZUdldChhcnJheUl0ZXJhdG9ycywgdGhpcyk7XG4gICAgICByZXR1cm4gQXJyYXlJdGVyYXRvclByb3RvdHlwZU5leHQoYXJyYXlJdGVyYXRvcik7XG4gICAgfSxcbiAgfSxcblxuICBbU3ltYm9sSXRlcmF0b3JdOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIH0sXG59KTtcblxuLyoqXG4gKiBXcmFwIHRoZSBBcnJheSBhcm91bmQgdGhlIFNhZmVJdGVyYXRvciBJZiBBcnJheS5wcm90b3R5cGUgW0BAaXRlcmF0b3JdIGhhcyBiZWVuIG1vZGlmaWVkXG4gKiBAdHlwZSB7PFQ+KGFycmF5OiBUW10pID0+IEl0ZXJhYmxlPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FmZUlmTmVlZGVkKGFycmF5KSB7XG4gIGlmIChcbiAgICBhcnJheVtTeW1ib2xJdGVyYXRvcl0gPT09IE5hdGl2ZUFycmF5UHJvdG90eXBlU3ltYm9sSXRlcmF0b3IgJiZcbiAgICBBcnJheUl0ZXJhdG9yUHJvdG90eXBlLm5leHQgPT09IEFycmF5SXRlcmF0b3JQcm90b3R5cGVOZXh0XG4gICkge1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIGNvbnN0IHNhZmUgPSBPYmplY3RDcmVhdGUoU2FmZUl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgV2Vha01hcFByb3RvdHlwZVNldChhcnJheUl0ZXJhdG9ycywgc2FmZSwgQXJyYXlQcm90b3R5cGVTeW1ib2xJdGVyYXRvcihhcnJheSkpO1xuICByZXR1cm4gc2FmZTtcbn1cblxuLyoqIEB0eXBlIHtXZWFrTWFwPHt9LCBHZW5lcmF0b3I8YW55Pj59ICovXG5jb25zdCBnZW5lcmF0b3JzID0gbmV3IE5hdGl2ZVdlYWtNYXAoKTtcblxuLyoqIEBzZWUgaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lYXJyYXlpdGVyYXRvcnByb3RvdHlwZSUtb2JqZWN0ICovXG5jb25zdCBEdW1teUFycmF5SXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3RDcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHtcbiAgbmV4dDoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgY29uc3QgZ2VuZXJhdG9yID0gV2Vha01hcFByb3RvdHlwZUdldChnZW5lcmF0b3JzLCB0aGlzKTtcbiAgICAgIHJldHVybiBHZW5lcmF0b3JQcm90b3R5cGVOZXh0KGdlbmVyYXRvcik7XG4gICAgfSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gIH0sXG59KTtcblxuZm9yIChjb25zdCBrZXkgb2YgUmVmbGVjdE93bktleXMoQXJyYXlJdGVyYXRvclByb3RvdHlwZSkpIHtcbiAgLy8gbmV4dCBtZXRob2QgaGFzIGFscmVhZHkgZGVmaW5lZFxuICBpZiAoa2V5ID09PSBcIm5leHRcIikge1xuICAgIGNvbnRpbnVlO1xuICB9XG5cbiAgLy8gQ29weSBBcnJheUl0ZXJhdG9yUHJvdG90eXBlIGRlc2NyaXB0b3JzIHRvIER1bW15QXJyYXlJdGVyYXRvclByb3RvdHlwZVxuICBPYmplY3REZWZpbmVQcm9wZXJ0eShEdW1teUFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGtleSwgUmVmbGVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBrZXkpKTtcbn1cblxuLyoqXG4gKiBXcmFwIHRoZSBHZW5lcmF0b3IgYXJvdW5kIHRoZSBkdW1teSBBcnJheUl0ZXJhdG9yXG4gKiBAdHlwZSB7PFQ+KGdlbmVyYXRvcjogR2VuZXJhdG9yPFQ+KSA9PiBJdGVyYWJsZUl0ZXJhdG9yPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcChnZW5lcmF0b3IpIHtcbiAgY29uc3QgZHVtbXkgPSBPYmplY3RDcmVhdGUoRHVtbXlBcnJheUl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgV2Vha01hcFByb3RvdHlwZVNldChnZW5lcmF0b3JzLCBkdW1teSwgZ2VuZXJhdG9yKTtcbiAgcmV0dXJuIGR1bW15O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/arrayIterator.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/converter.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@petamoriken/float16/src/_util/converter.mjs ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertToNumber: function() { return /* binding */ convertToNumber; },\n/* harmony export */   roundToFloat16: function() { return /* binding */ roundToFloat16; },\n/* harmony export */   roundToFloat16Bits: function() { return /* binding */ roundToFloat16Bits; }\n/* harmony export */ });\n/* harmony import */ var _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./primordials.mjs */ \"(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/primordials.mjs\");\n\n\nconst INVERSE_OF_EPSILON = 1 / _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.EPSILON;\n\n/**\n * rounds to the nearest value;\n * if the number falls midway, it is rounded to the nearest value with an even least significant digit\n * @param {number} num\n * @returns {number}\n */\nfunction roundTiesToEven(num) {\n  return (num + INVERSE_OF_EPSILON) - INVERSE_OF_EPSILON;\n}\n\nconst FLOAT16_MIN_VALUE = 6.103515625e-05;\nconst FLOAT16_MAX_VALUE = 65504;\nconst FLOAT16_EPSILON = 0.0009765625;\n\nconst FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE = FLOAT16_EPSILON * FLOAT16_MIN_VALUE;\nconst FLOAT16_EPSILON_DEVIDED_BY_EPSILON = FLOAT16_EPSILON * INVERSE_OF_EPSILON;\n\n/**\n * round a number to a half float number\n * @param {unknown} num - double float\n * @returns {number} half float number\n */\nfunction roundToFloat16(num) {\n  const number = +num;\n\n  // NaN, Infinity, -Infinity, 0, -0\n  if (!(0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NumberIsFinite)(number) || number === 0) {\n    return number;\n  }\n\n  // finite except 0, -0\n  const sign = number > 0 ? 1 : -1;\n  const absolute = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.MathAbs)(number);\n\n  // small number\n  if (absolute < FLOAT16_MIN_VALUE) {\n    return sign * roundTiesToEven(absolute / FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE) * FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE;\n  }\n\n  const temp = (1 + FLOAT16_EPSILON_DEVIDED_BY_EPSILON) * absolute;\n  const result = temp - (temp - absolute);\n\n  // large number\n  if (result > FLOAT16_MAX_VALUE || (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NumberIsNaN)(result)) {\n    return sign * Infinity;\n  }\n\n  return sign * result;\n}\n\n// base algorithm: http://fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\nconst buffer = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeArrayBuffer(4);\nconst floatView = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeFloat32Array(buffer);\nconst uint32View = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeUint32Array(buffer);\n\nconst baseTable = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeUint16Array(512);\nconst shiftTable = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeUint8Array(512);\n\nfor (let i = 0; i < 256; ++i) {\n  const e = i - 127;\n\n  // very small number (0, -0)\n  if (e < -24) {\n    baseTable[i]         = 0x0000;\n    baseTable[i | 0x100] = 0x8000;\n    shiftTable[i]         = 24;\n    shiftTable[i | 0x100] = 24;\n\n  // small number (denorm)\n  } else if (e < -14) {\n    baseTable[i]         =  0x0400 >> (-e - 14);\n    baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;\n    shiftTable[i]         = -e - 1;\n    shiftTable[i | 0x100] = -e - 1;\n\n  // normal number\n  } else if (e <= 15) {\n    baseTable[i]         =  (e + 15) << 10;\n    baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;\n    shiftTable[i]         = 13;\n    shiftTable[i | 0x100] = 13;\n\n  // large number (Infinity, -Infinity)\n  } else if (e < 128) {\n    baseTable[i]         = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i]         = 24;\n    shiftTable[i | 0x100] = 24;\n\n  // stay (NaN, Infinity, -Infinity)\n  } else {\n    baseTable[i]         = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i]         = 13;\n    shiftTable[i | 0x100] = 13;\n  }\n}\n\n/**\n * round a number to a half float number bits\n * @param {unknown} num - double float\n * @returns {number} half float number bits\n */\nfunction roundToFloat16Bits(num) {\n  floatView[0] = roundToFloat16(num);\n  const f = uint32View[0];\n  const e = (f >> 23) & 0x1ff;\n  return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);\n}\n\nconst mantissaTable = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeUint32Array(2048);\nfor (let i = 1; i < 1024; ++i) {\n  let m = i << 13; // zero pad mantissa bits\n  let e = 0; // zero exponent\n\n  // normalized\n  while ((m & 0x00800000) === 0) {\n    m <<= 1;\n    e -= 0x00800000; // decrement exponent\n  }\n\n  m &= ~0x00800000; // clear leading 1 bit\n  e += 0x38800000; // adjust bias\n\n  mantissaTable[i] = m | e;\n}\nfor (let i = 1024; i < 2048; ++i) {\n  mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);\n}\n\nconst exponentTable = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeUint32Array(64);\nfor (let i = 1; i < 31; ++i) {\n  exponentTable[i] = i << 23;\n}\nexponentTable[31] = 0x47800000;\nexponentTable[32] = 0x80000000;\nfor (let i = 33; i < 63; ++i) {\n  exponentTable[i] = 0x80000000 + ((i - 32) << 23);\n}\nexponentTable[63] = 0xc7800000;\n\nconst offsetTable = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeUint16Array(64);\nfor (let i = 1; i < 64; ++i) {\n  if (i !== 32) {\n    offsetTable[i] = 1024;\n  }\n}\n\n/**\n * convert a half float number bits to a number\n * @param {number} float16bits - half float number bits\n * @returns {number} double float\n */\nfunction convertToNumber(float16bits) {\n  const i = float16bits >> 10;\n  uint32View[0] = mantissaTable[offsetTable[i] + (float16bits & 0x3ff)] + exponentTable[i];\n  return floatView[0];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGV0YW1vcmlrZW4vZmxvYXQxNi9zcmMvX3V0aWwvY29udmVydGVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBVTJCOztBQUUzQiwrQkFBK0IscURBQU87O0FBRXRDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDTztBQUNQOztBQUVBO0FBQ0EsT0FBTyxnRUFBYztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIseURBQU87O0FBRTFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsNkRBQVc7QUFDL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQiwrREFBaUI7QUFDcEMsc0JBQXNCLGdFQUFrQjtBQUN4Qyx1QkFBdUIsK0RBQWlCOztBQUV4QyxzQkFBc0IsK0RBQWlCO0FBQ3ZDLHVCQUF1Qiw4REFBZ0I7O0FBRXZDLGdCQUFnQixTQUFTO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLCtEQUFpQjtBQUMzQyxnQkFBZ0IsVUFBVTtBQUMxQixtQkFBbUI7QUFDbkIsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUEsb0JBQW9CO0FBQ3BCLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7O0FBRUEsMEJBQTBCLCtEQUFpQjtBQUMzQyxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsK0RBQWlCO0FBQ3pDLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHBldGFtb3Jpa2VuL2Zsb2F0MTYvc3JjL191dGlsL2NvbnZlcnRlci5tanM/YTU2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBFUFNJTE9OLFxuICBNYXRoQWJzLFxuICBOYXRpdmVBcnJheUJ1ZmZlcixcbiAgTmF0aXZlRmxvYXQzMkFycmF5LFxuICBOYXRpdmVVaW50MTZBcnJheSxcbiAgTmF0aXZlVWludDMyQXJyYXksXG4gIE5hdGl2ZVVpbnQ4QXJyYXksXG4gIE51bWJlcklzRmluaXRlLFxuICBOdW1iZXJJc05hTixcbn0gZnJvbSBcIi4vcHJpbW9yZGlhbHMubWpzXCI7XG5cbmNvbnN0IElOVkVSU0VfT0ZfRVBTSUxPTiA9IDEgLyBFUFNJTE9OO1xuXG4vKipcbiAqIHJvdW5kcyB0byB0aGUgbmVhcmVzdCB2YWx1ZTtcbiAqIGlmIHRoZSBudW1iZXIgZmFsbHMgbWlkd2F5LCBpdCBpcyByb3VuZGVkIHRvIHRoZSBuZWFyZXN0IHZhbHVlIHdpdGggYW4gZXZlbiBsZWFzdCBzaWduaWZpY2FudCBkaWdpdFxuICogQHBhcmFtIHtudW1iZXJ9IG51bVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gcm91bmRUaWVzVG9FdmVuKG51bSkge1xuICByZXR1cm4gKG51bSArIElOVkVSU0VfT0ZfRVBTSUxPTikgLSBJTlZFUlNFX09GX0VQU0lMT047XG59XG5cbmNvbnN0IEZMT0FUMTZfTUlOX1ZBTFVFID0gNi4xMDM1MTU2MjVlLTA1O1xuY29uc3QgRkxPQVQxNl9NQVhfVkFMVUUgPSA2NTUwNDtcbmNvbnN0IEZMT0FUMTZfRVBTSUxPTiA9IDAuMDAwOTc2NTYyNTtcblxuY29uc3QgRkxPQVQxNl9FUFNJTE9OX01VTFRJUExJRURfQllfRkxPQVQxNl9NSU5fVkFMVUUgPSBGTE9BVDE2X0VQU0lMT04gKiBGTE9BVDE2X01JTl9WQUxVRTtcbmNvbnN0IEZMT0FUMTZfRVBTSUxPTl9ERVZJREVEX0JZX0VQU0lMT04gPSBGTE9BVDE2X0VQU0lMT04gKiBJTlZFUlNFX09GX0VQU0lMT047XG5cbi8qKlxuICogcm91bmQgYSBudW1iZXIgdG8gYSBoYWxmIGZsb2F0IG51bWJlclxuICogQHBhcmFtIHt1bmtub3dufSBudW0gLSBkb3VibGUgZmxvYXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGhhbGYgZmxvYXQgbnVtYmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3VuZFRvRmxvYXQxNihudW0pIHtcbiAgY29uc3QgbnVtYmVyID0gK251bTtcblxuICAvLyBOYU4sIEluZmluaXR5LCAtSW5maW5pdHksIDAsIC0wXG4gIGlmICghTnVtYmVySXNGaW5pdGUobnVtYmVyKSB8fCBudW1iZXIgPT09IDApIHtcbiAgICByZXR1cm4gbnVtYmVyO1xuICB9XG5cbiAgLy8gZmluaXRlIGV4Y2VwdCAwLCAtMFxuICBjb25zdCBzaWduID0gbnVtYmVyID4gMCA/IDEgOiAtMTtcbiAgY29uc3QgYWJzb2x1dGUgPSBNYXRoQWJzKG51bWJlcik7XG5cbiAgLy8gc21hbGwgbnVtYmVyXG4gIGlmIChhYnNvbHV0ZSA8IEZMT0FUMTZfTUlOX1ZBTFVFKSB7XG4gICAgcmV0dXJuIHNpZ24gKiByb3VuZFRpZXNUb0V2ZW4oYWJzb2x1dGUgLyBGTE9BVDE2X0VQU0lMT05fTVVMVElQTElFRF9CWV9GTE9BVDE2X01JTl9WQUxVRSkgKiBGTE9BVDE2X0VQU0lMT05fTVVMVElQTElFRF9CWV9GTE9BVDE2X01JTl9WQUxVRTtcbiAgfVxuXG4gIGNvbnN0IHRlbXAgPSAoMSArIEZMT0FUMTZfRVBTSUxPTl9ERVZJREVEX0JZX0VQU0lMT04pICogYWJzb2x1dGU7XG4gIGNvbnN0IHJlc3VsdCA9IHRlbXAgLSAodGVtcCAtIGFic29sdXRlKTtcblxuICAvLyBsYXJnZSBudW1iZXJcbiAgaWYgKHJlc3VsdCA+IEZMT0FUMTZfTUFYX1ZBTFVFIHx8IE51bWJlcklzTmFOKHJlc3VsdCkpIHtcbiAgICByZXR1cm4gc2lnbiAqIEluZmluaXR5O1xuICB9XG5cbiAgcmV0dXJuIHNpZ24gKiByZXN1bHQ7XG59XG5cbi8vIGJhc2UgYWxnb3JpdGhtOiBodHRwOi8vZm94LXRvb2xraXQub3JnL2Z0cC9mYXN0aGFsZmZsb2F0Y29udmVyc2lvbi5wZGZcblxuY29uc3QgYnVmZmVyID0gbmV3IE5hdGl2ZUFycmF5QnVmZmVyKDQpO1xuY29uc3QgZmxvYXRWaWV3ID0gbmV3IE5hdGl2ZUZsb2F0MzJBcnJheShidWZmZXIpO1xuY29uc3QgdWludDMyVmlldyA9IG5ldyBOYXRpdmVVaW50MzJBcnJheShidWZmZXIpO1xuXG5jb25zdCBiYXNlVGFibGUgPSBuZXcgTmF0aXZlVWludDE2QXJyYXkoNTEyKTtcbmNvbnN0IHNoaWZ0VGFibGUgPSBuZXcgTmF0aXZlVWludDhBcnJheSg1MTIpO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGNvbnN0IGUgPSBpIC0gMTI3O1xuXG4gIC8vIHZlcnkgc21hbGwgbnVtYmVyICgwLCAtMClcbiAgaWYgKGUgPCAtMjQpIHtcbiAgICBiYXNlVGFibGVbaV0gICAgICAgICA9IDB4MDAwMDtcbiAgICBiYXNlVGFibGVbaSB8IDB4MTAwXSA9IDB4ODAwMDtcbiAgICBzaGlmdFRhYmxlW2ldICAgICAgICAgPSAyNDtcbiAgICBzaGlmdFRhYmxlW2kgfCAweDEwMF0gPSAyNDtcblxuICAvLyBzbWFsbCBudW1iZXIgKGRlbm9ybSlcbiAgfSBlbHNlIGlmIChlIDwgLTE0KSB7XG4gICAgYmFzZVRhYmxlW2ldICAgICAgICAgPSAgMHgwNDAwID4+ICgtZSAtIDE0KTtcbiAgICBiYXNlVGFibGVbaSB8IDB4MTAwXSA9ICgweDA0MDAgPj4gKC1lIC0gMTQpKSB8IDB4ODAwMDtcbiAgICBzaGlmdFRhYmxlW2ldICAgICAgICAgPSAtZSAtIDE7XG4gICAgc2hpZnRUYWJsZVtpIHwgMHgxMDBdID0gLWUgLSAxO1xuXG4gIC8vIG5vcm1hbCBudW1iZXJcbiAgfSBlbHNlIGlmIChlIDw9IDE1KSB7XG4gICAgYmFzZVRhYmxlW2ldICAgICAgICAgPSAgKGUgKyAxNSkgPDwgMTA7XG4gICAgYmFzZVRhYmxlW2kgfCAweDEwMF0gPSAoKGUgKyAxNSkgPDwgMTApIHwgMHg4MDAwO1xuICAgIHNoaWZ0VGFibGVbaV0gICAgICAgICA9IDEzO1xuICAgIHNoaWZ0VGFibGVbaSB8IDB4MTAwXSA9IDEzO1xuXG4gIC8vIGxhcmdlIG51bWJlciAoSW5maW5pdHksIC1JbmZpbml0eSlcbiAgfSBlbHNlIGlmIChlIDwgMTI4KSB7XG4gICAgYmFzZVRhYmxlW2ldICAgICAgICAgPSAweDdjMDA7XG4gICAgYmFzZVRhYmxlW2kgfCAweDEwMF0gPSAweGZjMDA7XG4gICAgc2hpZnRUYWJsZVtpXSAgICAgICAgID0gMjQ7XG4gICAgc2hpZnRUYWJsZVtpIHwgMHgxMDBdID0gMjQ7XG5cbiAgLy8gc3RheSAoTmFOLCBJbmZpbml0eSwgLUluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIGJhc2VUYWJsZVtpXSAgICAgICAgID0gMHg3YzAwO1xuICAgIGJhc2VUYWJsZVtpIHwgMHgxMDBdID0gMHhmYzAwO1xuICAgIHNoaWZ0VGFibGVbaV0gICAgICAgICA9IDEzO1xuICAgIHNoaWZ0VGFibGVbaSB8IDB4MTAwXSA9IDEzO1xuICB9XG59XG5cbi8qKlxuICogcm91bmQgYSBudW1iZXIgdG8gYSBoYWxmIGZsb2F0IG51bWJlciBiaXRzXG4gKiBAcGFyYW0ge3Vua25vd259IG51bSAtIGRvdWJsZSBmbG9hdFxuICogQHJldHVybnMge251bWJlcn0gaGFsZiBmbG9hdCBudW1iZXIgYml0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gcm91bmRUb0Zsb2F0MTZCaXRzKG51bSkge1xuICBmbG9hdFZpZXdbMF0gPSByb3VuZFRvRmxvYXQxNihudW0pO1xuICBjb25zdCBmID0gdWludDMyVmlld1swXTtcbiAgY29uc3QgZSA9IChmID4+IDIzKSAmIDB4MWZmO1xuICByZXR1cm4gYmFzZVRhYmxlW2VdICsgKChmICYgMHgwMDdmZmZmZikgPj4gc2hpZnRUYWJsZVtlXSk7XG59XG5cbmNvbnN0IG1hbnRpc3NhVGFibGUgPSBuZXcgTmF0aXZlVWludDMyQXJyYXkoMjA0OCk7XG5mb3IgKGxldCBpID0gMTsgaSA8IDEwMjQ7ICsraSkge1xuICBsZXQgbSA9IGkgPDwgMTM7IC8vIHplcm8gcGFkIG1hbnRpc3NhIGJpdHNcbiAgbGV0IGUgPSAwOyAvLyB6ZXJvIGV4cG9uZW50XG5cbiAgLy8gbm9ybWFsaXplZFxuICB3aGlsZSAoKG0gJiAweDAwODAwMDAwKSA9PT0gMCkge1xuICAgIG0gPDw9IDE7XG4gICAgZSAtPSAweDAwODAwMDAwOyAvLyBkZWNyZW1lbnQgZXhwb25lbnRcbiAgfVxuXG4gIG0gJj0gfjB4MDA4MDAwMDA7IC8vIGNsZWFyIGxlYWRpbmcgMSBiaXRcbiAgZSArPSAweDM4ODAwMDAwOyAvLyBhZGp1c3QgYmlhc1xuXG4gIG1hbnRpc3NhVGFibGVbaV0gPSBtIHwgZTtcbn1cbmZvciAobGV0IGkgPSAxMDI0OyBpIDwgMjA0ODsgKytpKSB7XG4gIG1hbnRpc3NhVGFibGVbaV0gPSAweDM4MDAwMDAwICsgKChpIC0gMTAyNCkgPDwgMTMpO1xufVxuXG5jb25zdCBleHBvbmVudFRhYmxlID0gbmV3IE5hdGl2ZVVpbnQzMkFycmF5KDY0KTtcbmZvciAobGV0IGkgPSAxOyBpIDwgMzE7ICsraSkge1xuICBleHBvbmVudFRhYmxlW2ldID0gaSA8PCAyMztcbn1cbmV4cG9uZW50VGFibGVbMzFdID0gMHg0NzgwMDAwMDtcbmV4cG9uZW50VGFibGVbMzJdID0gMHg4MDAwMDAwMDtcbmZvciAobGV0IGkgPSAzMzsgaSA8IDYzOyArK2kpIHtcbiAgZXhwb25lbnRUYWJsZVtpXSA9IDB4ODAwMDAwMDAgKyAoKGkgLSAzMikgPDwgMjMpO1xufVxuZXhwb25lbnRUYWJsZVs2M10gPSAweGM3ODAwMDAwO1xuXG5jb25zdCBvZmZzZXRUYWJsZSA9IG5ldyBOYXRpdmVVaW50MTZBcnJheSg2NCk7XG5mb3IgKGxldCBpID0gMTsgaSA8IDY0OyArK2kpIHtcbiAgaWYgKGkgIT09IDMyKSB7XG4gICAgb2Zmc2V0VGFibGVbaV0gPSAxMDI0O1xuICB9XG59XG5cbi8qKlxuICogY29udmVydCBhIGhhbGYgZmxvYXQgbnVtYmVyIGJpdHMgdG8gYSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbG9hdDE2Yml0cyAtIGhhbGYgZmxvYXQgbnVtYmVyIGJpdHNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGRvdWJsZSBmbG9hdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvTnVtYmVyKGZsb2F0MTZiaXRzKSB7XG4gIGNvbnN0IGkgPSBmbG9hdDE2Yml0cyA+PiAxMDtcbiAgdWludDMyVmlld1swXSA9IG1hbnRpc3NhVGFibGVbb2Zmc2V0VGFibGVbaV0gKyAoZmxvYXQxNmJpdHMgJiAweDNmZildICsgZXhwb25lbnRUYWJsZVtpXTtcbiAgcmV0dXJuIGZsb2F0Vmlld1swXTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/converter.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/messages.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@petamoriken/float16/src/_util/messages.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER: function() { return /* binding */ ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER; },\n/* harmony export */   CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT: function() { return /* binding */ CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT; },\n/* harmony export */   CANNOT_MIX_BIGINT_AND_OTHER_TYPES: function() { return /* binding */ CANNOT_MIX_BIGINT_AND_OTHER_TYPES; },\n/* harmony export */   DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH: function() { return /* binding */ DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH; },\n/* harmony export */   ITERATOR_PROPERTY_IS_NOT_CALLABLE: function() { return /* binding */ ITERATOR_PROPERTY_IS_NOT_CALLABLE; },\n/* harmony export */   OFFSET_IS_OUT_OF_BOUNDS: function() { return /* binding */ OFFSET_IS_OUT_OF_BOUNDS; },\n/* harmony export */   REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE: function() { return /* binding */ REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE; },\n/* harmony export */   SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT: function() { return /* binding */ SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT; },\n/* harmony export */   THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED: function() { return /* binding */ THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED; },\n/* harmony export */   THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT: function() { return /* binding */ THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT; },\n/* harmony export */   THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY: function() { return /* binding */ THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY; },\n/* harmony export */   THIS_IS_NOT_AN_OBJECT: function() { return /* binding */ THIS_IS_NOT_AN_OBJECT; },\n/* harmony export */   THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT: function() { return /* binding */ THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT; }\n/* harmony export */ });\nconst THIS_IS_NOT_AN_OBJECT = \"This is not an object\";\nconst THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT = \"This is not a Float16Array object\";\nconst THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY =\n  \"This constructor is not a subclass of Float16Array\";\nconst THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT =\n  \"The constructor property value is not an object\";\nconst SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT =\n  \"Species constructor didn't return TypedArray object\";\nconst DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH =\n  \"Derived constructor created TypedArray object which was too small length\";\nconst ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER =\n  \"Attempting to access detached ArrayBuffer\";\nconst CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT =\n  \"Cannot convert undefined or null to object\";\nconst CANNOT_MIX_BIGINT_AND_OTHER_TYPES =\n  \"Cannot mix BigInt and other types, use explicit conversions\";\nconst ITERATOR_PROPERTY_IS_NOT_CALLABLE = \"@@iterator property is not callable\";\nconst REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE =\n  \"Reduce of empty array with no initial value\";\nconst THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED =\n  \"The comparison function must be either a function or undefined\";\nconst OFFSET_IS_OUT_OF_BOUNDS = \"Offset is out of bounds\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGV0YW1vcmlrZW4vZmxvYXQxNi9zcmMvX3V0aWwvbWVzc2FnZXMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBTztBQUNBO0FBQ0E7QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ0E7QUFDUDtBQUNPO0FBQ1A7QUFDTyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHBldGFtb3Jpa2VuL2Zsb2F0MTYvc3JjL191dGlsL21lc3NhZ2VzLm1qcz8wZjFlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBUSElTX0lTX05PVF9BTl9PQkpFQ1QgPSBcIlRoaXMgaXMgbm90IGFuIG9iamVjdFwiO1xuZXhwb3J0IGNvbnN0IFRISVNfSVNfTk9UX0FfRkxPQVQxNkFSUkFZX09CSkVDVCA9IFwiVGhpcyBpcyBub3QgYSBGbG9hdDE2QXJyYXkgb2JqZWN0XCI7XG5leHBvcnQgY29uc3QgVEhJU19DT05TVFJVQ1RPUl9JU19OT1RfQV9TVUJDTEFTU19PRl9GTE9BVDE2QVJSQVkgPVxuICBcIlRoaXMgY29uc3RydWN0b3IgaXMgbm90IGEgc3ViY2xhc3Mgb2YgRmxvYXQxNkFycmF5XCI7XG5leHBvcnQgY29uc3QgVEhFX0NPTlNUUlVDVE9SX1BST1BFUlRZX1ZBTFVFX0lTX05PVF9BTl9PQkpFQ1QgPVxuICBcIlRoZSBjb25zdHJ1Y3RvciBwcm9wZXJ0eSB2YWx1ZSBpcyBub3QgYW4gb2JqZWN0XCI7XG5leHBvcnQgY29uc3QgU1BFQ0lFU19DT05TVFJVQ1RPUl9ESUROVF9SRVRVUk5fVFlQRURBUlJBWV9PQkpFQ1QgPVxuICBcIlNwZWNpZXMgY29uc3RydWN0b3IgZGlkbid0IHJldHVybiBUeXBlZEFycmF5IG9iamVjdFwiO1xuZXhwb3J0IGNvbnN0IERFUklWRURfQ09OU1RSVUNUT1JfQ1JFQVRFRF9UWVBFREFSUkFZX09CSkVDVF9XSElDSF9XQVNfVE9PX1NNQUxMX0xFTkdUSCA9XG4gIFwiRGVyaXZlZCBjb25zdHJ1Y3RvciBjcmVhdGVkIFR5cGVkQXJyYXkgb2JqZWN0IHdoaWNoIHdhcyB0b28gc21hbGwgbGVuZ3RoXCI7XG5leHBvcnQgY29uc3QgQVRURU1QVElOR19UT19BQ0NFU1NfREVUQUNIRURfQVJSQVlCVUZGRVIgPVxuICBcIkF0dGVtcHRpbmcgdG8gYWNjZXNzIGRldGFjaGVkIEFycmF5QnVmZmVyXCI7XG5leHBvcnQgY29uc3QgQ0FOTk9UX0NPTlZFUlRfVU5ERUZJTkVEX09SX05VTExfVE9fT0JKRUNUID1cbiAgXCJDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3RcIjtcbmV4cG9ydCBjb25zdCBDQU5OT1RfTUlYX0JJR0lOVF9BTkRfT1RIRVJfVFlQRVMgPVxuICBcIkNhbm5vdCBtaXggQmlnSW50IGFuZCBvdGhlciB0eXBlcywgdXNlIGV4cGxpY2l0IGNvbnZlcnNpb25zXCI7XG5leHBvcnQgY29uc3QgSVRFUkFUT1JfUFJPUEVSVFlfSVNfTk9UX0NBTExBQkxFID0gXCJAQGl0ZXJhdG9yIHByb3BlcnR5IGlzIG5vdCBjYWxsYWJsZVwiO1xuZXhwb3J0IGNvbnN0IFJFRFVDRV9PRl9FTVBUWV9BUlJBWV9XSVRIX05PX0lOSVRJQUxfVkFMVUUgPVxuICBcIlJlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWVcIjtcbmV4cG9ydCBjb25zdCBUSEVfQ09NUEFSSVNPTl9GVU5DVElPTl9NVVNUX0JFX0VJVEhFUl9BX0ZVTkNUSU9OX09SX1VOREVGSU5FRCA9XG4gIFwiVGhlIGNvbXBhcmlzb24gZnVuY3Rpb24gbXVzdCBiZSBlaXRoZXIgYSBmdW5jdGlvbiBvciB1bmRlZmluZWRcIjtcbmV4cG9ydCBjb25zdCBPRkZTRVRfSVNfT1VUX09GX0JPVU5EUyA9IFwiT2Zmc2V0IGlzIG91dCBvZiBib3VuZHNcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/messages.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/primordials.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@petamoriken/float16/src/_util/primordials.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayBufferIsView: function() { return /* binding */ ArrayBufferIsView; },\n/* harmony export */   ArrayBufferPrototypeGetByteLength: function() { return /* binding */ ArrayBufferPrototypeGetByteLength; },\n/* harmony export */   ArrayBufferPrototypeSlice: function() { return /* binding */ ArrayBufferPrototypeSlice; },\n/* harmony export */   ArrayIsArray: function() { return /* binding */ ArrayIsArray; },\n/* harmony export */   ArrayIteratorPrototype: function() { return /* binding */ ArrayIteratorPrototype; },\n/* harmony export */   ArrayIteratorPrototypeNext: function() { return /* binding */ ArrayIteratorPrototypeNext; },\n/* harmony export */   ArrayPrototypeJoin: function() { return /* binding */ ArrayPrototypeJoin; },\n/* harmony export */   ArrayPrototypePush: function() { return /* binding */ ArrayPrototypePush; },\n/* harmony export */   ArrayPrototypeSymbolIterator: function() { return /* binding */ ArrayPrototypeSymbolIterator; },\n/* harmony export */   ArrayPrototypeToLocaleString: function() { return /* binding */ ArrayPrototypeToLocaleString; },\n/* harmony export */   DataViewPrototypeGetUint16: function() { return /* binding */ DataViewPrototypeGetUint16; },\n/* harmony export */   DataViewPrototypeSetUint16: function() { return /* binding */ DataViewPrototypeSetUint16; },\n/* harmony export */   EPSILON: function() { return /* binding */ EPSILON; },\n/* harmony export */   GeneratorPrototypeNext: function() { return /* binding */ GeneratorPrototypeNext; },\n/* harmony export */   IteratorPrototype: function() { return /* binding */ IteratorPrototype; },\n/* harmony export */   MAX_SAFE_INTEGER: function() { return /* binding */ MAX_SAFE_INTEGER; },\n/* harmony export */   MathAbs: function() { return /* binding */ MathAbs; },\n/* harmony export */   MathTrunc: function() { return /* binding */ MathTrunc; },\n/* harmony export */   NativeArrayBuffer: function() { return /* binding */ NativeArrayBuffer; },\n/* harmony export */   NativeArrayPrototypeSymbolIterator: function() { return /* binding */ NativeArrayPrototypeSymbolIterator; },\n/* harmony export */   NativeFloat32Array: function() { return /* binding */ NativeFloat32Array; },\n/* harmony export */   NativeObject: function() { return /* binding */ NativeObject; },\n/* harmony export */   NativeProxy: function() { return /* binding */ NativeProxy; },\n/* harmony export */   NativeRangeError: function() { return /* binding */ NativeRangeError; },\n/* harmony export */   NativeSharedArrayBuffer: function() { return /* binding */ NativeSharedArrayBuffer; },\n/* harmony export */   NativeTypeError: function() { return /* binding */ NativeTypeError; },\n/* harmony export */   NativeTypedArrayPrototypeSymbolIterator: function() { return /* binding */ NativeTypedArrayPrototypeSymbolIterator; },\n/* harmony export */   NativeUint16Array: function() { return /* binding */ NativeUint16Array; },\n/* harmony export */   NativeUint32Array: function() { return /* binding */ NativeUint32Array; },\n/* harmony export */   NativeUint8Array: function() { return /* binding */ NativeUint8Array; },\n/* harmony export */   NativeWeakMap: function() { return /* binding */ NativeWeakMap; },\n/* harmony export */   NativeWeakSet: function() { return /* binding */ NativeWeakSet; },\n/* harmony export */   NumberIsFinite: function() { return /* binding */ NumberIsFinite; },\n/* harmony export */   NumberIsNaN: function() { return /* binding */ NumberIsNaN; },\n/* harmony export */   ObjectCreate: function() { return /* binding */ ObjectCreate; },\n/* harmony export */   ObjectDefineProperty: function() { return /* binding */ ObjectDefineProperty; },\n/* harmony export */   ObjectFreeze: function() { return /* binding */ ObjectFreeze; },\n/* harmony export */   ObjectHasOwn: function() { return /* binding */ ObjectHasOwn; },\n/* harmony export */   ObjectIs: function() { return /* binding */ ObjectIs; },\n/* harmony export */   ObjectPrototype__lookupGetter__: function() { return /* binding */ ObjectPrototype__lookupGetter__; },\n/* harmony export */   ReflectApply: function() { return /* binding */ ReflectApply; },\n/* harmony export */   ReflectConstruct: function() { return /* binding */ ReflectConstruct; },\n/* harmony export */   ReflectDefineProperty: function() { return /* binding */ ReflectDefineProperty; },\n/* harmony export */   ReflectGet: function() { return /* binding */ ReflectGet; },\n/* harmony export */   ReflectGetOwnPropertyDescriptor: function() { return /* binding */ ReflectGetOwnPropertyDescriptor; },\n/* harmony export */   ReflectGetPrototypeOf: function() { return /* binding */ ReflectGetPrototypeOf; },\n/* harmony export */   ReflectHas: function() { return /* binding */ ReflectHas; },\n/* harmony export */   ReflectOwnKeys: function() { return /* binding */ ReflectOwnKeys; },\n/* harmony export */   ReflectSet: function() { return /* binding */ ReflectSet; },\n/* harmony export */   ReflectSetPrototypeOf: function() { return /* binding */ ReflectSetPrototypeOf; },\n/* harmony export */   SharedArrayBufferPrototypeGetByteLength: function() { return /* binding */ SharedArrayBufferPrototypeGetByteLength; },\n/* harmony export */   SymbolFor: function() { return /* binding */ SymbolFor; },\n/* harmony export */   SymbolIterator: function() { return /* binding */ SymbolIterator; },\n/* harmony export */   SymbolSpecies: function() { return /* binding */ SymbolSpecies; },\n/* harmony export */   SymbolToStringTag: function() { return /* binding */ SymbolToStringTag; },\n/* harmony export */   TypedArray: function() { return /* binding */ TypedArray; },\n/* harmony export */   TypedArrayPrototype: function() { return /* binding */ TypedArrayPrototype; },\n/* harmony export */   TypedArrayPrototypeCopyWithin: function() { return /* binding */ TypedArrayPrototypeCopyWithin; },\n/* harmony export */   TypedArrayPrototypeEntries: function() { return /* binding */ TypedArrayPrototypeEntries; },\n/* harmony export */   TypedArrayPrototypeFill: function() { return /* binding */ TypedArrayPrototypeFill; },\n/* harmony export */   TypedArrayPrototypeGetBuffer: function() { return /* binding */ TypedArrayPrototypeGetBuffer; },\n/* harmony export */   TypedArrayPrototypeGetByteOffset: function() { return /* binding */ TypedArrayPrototypeGetByteOffset; },\n/* harmony export */   TypedArrayPrototypeGetLength: function() { return /* binding */ TypedArrayPrototypeGetLength; },\n/* harmony export */   TypedArrayPrototypeGetSymbolToStringTag: function() { return /* binding */ TypedArrayPrototypeGetSymbolToStringTag; },\n/* harmony export */   TypedArrayPrototypeKeys: function() { return /* binding */ TypedArrayPrototypeKeys; },\n/* harmony export */   TypedArrayPrototypeReverse: function() { return /* binding */ TypedArrayPrototypeReverse; },\n/* harmony export */   TypedArrayPrototypeSet: function() { return /* binding */ TypedArrayPrototypeSet; },\n/* harmony export */   TypedArrayPrototypeSlice: function() { return /* binding */ TypedArrayPrototypeSlice; },\n/* harmony export */   TypedArrayPrototypeSort: function() { return /* binding */ TypedArrayPrototypeSort; },\n/* harmony export */   TypedArrayPrototypeSubarray: function() { return /* binding */ TypedArrayPrototypeSubarray; },\n/* harmony export */   TypedArrayPrototypeValues: function() { return /* binding */ TypedArrayPrototypeValues; },\n/* harmony export */   Uint16ArrayFrom: function() { return /* binding */ Uint16ArrayFrom; },\n/* harmony export */   WeakMapPrototypeGet: function() { return /* binding */ WeakMapPrototypeGet; },\n/* harmony export */   WeakMapPrototypeHas: function() { return /* binding */ WeakMapPrototypeHas; },\n/* harmony export */   WeakMapPrototypeSet: function() { return /* binding */ WeakMapPrototypeSet; },\n/* harmony export */   WeakSetPrototypeAdd: function() { return /* binding */ WeakSetPrototypeAdd; },\n/* harmony export */   WeakSetPrototypeHas: function() { return /* binding */ WeakSetPrototypeHas; }\n/* harmony export */ });\n/* harmony import */ var _messages_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./messages.mjs */ \"(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/messages.mjs\");\n/* eslint-disable no-restricted-globals, no-restricted-syntax */\n/* global SharedArrayBuffer */\n\n\n\n/** @type {<T extends (...args: any) => any>(target: T) => (thisArg: ThisType<T>, ...args: any[]) => any} */\nfunction uncurryThis(target) {\n  return (thisArg, ...args) => {\n    return ReflectApply(target, thisArg, args);\n  };\n}\n\n/** @type {(target: any, key: string | symbol) => (thisArg: any, ...args: any[]) => any} */\nfunction uncurryThisGetter(target, key) {\n  return uncurryThis(\n    ReflectGetOwnPropertyDescriptor(\n      target,\n      key\n    ).get\n  );\n}\n\n// Reflect\nconst {\n  apply: ReflectApply,\n  construct: ReflectConstruct,\n  defineProperty: ReflectDefineProperty,\n  get: ReflectGet,\n  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,\n  getPrototypeOf: ReflectGetPrototypeOf,\n  has: ReflectHas,\n  ownKeys: ReflectOwnKeys,\n  set: ReflectSet,\n  setPrototypeOf: ReflectSetPrototypeOf,\n} = Reflect;\n\n// Proxy\nconst NativeProxy = Proxy;\n\n// Number\nconst {\n  EPSILON,\n  MAX_SAFE_INTEGER,\n  isFinite: NumberIsFinite,\n  isNaN: NumberIsNaN,\n} = Number;\n\n// Symbol\nconst {\n  iterator: SymbolIterator,\n  species: SymbolSpecies,\n  toStringTag: SymbolToStringTag,\n  for: SymbolFor,\n} = Symbol;\n\n// Object\nconst NativeObject = Object;\nconst {\n  create: ObjectCreate,\n  defineProperty: ObjectDefineProperty,\n  freeze: ObjectFreeze,\n  is: ObjectIs,\n} = NativeObject;\nconst ObjectPrototype = NativeObject.prototype;\n/** @type {(object: object, key: PropertyKey) => Function | undefined} */\nconst ObjectPrototype__lookupGetter__ = /** @type {any} */ (ObjectPrototype).__lookupGetter__\n  ? uncurryThis(/** @type {any} */ (ObjectPrototype).__lookupGetter__)\n  : (object, key) => {\n    if (object == null) {\n      throw NativeTypeError(\n        _messages_mjs__WEBPACK_IMPORTED_MODULE_0__.CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT\n      );\n    }\n\n    let target = NativeObject(object);\n    do {\n      const descriptor = ReflectGetOwnPropertyDescriptor(target, key);\n      if (descriptor !== undefined) {\n        if (ObjectHasOwn(descriptor, \"get\")) {\n          return descriptor.get;\n        }\n\n        return;\n      }\n    } while ((target = ReflectGetPrototypeOf(target)) !== null);\n  };\n/** @type {(object: object, key: PropertyKey) => boolean} */\nconst ObjectHasOwn = /** @type {any} */ (NativeObject).hasOwn ||\n  uncurryThis(ObjectPrototype.hasOwnProperty);\n\n// Array\nconst NativeArray = Array;\nconst ArrayIsArray = NativeArray.isArray;\nconst ArrayPrototype = NativeArray.prototype;\n/** @type {(array: ArrayLike<unknown>, separator?: string) => string} */\nconst ArrayPrototypeJoin = uncurryThis(ArrayPrototype.join);\n/** @type {<T>(array: T[], ...items: T[]) => number} */\nconst ArrayPrototypePush = uncurryThis(ArrayPrototype.push);\n/** @type {(array: ArrayLike<unknown>, ...opts: any[]) => string} */\nconst ArrayPrototypeToLocaleString = uncurryThis(\n  ArrayPrototype.toLocaleString\n);\nconst NativeArrayPrototypeSymbolIterator = ArrayPrototype[SymbolIterator];\n/** @type {<T>(array: T[]) => IterableIterator<T>} */\nconst ArrayPrototypeSymbolIterator = uncurryThis(NativeArrayPrototypeSymbolIterator);\n\n// Math\nconst {\n  abs: MathAbs,\n  trunc: MathTrunc,\n} = Math;\n\n// ArrayBuffer\nconst NativeArrayBuffer = ArrayBuffer;\nconst ArrayBufferIsView = NativeArrayBuffer.isView;\nconst ArrayBufferPrototype = NativeArrayBuffer.prototype;\n/** @type {(buffer: ArrayBuffer, begin?: number, end?: number) => number} */\nconst ArrayBufferPrototypeSlice = uncurryThis(ArrayBufferPrototype.slice);\n/** @type {(buffer: ArrayBuffer) => ArrayBuffer} */\nconst ArrayBufferPrototypeGetByteLength = uncurryThisGetter(ArrayBufferPrototype, \"byteLength\");\n\n// SharedArrayBuffer\nconst NativeSharedArrayBuffer = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : null;\n/** @type {(buffer: SharedArrayBuffer) => SharedArrayBuffer} */\nconst SharedArrayBufferPrototypeGetByteLength = NativeSharedArrayBuffer\n  && uncurryThisGetter(NativeSharedArrayBuffer.prototype, \"byteLength\");\n\n// TypedArray\n/** @typedef {Uint8Array|Uint8ClampedArray|Uint16Array|Uint32Array|Int8Array|Int16Array|Int32Array|Float32Array|Float64Array|BigUint64Array|BigInt64Array} TypedArray */\n/** @type {any} */\nconst TypedArray = ReflectGetPrototypeOf(Uint8Array);\nconst TypedArrayFrom = TypedArray.from;\nconst TypedArrayPrototype = TypedArray.prototype;\nconst NativeTypedArrayPrototypeSymbolIterator = TypedArrayPrototype[SymbolIterator];\n/** @type {(typedArray: TypedArray) => IterableIterator<number>} */\nconst TypedArrayPrototypeKeys = uncurryThis(TypedArrayPrototype.keys);\n/** @type {(typedArray: TypedArray) => IterableIterator<number>} */\nconst TypedArrayPrototypeValues = uncurryThis(\n  TypedArrayPrototype.values\n);\n/** @type {(typedArray: TypedArray) => IterableIterator<[number, number]>} */\nconst TypedArrayPrototypeEntries = uncurryThis(\n  TypedArrayPrototype.entries\n);\n/** @type {(typedArray: TypedArray, array: ArrayLike<number>, offset?: number) => void} */\nconst TypedArrayPrototypeSet = uncurryThis(TypedArrayPrototype.set);\n/** @type {<T extends TypedArray>(typedArray: T) => T} */\nconst TypedArrayPrototypeReverse = uncurryThis(\n  TypedArrayPrototype.reverse\n);\n/** @type {<T extends TypedArray>(typedArray: T, value: number, start?: number, end?: number) => T} */\nconst TypedArrayPrototypeFill = uncurryThis(TypedArrayPrototype.fill);\n/** @type {<T extends TypedArray>(typedArray: T, target: number, start: number, end?: number) => T} */\nconst TypedArrayPrototypeCopyWithin = uncurryThis(\n  TypedArrayPrototype.copyWithin\n);\n/** @type {<T extends TypedArray>(typedArray: T, compareFn?: (a: number, b: number) => number) => T} */\nconst TypedArrayPrototypeSort = uncurryThis(TypedArrayPrototype.sort);\n/** @type {<T extends TypedArray>(typedArray: T, start?: number, end?: number) => T} */\nconst TypedArrayPrototypeSlice = uncurryThis(TypedArrayPrototype.slice);\n/** @type {<T extends TypedArray>(typedArray: T, start?: number, end?: number) => T} */\nconst TypedArrayPrototypeSubarray = uncurryThis(\n  TypedArrayPrototype.subarray\n);\n/** @type {((typedArray: TypedArray) => ArrayBuffer)} */\nconst TypedArrayPrototypeGetBuffer = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"buffer\"\n);\n/** @type {((typedArray: TypedArray) => number)} */\nconst TypedArrayPrototypeGetByteOffset = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"byteOffset\"\n);\n/** @type {((typedArray: TypedArray) => number)} */\nconst TypedArrayPrototypeGetLength = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"length\"\n);\n/** @type {(target: unknown) => string} */\nconst TypedArrayPrototypeGetSymbolToStringTag = uncurryThisGetter(\n  TypedArrayPrototype,\n  SymbolToStringTag\n);\n\n// Uint8Array\nconst NativeUint8Array = Uint8Array;\n\n// Uint16Array\nconst NativeUint16Array = Uint16Array;\n/** @type {Uint16ArrayConstructor[\"from\"]} */\nconst Uint16ArrayFrom = (...args) => {\n  return ReflectApply(TypedArrayFrom, NativeUint16Array, args);\n};\n\n// Uint32Array\nconst NativeUint32Array = Uint32Array;\n\n// Float32Array\nconst NativeFloat32Array = Float32Array;\n\n// ArrayIterator\n/** @type {any} */\nconst ArrayIteratorPrototype = ReflectGetPrototypeOf([][SymbolIterator]());\n/** @type {<T>(arrayIterator: IterableIterator<T>) => IteratorResult<T>} */\nconst ArrayIteratorPrototypeNext = uncurryThis(ArrayIteratorPrototype.next);\n\n// Generator\n/** @type {<T = unknown, TReturn = any, TNext = unknown>(generator: Generator<T, TReturn, TNext>, value?: TNext) => T} */\nconst GeneratorPrototypeNext = uncurryThis((function* () {})().next);\n\n// Iterator\nconst IteratorPrototype = ReflectGetPrototypeOf(ArrayIteratorPrototype);\n\n// DataView\nconst DataViewPrototype = DataView.prototype;\n/** @type {(dataView: DataView, byteOffset: number, littleEndian?: boolean) => number} */\nconst DataViewPrototypeGetUint16 = uncurryThis(\n  DataViewPrototype.getUint16\n);\n/** @type {(dataView: DataView, byteOffset: number, value: number, littleEndian?: boolean) => void} */\nconst DataViewPrototypeSetUint16 = uncurryThis(\n  DataViewPrototype.setUint16\n);\n\n// Error\nconst NativeTypeError = TypeError;\nconst NativeRangeError = RangeError;\n\n// WeakSet\n/**\n * Do not construct with arguments to avoid calling the \"add\" method\n * @type {{new <T extends {}>(): WeakSet<T>}}\n */\nconst NativeWeakSet = WeakSet;\nconst WeakSetPrototype = NativeWeakSet.prototype;\n/** @type {<T extends {}>(set: WeakSet<T>, value: T) => Set<T>} */\nconst WeakSetPrototypeAdd = uncurryThis(WeakSetPrototype.add);\n/** @type {<T extends {}>(set: WeakSet<T>, value: T) => boolean} */\nconst WeakSetPrototypeHas = uncurryThis(WeakSetPrototype.has);\n\n// WeakMap\n/**\n * Do not construct with arguments to avoid calling the \"set\" method\n * @type {{new <K extends {}, V>(): WeakMap<K, V>}}\n */\nconst NativeWeakMap = WeakMap;\nconst WeakMapPrototype = NativeWeakMap.prototype;\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K) => V} */\nconst WeakMapPrototypeGet = uncurryThis(WeakMapPrototype.get);\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K) => boolean} */\nconst WeakMapPrototypeHas = uncurryThis(WeakMapPrototype.has);\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K, value: V) => WeakMap} */\nconst WeakMapPrototypeSet = uncurryThis(WeakMapPrototype.set);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGV0YW1vcmlrZW4vZmxvYXQxNi9zcmMvX3V0aWwvcHJpbW9yZGlhbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRTRFOztBQUU1RSxXQUFXLCtGQUErRjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsOEVBQThFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNPOztBQUVQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLFdBQVcsNERBQTREO0FBQ2hFLG1EQUFtRCxLQUFLO0FBQy9ELDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFFBQVEscUZBQTBDO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLFdBQVcsK0NBQStDO0FBQ25ELGdDQUFnQyxLQUFLO0FBQzVDOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsV0FBVywyREFBMkQ7QUFDL0Q7QUFDUCxXQUFXLDBDQUEwQztBQUM5QztBQUNQLFdBQVcsdURBQXVEO0FBQzNEO0FBQ1A7QUFDQTtBQUNPO0FBQ1AsV0FBVyx3Q0FBd0M7QUFDNUM7O0FBRVA7QUFDTztBQUNQO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ087QUFDQTtBQUNQO0FBQ0EsV0FBVywrREFBK0Q7QUFDbkU7QUFDUCxXQUFXLHNDQUFzQztBQUMxQzs7QUFFUDtBQUNPO0FBQ1AsV0FBVyxrREFBa0Q7QUFDdEQ7QUFDUDs7QUFFQTtBQUNBLGNBQWMsNklBQTZJO0FBQzNKLFdBQVcsS0FBSztBQUNUO0FBQ1A7QUFDTztBQUNBO0FBQ1AsV0FBVyxzREFBc0Q7QUFDMUQ7QUFDUCxXQUFXLHNEQUFzRDtBQUMxRDtBQUNQO0FBQ0E7QUFDQSxXQUFXLGdFQUFnRTtBQUNwRTtBQUNQO0FBQ0E7QUFDQSxXQUFXLDZFQUE2RTtBQUNqRjtBQUNQLFdBQVcsNENBQTRDO0FBQ2hEO0FBQ1A7QUFDQTtBQUNBLFdBQVcseUZBQXlGO0FBQzdGO0FBQ1AsV0FBVyx5RkFBeUY7QUFDN0Y7QUFDUDtBQUNBO0FBQ0EsV0FBVywwRkFBMEY7QUFDOUY7QUFDUCxXQUFXLDBFQUEwRTtBQUM5RTtBQUNQLFdBQVcsMEVBQTBFO0FBQzlFO0FBQ1A7QUFDQTtBQUNBLFdBQVcsMkNBQTJDO0FBQy9DO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQ0FBc0M7QUFDMUM7QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNDQUFzQztBQUMxQztBQUNQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkJBQTZCO0FBQ2pDO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ087O0FBRVA7QUFDTztBQUNQLFdBQVcsZ0NBQWdDO0FBQ3BDO0FBQ1A7QUFDQTs7QUFFQTtBQUNPOztBQUVQO0FBQ087O0FBRVA7QUFDQSxXQUFXLEtBQUs7QUFDVDtBQUNQLFdBQVcsOERBQThEO0FBQ2xFOztBQUVQO0FBQ0EsV0FBVyw0R0FBNEc7QUFDaEgsMkRBQTJEOztBQUVsRTtBQUNPOztBQUVQO0FBQ0E7QUFDQSxXQUFXLDRFQUE0RTtBQUNoRjtBQUNQO0FBQ0E7QUFDQSxXQUFXLHlGQUF5RjtBQUM3RjtBQUNQO0FBQ0E7O0FBRUE7QUFDTztBQUNBOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ087QUFDUDtBQUNBLFdBQVcsYUFBYSx3Q0FBd0M7QUFDekQ7QUFDUCxXQUFXLGFBQWEseUNBQXlDO0FBQzFEOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ087QUFDUDtBQUNBLFdBQVcsYUFBYSwyQ0FBMkM7QUFDNUQ7QUFDUCxXQUFXLGFBQWEsaURBQWlEO0FBQ2xFO0FBQ1AsV0FBVyxhQUFhLDJEQUEyRDtBQUM1RSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHBldGFtb3Jpa2VuL2Zsb2F0MTYvc3JjL191dGlsL3ByaW1vcmRpYWxzLm1qcz9lM2UwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscywgbm8tcmVzdHJpY3RlZC1zeW50YXggKi9cbi8qIGdsb2JhbCBTaGFyZWRBcnJheUJ1ZmZlciAqL1xuXG5pbXBvcnQgeyBDQU5OT1RfQ09OVkVSVF9VTkRFRklORURfT1JfTlVMTF9UT19PQkpFQ1QgfSBmcm9tIFwiLi9tZXNzYWdlcy5tanNcIjtcblxuLyoqIEB0eXBlIHs8VCBleHRlbmRzICguLi5hcmdzOiBhbnkpID0+IGFueT4odGFyZ2V0OiBUKSA9PiAodGhpc0FyZzogVGhpc1R5cGU8VD4sIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnl9ICovXG5mdW5jdGlvbiB1bmN1cnJ5VGhpcyh0YXJnZXQpIHtcbiAgcmV0dXJuICh0aGlzQXJnLCAuLi5hcmdzKSA9PiB7XG4gICAgcmV0dXJuIFJlZmxlY3RBcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ3MpO1xuICB9O1xufVxuXG4vKiogQHR5cGUgeyh0YXJnZXQ6IGFueSwga2V5OiBzdHJpbmcgfCBzeW1ib2wpID0+ICh0aGlzQXJnOiBhbnksIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnl9ICovXG5mdW5jdGlvbiB1bmN1cnJ5VGhpc0dldHRlcih0YXJnZXQsIGtleSkge1xuICByZXR1cm4gdW5jdXJyeVRoaXMoXG4gICAgUmVmbGVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgIHRhcmdldCxcbiAgICAgIGtleVxuICAgICkuZ2V0XG4gICk7XG59XG5cbi8vIFJlZmxlY3RcbmV4cG9ydCBjb25zdCB7XG4gIGFwcGx5OiBSZWZsZWN0QXBwbHksXG4gIGNvbnN0cnVjdDogUmVmbGVjdENvbnN0cnVjdCxcbiAgZGVmaW5lUHJvcGVydHk6IFJlZmxlY3REZWZpbmVQcm9wZXJ0eSxcbiAgZ2V0OiBSZWZsZWN0R2V0LFxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IFJlZmxlY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIGdldFByb3RvdHlwZU9mOiBSZWZsZWN0R2V0UHJvdG90eXBlT2YsXG4gIGhhczogUmVmbGVjdEhhcyxcbiAgb3duS2V5czogUmVmbGVjdE93bktleXMsXG4gIHNldDogUmVmbGVjdFNldCxcbiAgc2V0UHJvdG90eXBlT2Y6IFJlZmxlY3RTZXRQcm90b3R5cGVPZixcbn0gPSBSZWZsZWN0O1xuXG4vLyBQcm94eVxuZXhwb3J0IGNvbnN0IE5hdGl2ZVByb3h5ID0gUHJveHk7XG5cbi8vIE51bWJlclxuZXhwb3J0IGNvbnN0IHtcbiAgRVBTSUxPTixcbiAgTUFYX1NBRkVfSU5URUdFUixcbiAgaXNGaW5pdGU6IE51bWJlcklzRmluaXRlLFxuICBpc05hTjogTnVtYmVySXNOYU4sXG59ID0gTnVtYmVyO1xuXG4vLyBTeW1ib2xcbmV4cG9ydCBjb25zdCB7XG4gIGl0ZXJhdG9yOiBTeW1ib2xJdGVyYXRvcixcbiAgc3BlY2llczogU3ltYm9sU3BlY2llcyxcbiAgdG9TdHJpbmdUYWc6IFN5bWJvbFRvU3RyaW5nVGFnLFxuICBmb3I6IFN5bWJvbEZvcixcbn0gPSBTeW1ib2w7XG5cbi8vIE9iamVjdFxuZXhwb3J0IGNvbnN0IE5hdGl2ZU9iamVjdCA9IE9iamVjdDtcbmV4cG9ydCBjb25zdCB7XG4gIGNyZWF0ZTogT2JqZWN0Q3JlYXRlLFxuICBkZWZpbmVQcm9wZXJ0eTogT2JqZWN0RGVmaW5lUHJvcGVydHksXG4gIGZyZWV6ZTogT2JqZWN0RnJlZXplLFxuICBpczogT2JqZWN0SXMsXG59ID0gTmF0aXZlT2JqZWN0O1xuY29uc3QgT2JqZWN0UHJvdG90eXBlID0gTmF0aXZlT2JqZWN0LnByb3RvdHlwZTtcbi8qKiBAdHlwZSB7KG9iamVjdDogb2JqZWN0LCBrZXk6IFByb3BlcnR5S2V5KSA9PiBGdW5jdGlvbiB8IHVuZGVmaW5lZH0gKi9cbmV4cG9ydCBjb25zdCBPYmplY3RQcm90b3R5cGVfX2xvb2t1cEdldHRlcl9fID0gLyoqIEB0eXBlIHthbnl9ICovIChPYmplY3RQcm90b3R5cGUpLl9fbG9va3VwR2V0dGVyX19cbiAgPyB1bmN1cnJ5VGhpcygvKiogQHR5cGUge2FueX0gKi8gKE9iamVjdFByb3RvdHlwZSkuX19sb29rdXBHZXR0ZXJfXylcbiAgOiAob2JqZWN0LCBrZXkpID0+IHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHRocm93IE5hdGl2ZVR5cGVFcnJvcihcbiAgICAgICAgQ0FOTk9UX0NPTlZFUlRfVU5ERUZJTkVEX09SX05VTExfVE9fT0JKRUNUXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCB0YXJnZXQgPSBOYXRpdmVPYmplY3Qob2JqZWN0KTtcbiAgICBkbyB7XG4gICAgICBjb25zdCBkZXNjcmlwdG9yID0gUmVmbGVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gICAgICBpZiAoZGVzY3JpcHRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChPYmplY3RIYXNPd24oZGVzY3JpcHRvciwgXCJnZXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvci5nZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSB3aGlsZSAoKHRhcmdldCA9IFJlZmxlY3RHZXRQcm90b3R5cGVPZih0YXJnZXQpKSAhPT0gbnVsbCk7XG4gIH07XG4vKiogQHR5cGUgeyhvYmplY3Q6IG9iamVjdCwga2V5OiBQcm9wZXJ0eUtleSkgPT4gYm9vbGVhbn0gKi9cbmV4cG9ydCBjb25zdCBPYmplY3RIYXNPd24gPSAvKiogQHR5cGUge2FueX0gKi8gKE5hdGl2ZU9iamVjdCkuaGFzT3duIHx8XG4gIHVuY3VycnlUaGlzKE9iamVjdFByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbi8vIEFycmF5XG5jb25zdCBOYXRpdmVBcnJheSA9IEFycmF5O1xuZXhwb3J0IGNvbnN0IEFycmF5SXNBcnJheSA9IE5hdGl2ZUFycmF5LmlzQXJyYXk7XG5jb25zdCBBcnJheVByb3RvdHlwZSA9IE5hdGl2ZUFycmF5LnByb3RvdHlwZTtcbi8qKiBAdHlwZSB7KGFycmF5OiBBcnJheUxpa2U8dW5rbm93bj4sIHNlcGFyYXRvcj86IHN0cmluZykgPT4gc3RyaW5nfSAqL1xuZXhwb3J0IGNvbnN0IEFycmF5UHJvdG90eXBlSm9pbiA9IHVuY3VycnlUaGlzKEFycmF5UHJvdG90eXBlLmpvaW4pO1xuLyoqIEB0eXBlIHs8VD4oYXJyYXk6IFRbXSwgLi4uaXRlbXM6IFRbXSkgPT4gbnVtYmVyfSAqL1xuZXhwb3J0IGNvbnN0IEFycmF5UHJvdG90eXBlUHVzaCA9IHVuY3VycnlUaGlzKEFycmF5UHJvdG90eXBlLnB1c2gpO1xuLyoqIEB0eXBlIHsoYXJyYXk6IEFycmF5TGlrZTx1bmtub3duPiwgLi4ub3B0czogYW55W10pID0+IHN0cmluZ30gKi9cbmV4cG9ydCBjb25zdCBBcnJheVByb3RvdHlwZVRvTG9jYWxlU3RyaW5nID0gdW5jdXJyeVRoaXMoXG4gIEFycmF5UHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nXG4pO1xuZXhwb3J0IGNvbnN0IE5hdGl2ZUFycmF5UHJvdG90eXBlU3ltYm9sSXRlcmF0b3IgPSBBcnJheVByb3RvdHlwZVtTeW1ib2xJdGVyYXRvcl07XG4vKiogQHR5cGUgezxUPihhcnJheTogVFtdKSA9PiBJdGVyYWJsZUl0ZXJhdG9yPFQ+fSAqL1xuZXhwb3J0IGNvbnN0IEFycmF5UHJvdG90eXBlU3ltYm9sSXRlcmF0b3IgPSB1bmN1cnJ5VGhpcyhOYXRpdmVBcnJheVByb3RvdHlwZVN5bWJvbEl0ZXJhdG9yKTtcblxuLy8gTWF0aFxuZXhwb3J0IGNvbnN0IHtcbiAgYWJzOiBNYXRoQWJzLFxuICB0cnVuYzogTWF0aFRydW5jLFxufSA9IE1hdGg7XG5cbi8vIEFycmF5QnVmZmVyXG5leHBvcnQgY29uc3QgTmF0aXZlQXJyYXlCdWZmZXIgPSBBcnJheUJ1ZmZlcjtcbmV4cG9ydCBjb25zdCBBcnJheUJ1ZmZlcklzVmlldyA9IE5hdGl2ZUFycmF5QnVmZmVyLmlzVmlldztcbmNvbnN0IEFycmF5QnVmZmVyUHJvdG90eXBlID0gTmF0aXZlQXJyYXlCdWZmZXIucHJvdG90eXBlO1xuLyoqIEB0eXBlIHsoYnVmZmVyOiBBcnJheUJ1ZmZlciwgYmVnaW4/OiBudW1iZXIsIGVuZD86IG51bWJlcikgPT4gbnVtYmVyfSAqL1xuZXhwb3J0IGNvbnN0IEFycmF5QnVmZmVyUHJvdG90eXBlU2xpY2UgPSB1bmN1cnJ5VGhpcyhBcnJheUJ1ZmZlclByb3RvdHlwZS5zbGljZSk7XG4vKiogQHR5cGUgeyhidWZmZXI6IEFycmF5QnVmZmVyKSA9PiBBcnJheUJ1ZmZlcn0gKi9cbmV4cG9ydCBjb25zdCBBcnJheUJ1ZmZlclByb3RvdHlwZUdldEJ5dGVMZW5ndGggPSB1bmN1cnJ5VGhpc0dldHRlcihBcnJheUJ1ZmZlclByb3RvdHlwZSwgXCJieXRlTGVuZ3RoXCIpO1xuXG4vLyBTaGFyZWRBcnJheUJ1ZmZlclxuZXhwb3J0IGNvbnN0IE5hdGl2ZVNoYXJlZEFycmF5QnVmZmVyID0gdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSBcInVuZGVmaW5lZFwiID8gU2hhcmVkQXJyYXlCdWZmZXIgOiBudWxsO1xuLyoqIEB0eXBlIHsoYnVmZmVyOiBTaGFyZWRBcnJheUJ1ZmZlcikgPT4gU2hhcmVkQXJyYXlCdWZmZXJ9ICovXG5leHBvcnQgY29uc3QgU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGVHZXRCeXRlTGVuZ3RoID0gTmF0aXZlU2hhcmVkQXJyYXlCdWZmZXJcbiAgJiYgdW5jdXJyeVRoaXNHZXR0ZXIoTmF0aXZlU2hhcmVkQXJyYXlCdWZmZXIucHJvdG90eXBlLCBcImJ5dGVMZW5ndGhcIik7XG5cbi8vIFR5cGVkQXJyYXlcbi8qKiBAdHlwZWRlZiB7VWludDhBcnJheXxVaW50OENsYW1wZWRBcnJheXxVaW50MTZBcnJheXxVaW50MzJBcnJheXxJbnQ4QXJyYXl8SW50MTZBcnJheXxJbnQzMkFycmF5fEZsb2F0MzJBcnJheXxGbG9hdDY0QXJyYXl8QmlnVWludDY0QXJyYXl8QmlnSW50NjRBcnJheX0gVHlwZWRBcnJheSAqL1xuLyoqIEB0eXBlIHthbnl9ICovXG5leHBvcnQgY29uc3QgVHlwZWRBcnJheSA9IFJlZmxlY3RHZXRQcm90b3R5cGVPZihVaW50OEFycmF5KTtcbmNvbnN0IFR5cGVkQXJyYXlGcm9tID0gVHlwZWRBcnJheS5mcm9tO1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5LnByb3RvdHlwZTtcbmV4cG9ydCBjb25zdCBOYXRpdmVUeXBlZEFycmF5UHJvdG90eXBlU3ltYm9sSXRlcmF0b3IgPSBUeXBlZEFycmF5UHJvdG90eXBlW1N5bWJvbEl0ZXJhdG9yXTtcbi8qKiBAdHlwZSB7KHR5cGVkQXJyYXk6IFR5cGVkQXJyYXkpID0+IEl0ZXJhYmxlSXRlcmF0b3I8bnVtYmVyPn0gKi9cbmV4cG9ydCBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlS2V5cyA9IHVuY3VycnlUaGlzKFR5cGVkQXJyYXlQcm90b3R5cGUua2V5cyk7XG4vKiogQHR5cGUgeyh0eXBlZEFycmF5OiBUeXBlZEFycmF5KSA9PiBJdGVyYWJsZUl0ZXJhdG9yPG51bWJlcj59ICovXG5leHBvcnQgY29uc3QgVHlwZWRBcnJheVByb3RvdHlwZVZhbHVlcyA9IHVuY3VycnlUaGlzKFxuICBUeXBlZEFycmF5UHJvdG90eXBlLnZhbHVlc1xuKTtcbi8qKiBAdHlwZSB7KHR5cGVkQXJyYXk6IFR5cGVkQXJyYXkpID0+IEl0ZXJhYmxlSXRlcmF0b3I8W251bWJlciwgbnVtYmVyXT59ICovXG5leHBvcnQgY29uc3QgVHlwZWRBcnJheVByb3RvdHlwZUVudHJpZXMgPSB1bmN1cnJ5VGhpcyhcbiAgVHlwZWRBcnJheVByb3RvdHlwZS5lbnRyaWVzXG4pO1xuLyoqIEB0eXBlIHsodHlwZWRBcnJheTogVHlwZWRBcnJheSwgYXJyYXk6IEFycmF5TGlrZTxudW1iZXI+LCBvZmZzZXQ/OiBudW1iZXIpID0+IHZvaWR9ICovXG5leHBvcnQgY29uc3QgVHlwZWRBcnJheVByb3RvdHlwZVNldCA9IHVuY3VycnlUaGlzKFR5cGVkQXJyYXlQcm90b3R5cGUuc2V0KTtcbi8qKiBAdHlwZSB7PFQgZXh0ZW5kcyBUeXBlZEFycmF5Pih0eXBlZEFycmF5OiBUKSA9PiBUfSAqL1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVSZXZlcnNlID0gdW5jdXJyeVRoaXMoXG4gIFR5cGVkQXJyYXlQcm90b3R5cGUucmV2ZXJzZVxuKTtcbi8qKiBAdHlwZSB7PFQgZXh0ZW5kcyBUeXBlZEFycmF5Pih0eXBlZEFycmF5OiBULCB2YWx1ZTogbnVtYmVyLCBzdGFydD86IG51bWJlciwgZW5kPzogbnVtYmVyKSA9PiBUfSAqL1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVGaWxsID0gdW5jdXJyeVRoaXMoVHlwZWRBcnJheVByb3RvdHlwZS5maWxsKTtcbi8qKiBAdHlwZSB7PFQgZXh0ZW5kcyBUeXBlZEFycmF5Pih0eXBlZEFycmF5OiBULCB0YXJnZXQ6IG51bWJlciwgc3RhcnQ6IG51bWJlciwgZW5kPzogbnVtYmVyKSA9PiBUfSAqL1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVDb3B5V2l0aGluID0gdW5jdXJyeVRoaXMoXG4gIFR5cGVkQXJyYXlQcm90b3R5cGUuY29weVdpdGhpblxuKTtcbi8qKiBAdHlwZSB7PFQgZXh0ZW5kcyBUeXBlZEFycmF5Pih0eXBlZEFycmF5OiBULCBjb21wYXJlRm4/OiAoYTogbnVtYmVyLCBiOiBudW1iZXIpID0+IG51bWJlcikgPT4gVH0gKi9cbmV4cG9ydCBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlU29ydCA9IHVuY3VycnlUaGlzKFR5cGVkQXJyYXlQcm90b3R5cGUuc29ydCk7XG4vKiogQHR5cGUgezxUIGV4dGVuZHMgVHlwZWRBcnJheT4odHlwZWRBcnJheTogVCwgc3RhcnQ/OiBudW1iZXIsIGVuZD86IG51bWJlcikgPT4gVH0gKi9cbmV4cG9ydCBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlU2xpY2UgPSB1bmN1cnJ5VGhpcyhUeXBlZEFycmF5UHJvdG90eXBlLnNsaWNlKTtcbi8qKiBAdHlwZSB7PFQgZXh0ZW5kcyBUeXBlZEFycmF5Pih0eXBlZEFycmF5OiBULCBzdGFydD86IG51bWJlciwgZW5kPzogbnVtYmVyKSA9PiBUfSAqL1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVTdWJhcnJheSA9IHVuY3VycnlUaGlzKFxuICBUeXBlZEFycmF5UHJvdG90eXBlLnN1YmFycmF5XG4pO1xuLyoqIEB0eXBlIHsoKHR5cGVkQXJyYXk6IFR5cGVkQXJyYXkpID0+IEFycmF5QnVmZmVyKX0gKi9cbmV4cG9ydCBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlR2V0QnVmZmVyID0gdW5jdXJyeVRoaXNHZXR0ZXIoXG4gIFR5cGVkQXJyYXlQcm90b3R5cGUsXG4gIFwiYnVmZmVyXCJcbik7XG4vKiogQHR5cGUgeygodHlwZWRBcnJheTogVHlwZWRBcnJheSkgPT4gbnVtYmVyKX0gKi9cbmV4cG9ydCBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlR2V0Qnl0ZU9mZnNldCA9IHVuY3VycnlUaGlzR2V0dGVyKFxuICBUeXBlZEFycmF5UHJvdG90eXBlLFxuICBcImJ5dGVPZmZzZXRcIlxuKTtcbi8qKiBAdHlwZSB7KCh0eXBlZEFycmF5OiBUeXBlZEFycmF5KSA9PiBudW1iZXIpfSAqL1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVHZXRMZW5ndGggPSB1bmN1cnJ5VGhpc0dldHRlcihcbiAgVHlwZWRBcnJheVByb3RvdHlwZSxcbiAgXCJsZW5ndGhcIlxuKTtcbi8qKiBAdHlwZSB7KHRhcmdldDogdW5rbm93bikgPT4gc3RyaW5nfSAqL1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVHZXRTeW1ib2xUb1N0cmluZ1RhZyA9IHVuY3VycnlUaGlzR2V0dGVyKFxuICBUeXBlZEFycmF5UHJvdG90eXBlLFxuICBTeW1ib2xUb1N0cmluZ1RhZ1xuKTtcblxuLy8gVWludDhBcnJheVxuZXhwb3J0IGNvbnN0IE5hdGl2ZVVpbnQ4QXJyYXkgPSBVaW50OEFycmF5O1xuXG4vLyBVaW50MTZBcnJheVxuZXhwb3J0IGNvbnN0IE5hdGl2ZVVpbnQxNkFycmF5ID0gVWludDE2QXJyYXk7XG4vKiogQHR5cGUge1VpbnQxNkFycmF5Q29uc3RydWN0b3JbXCJmcm9tXCJdfSAqL1xuZXhwb3J0IGNvbnN0IFVpbnQxNkFycmF5RnJvbSA9ICguLi5hcmdzKSA9PiB7XG4gIHJldHVybiBSZWZsZWN0QXBwbHkoVHlwZWRBcnJheUZyb20sIE5hdGl2ZVVpbnQxNkFycmF5LCBhcmdzKTtcbn07XG5cbi8vIFVpbnQzMkFycmF5XG5leHBvcnQgY29uc3QgTmF0aXZlVWludDMyQXJyYXkgPSBVaW50MzJBcnJheTtcblxuLy8gRmxvYXQzMkFycmF5XG5leHBvcnQgY29uc3QgTmF0aXZlRmxvYXQzMkFycmF5ID0gRmxvYXQzMkFycmF5O1xuXG4vLyBBcnJheUl0ZXJhdG9yXG4vKiogQHR5cGUge2FueX0gKi9cbmV4cG9ydCBjb25zdCBBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gUmVmbGVjdEdldFByb3RvdHlwZU9mKFtdW1N5bWJvbEl0ZXJhdG9yXSgpKTtcbi8qKiBAdHlwZSB7PFQ+KGFycmF5SXRlcmF0b3I6IEl0ZXJhYmxlSXRlcmF0b3I8VD4pID0+IEl0ZXJhdG9yUmVzdWx0PFQ+fSAqL1xuZXhwb3J0IGNvbnN0IEFycmF5SXRlcmF0b3JQcm90b3R5cGVOZXh0ID0gdW5jdXJyeVRoaXMoQXJyYXlJdGVyYXRvclByb3RvdHlwZS5uZXh0KTtcblxuLy8gR2VuZXJhdG9yXG4vKiogQHR5cGUgezxUID0gdW5rbm93biwgVFJldHVybiA9IGFueSwgVE5leHQgPSB1bmtub3duPihnZW5lcmF0b3I6IEdlbmVyYXRvcjxULCBUUmV0dXJuLCBUTmV4dD4sIHZhbHVlPzogVE5leHQpID0+IFR9ICovXG5leHBvcnQgY29uc3QgR2VuZXJhdG9yUHJvdG90eXBlTmV4dCA9IHVuY3VycnlUaGlzKChmdW5jdGlvbiogKCkge30pKCkubmV4dCk7XG5cbi8vIEl0ZXJhdG9yXG5leHBvcnQgY29uc3QgSXRlcmF0b3JQcm90b3R5cGUgPSBSZWZsZWN0R2V0UHJvdG90eXBlT2YoQXJyYXlJdGVyYXRvclByb3RvdHlwZSk7XG5cbi8vIERhdGFWaWV3XG5jb25zdCBEYXRhVmlld1Byb3RvdHlwZSA9IERhdGFWaWV3LnByb3RvdHlwZTtcbi8qKiBAdHlwZSB7KGRhdGFWaWV3OiBEYXRhVmlldywgYnl0ZU9mZnNldDogbnVtYmVyLCBsaXR0bGVFbmRpYW4/OiBib29sZWFuKSA9PiBudW1iZXJ9ICovXG5leHBvcnQgY29uc3QgRGF0YVZpZXdQcm90b3R5cGVHZXRVaW50MTYgPSB1bmN1cnJ5VGhpcyhcbiAgRGF0YVZpZXdQcm90b3R5cGUuZ2V0VWludDE2XG4pO1xuLyoqIEB0eXBlIHsoZGF0YVZpZXc6IERhdGFWaWV3LCBieXRlT2Zmc2V0OiBudW1iZXIsIHZhbHVlOiBudW1iZXIsIGxpdHRsZUVuZGlhbj86IGJvb2xlYW4pID0+IHZvaWR9ICovXG5leHBvcnQgY29uc3QgRGF0YVZpZXdQcm90b3R5cGVTZXRVaW50MTYgPSB1bmN1cnJ5VGhpcyhcbiAgRGF0YVZpZXdQcm90b3R5cGUuc2V0VWludDE2XG4pO1xuXG4vLyBFcnJvclxuZXhwb3J0IGNvbnN0IE5hdGl2ZVR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbmV4cG9ydCBjb25zdCBOYXRpdmVSYW5nZUVycm9yID0gUmFuZ2VFcnJvcjtcblxuLy8gV2Vha1NldFxuLyoqXG4gKiBEbyBub3QgY29uc3RydWN0IHdpdGggYXJndW1lbnRzIHRvIGF2b2lkIGNhbGxpbmcgdGhlIFwiYWRkXCIgbWV0aG9kXG4gKiBAdHlwZSB7e25ldyA8VCBleHRlbmRzIHt9PigpOiBXZWFrU2V0PFQ+fX1cbiAqL1xuZXhwb3J0IGNvbnN0IE5hdGl2ZVdlYWtTZXQgPSBXZWFrU2V0O1xuY29uc3QgV2Vha1NldFByb3RvdHlwZSA9IE5hdGl2ZVdlYWtTZXQucHJvdG90eXBlO1xuLyoqIEB0eXBlIHs8VCBleHRlbmRzIHt9PihzZXQ6IFdlYWtTZXQ8VD4sIHZhbHVlOiBUKSA9PiBTZXQ8VD59ICovXG5leHBvcnQgY29uc3QgV2Vha1NldFByb3RvdHlwZUFkZCA9IHVuY3VycnlUaGlzKFdlYWtTZXRQcm90b3R5cGUuYWRkKTtcbi8qKiBAdHlwZSB7PFQgZXh0ZW5kcyB7fT4oc2V0OiBXZWFrU2V0PFQ+LCB2YWx1ZTogVCkgPT4gYm9vbGVhbn0gKi9cbmV4cG9ydCBjb25zdCBXZWFrU2V0UHJvdG90eXBlSGFzID0gdW5jdXJyeVRoaXMoV2Vha1NldFByb3RvdHlwZS5oYXMpO1xuXG4vLyBXZWFrTWFwXG4vKipcbiAqIERvIG5vdCBjb25zdHJ1Y3Qgd2l0aCBhcmd1bWVudHMgdG8gYXZvaWQgY2FsbGluZyB0aGUgXCJzZXRcIiBtZXRob2RcbiAqIEB0eXBlIHt7bmV3IDxLIGV4dGVuZHMge30sIFY+KCk6IFdlYWtNYXA8SywgVj59fVxuICovXG5leHBvcnQgY29uc3QgTmF0aXZlV2Vha01hcCA9IFdlYWtNYXA7XG5jb25zdCBXZWFrTWFwUHJvdG90eXBlID0gTmF0aXZlV2Vha01hcC5wcm90b3R5cGU7XG4vKiogQHR5cGUgezxLIGV4dGVuZHMge30sIFY+KHdlYWtNYXA6IFdlYWtNYXA8SywgVj4sIGtleTogSykgPT4gVn0gKi9cbmV4cG9ydCBjb25zdCBXZWFrTWFwUHJvdG90eXBlR2V0ID0gdW5jdXJyeVRoaXMoV2Vha01hcFByb3RvdHlwZS5nZXQpO1xuLyoqIEB0eXBlIHs8SyBleHRlbmRzIHt9LCBWPih3ZWFrTWFwOiBXZWFrTWFwPEssIFY+LCBrZXk6IEspID0+IGJvb2xlYW59ICovXG5leHBvcnQgY29uc3QgV2Vha01hcFByb3RvdHlwZUhhcyA9IHVuY3VycnlUaGlzKFdlYWtNYXBQcm90b3R5cGUuaGFzKTtcbi8qKiBAdHlwZSB7PEsgZXh0ZW5kcyB7fSwgVj4od2Vha01hcDogV2Vha01hcDxLLCBWPiwga2V5OiBLLCB2YWx1ZTogVikgPT4gV2Vha01hcH0gKi9cbmV4cG9ydCBjb25zdCBXZWFrTWFwUHJvdG90eXBlU2V0ID0gdW5jdXJyeVRoaXMoV2Vha01hcFByb3RvdHlwZS5zZXQpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/primordials.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/compression/basedecoder.js":
/*!*********************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/basedecoder.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ BaseDecoder; }\n/* harmony export */ });\n/* harmony import */ var _predictor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../predictor.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/predictor.js\");\n\n\nclass BaseDecoder {\n  async decode(fileDirectory, buffer) {\n    const decoded = await this.decodeBlock(buffer);\n    const predictor = fileDirectory.Predictor || 1;\n    if (predictor !== 1) {\n      const isTiled = !fileDirectory.StripOffsets;\n      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;\n      const tileHeight = isTiled ? fileDirectory.TileLength : (\n        fileDirectory.RowsPerStrip || fileDirectory.ImageLength\n      );\n      return (0,_predictor_js__WEBPACK_IMPORTED_MODULE_0__.applyPredictor)(\n        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,\n        fileDirectory.PlanarConfiguration,\n      );\n    }\n    return decoded;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2NvbXByZXNzaW9uL2Jhc2VkZWNvZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWlEOztBQUVsQztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkRBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvY29tcHJlc3Npb24vYmFzZWRlY29kZXIuanM/NjI2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhcHBseVByZWRpY3RvciB9IGZyb20gJy4uL3ByZWRpY3Rvci5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VEZWNvZGVyIHtcbiAgYXN5bmMgZGVjb2RlKGZpbGVEaXJlY3RvcnksIGJ1ZmZlcikge1xuICAgIGNvbnN0IGRlY29kZWQgPSBhd2FpdCB0aGlzLmRlY29kZUJsb2NrKGJ1ZmZlcik7XG4gICAgY29uc3QgcHJlZGljdG9yID0gZmlsZURpcmVjdG9yeS5QcmVkaWN0b3IgfHwgMTtcbiAgICBpZiAocHJlZGljdG9yICE9PSAxKSB7XG4gICAgICBjb25zdCBpc1RpbGVkID0gIWZpbGVEaXJlY3RvcnkuU3RyaXBPZmZzZXRzO1xuICAgICAgY29uc3QgdGlsZVdpZHRoID0gaXNUaWxlZCA/IGZpbGVEaXJlY3RvcnkuVGlsZVdpZHRoIDogZmlsZURpcmVjdG9yeS5JbWFnZVdpZHRoO1xuICAgICAgY29uc3QgdGlsZUhlaWdodCA9IGlzVGlsZWQgPyBmaWxlRGlyZWN0b3J5LlRpbGVMZW5ndGggOiAoXG4gICAgICAgIGZpbGVEaXJlY3RvcnkuUm93c1BlclN0cmlwIHx8IGZpbGVEaXJlY3RvcnkuSW1hZ2VMZW5ndGhcbiAgICAgICk7XG4gICAgICByZXR1cm4gYXBwbHlQcmVkaWN0b3IoXG4gICAgICAgIGRlY29kZWQsIHByZWRpY3RvciwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0LCBmaWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGUsXG4gICAgICAgIGZpbGVEaXJlY3RvcnkuUGxhbmFyQ29uZmlndXJhdGlvbixcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVkO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/compression/basedecoder.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/compression/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addDecoder: function() { return /* binding */ addDecoder; },\n/* harmony export */   getDecoder: function() { return /* binding */ getDecoder; }\n/* harmony export */ });\nconst registry = new Map();\n\nfunction addDecoder(cases, importFn) {\n  if (!Array.isArray(cases)) {\n    cases = [cases]; // eslint-disable-line no-param-reassign\n  }\n  cases.forEach((c) => registry.set(c, importFn));\n}\n\nasync function getDecoder(fileDirectory) {\n  const importFn = registry.get(fileDirectory.Compression);\n  if (!importFn) {\n    throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);\n  }\n  const Decoder = await importFn();\n  return new Decoder(fileDirectory);\n}\n\n// Add default decoders to registry (end-user may override with other implementations)\naddDecoder([undefined, 1], () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_geotiff_dist-module_compression_raw_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./raw.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/compression/raw.js\")).then((m) => m.default));\naddDecoder(5, () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_geotiff_dist-module_compression_lzw_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./lzw.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/compression/lzw.js\")).then((m) => m.default));\naddDecoder(6, () => {\n  throw new Error('old style JPEG compression is not supported.');\n});\naddDecoder(7, () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_geotiff_dist-module_compression_jpeg_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./jpeg.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/compression/jpeg.js\")).then((m) => m.default));\naddDecoder([8, 32946], () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_geotiff_dist-module_compression_deflate_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./deflate.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/compression/deflate.js\")).then((m) => m.default));\naddDecoder(32773, () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_geotiff_dist-module_compression_packbits_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./packbits.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/compression/packbits.js\")).then((m) => m.default));\naddDecoder(34887, () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_geotiff_dist-module_compression_lerc_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./lerc.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/compression/lerc.js\"))\n  .then(async (m) => {\n    await m.zstd.init();\n    return m;\n  })\n  .then((m) => m.default),\n);\naddDecoder(50001, () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_geotiff_dist-module_compression_webimage_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./webimage.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/compression/webimage.js\")).then((m) => m.default));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2NvbXByZXNzaW9uL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0FBRU87QUFDUDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsOERBQThELDBCQUEwQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxnUUFBa0I7QUFDbkQsb0JBQW9CLGdRQUFrQjtBQUN0QztBQUNBO0FBQ0EsQ0FBQztBQUNELG9CQUFvQixtUUFBbUI7QUFDdkMsNkJBQTZCLDRRQUFzQjtBQUNuRCx3QkFBd0IsK1FBQXVCO0FBQy9DLHdCQUF3QixtUUFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx3QkFBd0IsK1FBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2NvbXByZXNzaW9uL2luZGV4LmpzPzZjMWYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcmVnaXN0cnkgPSBuZXcgTWFwKCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGREZWNvZGVyKGNhc2VzLCBpbXBvcnRGbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY2FzZXMpKSB7XG4gICAgY2FzZXMgPSBbY2FzZXNdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIH1cbiAgY2FzZXMuZm9yRWFjaCgoYykgPT4gcmVnaXN0cnkuc2V0KGMsIGltcG9ydEZuKSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXREZWNvZGVyKGZpbGVEaXJlY3RvcnkpIHtcbiAgY29uc3QgaW1wb3J0Rm4gPSByZWdpc3RyeS5nZXQoZmlsZURpcmVjdG9yeS5Db21wcmVzc2lvbik7XG4gIGlmICghaW1wb3J0Rm4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY29tcHJlc3Npb24gbWV0aG9kIGlkZW50aWZpZXI6ICR7ZmlsZURpcmVjdG9yeS5Db21wcmVzc2lvbn1gKTtcbiAgfVxuICBjb25zdCBEZWNvZGVyID0gYXdhaXQgaW1wb3J0Rm4oKTtcbiAgcmV0dXJuIG5ldyBEZWNvZGVyKGZpbGVEaXJlY3RvcnkpO1xufVxuXG4vLyBBZGQgZGVmYXVsdCBkZWNvZGVycyB0byByZWdpc3RyeSAoZW5kLXVzZXIgbWF5IG92ZXJyaWRlIHdpdGggb3RoZXIgaW1wbGVtZW50YXRpb25zKVxuYWRkRGVjb2RlcihbdW5kZWZpbmVkLCAxXSwgKCkgPT4gaW1wb3J0KCcuL3Jhdy5qcycpLnRoZW4oKG0pID0+IG0uZGVmYXVsdCkpO1xuYWRkRGVjb2Rlcig1LCAoKSA9PiBpbXBvcnQoJy4vbHp3LmpzJykudGhlbigobSkgPT4gbS5kZWZhdWx0KSk7XG5hZGREZWNvZGVyKDYsICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKCdvbGQgc3R5bGUgSlBFRyBjb21wcmVzc2lvbiBpcyBub3Qgc3VwcG9ydGVkLicpO1xufSk7XG5hZGREZWNvZGVyKDcsICgpID0+IGltcG9ydCgnLi9qcGVnLmpzJykudGhlbigobSkgPT4gbS5kZWZhdWx0KSk7XG5hZGREZWNvZGVyKFs4LCAzMjk0Nl0sICgpID0+IGltcG9ydCgnLi9kZWZsYXRlLmpzJykudGhlbigobSkgPT4gbS5kZWZhdWx0KSk7XG5hZGREZWNvZGVyKDMyNzczLCAoKSA9PiBpbXBvcnQoJy4vcGFja2JpdHMuanMnKS50aGVuKChtKSA9PiBtLmRlZmF1bHQpKTtcbmFkZERlY29kZXIoMzQ4ODcsICgpID0+IGltcG9ydCgnLi9sZXJjLmpzJylcbiAgLnRoZW4oYXN5bmMgKG0pID0+IHtcbiAgICBhd2FpdCBtLnpzdGQuaW5pdCgpO1xuICAgIHJldHVybiBtO1xuICB9KVxuICAudGhlbigobSkgPT4gbS5kZWZhdWx0KSxcbik7XG5hZGREZWNvZGVyKDUwMDAxLCAoKSA9PiBpbXBvcnQoJy4vd2ViaW1hZ2UuanMnKS50aGVuKChtKSA9PiBtLmRlZmF1bHQpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/compression/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/dataslice.js":
/*!*******************************************************!*\
  !*** ./node_modules/geotiff/dist-module/dataslice.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ DataSlice; }\n/* harmony export */ });\nclass DataSlice {\n  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {\n    this._dataView = new DataView(arrayBuffer);\n    this._sliceOffset = sliceOffset;\n    this._littleEndian = littleEndian;\n    this._bigTiff = bigTiff;\n  }\n\n  get sliceOffset() {\n    return this._sliceOffset;\n  }\n\n  get sliceTop() {\n    return this._sliceOffset + this.buffer.byteLength;\n  }\n\n  get littleEndian() {\n    return this._littleEndian;\n  }\n\n  get bigTiff() {\n    return this._bigTiff;\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  covers(offset, length) {\n    return this.sliceOffset <= offset && this.sliceTop >= offset + length;\n  }\n\n  readUint8(offset) {\n    return this._dataView.getUint8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt8(offset) {\n    return this._dataView.getInt8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint16(offset) {\n    return this._dataView.getUint16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt16(offset) {\n    return this._dataView.getInt16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint32(offset) {\n    return this._dataView.getUint32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt32(offset) {\n    return this._dataView.getInt32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat32(offset) {\n    return this._dataView.getFloat32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat64(offset) {\n    return this._dataView.getFloat64(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint64(offset) {\n    const left = this.readUint32(offset);\n    const right = this.readUint32(offset + 4);\n    let combined;\n    if (this._littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  readInt64(offset) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80)\n      > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(\n        offset + (this._littleEndian ? i : 7 - i),\n      );\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  readOffset(offset) {\n    if (this._bigTiff) {\n      return this.readUint64(offset);\n    }\n    return this.readUint32(offset);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2RhdGFzbGljZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvZGF0YXNsaWNlLmpzP2ViNDYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0YVNsaWNlIHtcbiAgY29uc3RydWN0b3IoYXJyYXlCdWZmZXIsIHNsaWNlT2Zmc2V0LCBsaXR0bGVFbmRpYW4sIGJpZ1RpZmYpIHtcbiAgICB0aGlzLl9kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gICAgdGhpcy5fc2xpY2VPZmZzZXQgPSBzbGljZU9mZnNldDtcbiAgICB0aGlzLl9saXR0bGVFbmRpYW4gPSBsaXR0bGVFbmRpYW47XG4gICAgdGhpcy5fYmlnVGlmZiA9IGJpZ1RpZmY7XG4gIH1cblxuICBnZXQgc2xpY2VPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NsaWNlT2Zmc2V0O1xuICB9XG5cbiAgZ2V0IHNsaWNlVG9wKCkge1xuICAgIHJldHVybiB0aGlzLl9zbGljZU9mZnNldCArIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gIH1cblxuICBnZXQgbGl0dGxlRW5kaWFuKCkge1xuICAgIHJldHVybiB0aGlzLl9saXR0bGVFbmRpYW47XG4gIH1cblxuICBnZXQgYmlnVGlmZigpIHtcbiAgICByZXR1cm4gdGhpcy5fYmlnVGlmZjtcbiAgfVxuXG4gIGdldCBidWZmZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmJ1ZmZlcjtcbiAgfVxuXG4gIGNvdmVycyhvZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlT2Zmc2V0IDw9IG9mZnNldCAmJiB0aGlzLnNsaWNlVG9wID49IG9mZnNldCArIGxlbmd0aDtcbiAgfVxuXG4gIHJlYWRVaW50OChvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0VWludDgoXG4gICAgICBvZmZzZXQgLSB0aGlzLl9zbGljZU9mZnNldCwgdGhpcy5fbGl0dGxlRW5kaWFuLFxuICAgICk7XG4gIH1cblxuICByZWFkSW50OChvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0SW50OChcbiAgICAgIG9mZnNldCAtIHRoaXMuX3NsaWNlT2Zmc2V0LCB0aGlzLl9saXR0bGVFbmRpYW4sXG4gICAgKTtcbiAgfVxuXG4gIHJlYWRVaW50MTYob2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldFVpbnQxNihcbiAgICAgIG9mZnNldCAtIHRoaXMuX3NsaWNlT2Zmc2V0LCB0aGlzLl9saXR0bGVFbmRpYW4sXG4gICAgKTtcbiAgfVxuXG4gIHJlYWRJbnQxNihvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0SW50MTYoXG4gICAgICBvZmZzZXQgLSB0aGlzLl9zbGljZU9mZnNldCwgdGhpcy5fbGl0dGxlRW5kaWFuLFxuICAgICk7XG4gIH1cblxuICByZWFkVWludDMyKG9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRVaW50MzIoXG4gICAgICBvZmZzZXQgLSB0aGlzLl9zbGljZU9mZnNldCwgdGhpcy5fbGl0dGxlRW5kaWFuLFxuICAgICk7XG4gIH1cblxuICByZWFkSW50MzIob2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldEludDMyKFxuICAgICAgb2Zmc2V0IC0gdGhpcy5fc2xpY2VPZmZzZXQsIHRoaXMuX2xpdHRsZUVuZGlhbixcbiAgICApO1xuICB9XG5cbiAgcmVhZEZsb2F0MzIob2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldEZsb2F0MzIoXG4gICAgICBvZmZzZXQgLSB0aGlzLl9zbGljZU9mZnNldCwgdGhpcy5fbGl0dGxlRW5kaWFuLFxuICAgICk7XG4gIH1cblxuICByZWFkRmxvYXQ2NChvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0RmxvYXQ2NChcbiAgICAgIG9mZnNldCAtIHRoaXMuX3NsaWNlT2Zmc2V0LCB0aGlzLl9saXR0bGVFbmRpYW4sXG4gICAgKTtcbiAgfVxuXG4gIHJlYWRVaW50NjQob2Zmc2V0KSB7XG4gICAgY29uc3QgbGVmdCA9IHRoaXMucmVhZFVpbnQzMihvZmZzZXQpO1xuICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5yZWFkVWludDMyKG9mZnNldCArIDQpO1xuICAgIGxldCBjb21iaW5lZDtcbiAgICBpZiAodGhpcy5fbGl0dGxlRW5kaWFuKSB7XG4gICAgICBjb21iaW5lZCA9IGxlZnQgKyAoKDIgKiogMzIpICogcmlnaHQpO1xuICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihjb21iaW5lZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAke2NvbWJpbmVkfSBleGNlZWRzIE1BWF9TQUZFX0lOVEVHRVIuIGBcbiAgICAgICAgICArICdQcmVjaXNpb24gbWF5IGJlIGxvc3QuIFBsZWFzZSByZXBvcnQgaWYgeW91IGdldCB0aGlzIG1lc3NhZ2UgdG8gaHR0cHM6Ly9naXRodWIuY29tL2dlb3RpZmZqcy9nZW90aWZmLmpzL2lzc3VlcycsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tYmluZWQ7XG4gICAgfVxuICAgIGNvbWJpbmVkID0gKCgyICoqIDMyKSAqIGxlZnQpICsgcmlnaHQ7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihjb21iaW5lZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYCR7Y29tYmluZWR9IGV4Y2VlZHMgTUFYX1NBRkVfSU5URUdFUi4gYFxuICAgICAgICArICdQcmVjaXNpb24gbWF5IGJlIGxvc3QuIFBsZWFzZSByZXBvcnQgaWYgeW91IGdldCB0aGlzIG1lc3NhZ2UgdG8gaHR0cHM6Ly9naXRodWIuY29tL2dlb3RpZmZqcy9nZW90aWZmLmpzL2lzc3VlcycsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBjb21iaW5lZDtcbiAgfVxuXG4gIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTUzMzgzODQvODA2MDU5MVxuICByZWFkSW50NjQob2Zmc2V0KSB7XG4gICAgbGV0IHZhbHVlID0gMDtcbiAgICBjb25zdCBpc05lZ2F0aXZlID0gKHRoaXMuX2RhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArICh0aGlzLl9saXR0bGVFbmRpYW4gPyA3IDogMCkpICYgMHg4MClcbiAgICAgID4gMDtcbiAgICBsZXQgY2FycnlpbmcgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICBsZXQgYnl0ZSA9IHRoaXMuX2RhdGFWaWV3LmdldFVpbnQ4KFxuICAgICAgICBvZmZzZXQgKyAodGhpcy5fbGl0dGxlRW5kaWFuID8gaSA6IDcgLSBpKSxcbiAgICAgICk7XG4gICAgICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgICAgICBpZiAoY2FycnlpbmcpIHtcbiAgICAgICAgICBpZiAoYnl0ZSAhPT0gMHgwMCkge1xuICAgICAgICAgICAgYnl0ZSA9IH4oYnl0ZSAtIDEpICYgMHhmZjtcbiAgICAgICAgICAgIGNhcnJ5aW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ5dGUgPSB+Ynl0ZSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhbHVlICs9IGJ5dGUgKiAoMjU2ICoqIGkpO1xuICAgIH1cbiAgICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJlYWRPZmZzZXQob2Zmc2V0KSB7XG4gICAgaWYgKHRoaXMuX2JpZ1RpZmYpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRVaW50NjQob2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVhZFVpbnQzMihvZmZzZXQpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/dataslice.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/dataview64.js":
/*!********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/dataview64.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ DataView64; }\n/* harmony export */ });\n/* harmony import */ var _petamoriken_float16__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @petamoriken/float16 */ \"(app-pages-browser)/./node_modules/@petamoriken/float16/src/DataView.mjs\");\n\n\nclass DataView64 {\n  constructor(arrayBuffer) {\n    this._dataView = new DataView(arrayBuffer);\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  getUint64(offset, littleEndian) {\n    const left = this.getUint32(offset, littleEndian);\n    const right = this.getUint32(offset + 4, littleEndian);\n    let combined;\n    if (littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  getInt64(offset, littleEndian) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  getUint8(offset, littleEndian) {\n    return this._dataView.getUint8(offset, littleEndian);\n  }\n\n  getInt8(offset, littleEndian) {\n    return this._dataView.getInt8(offset, littleEndian);\n  }\n\n  getUint16(offset, littleEndian) {\n    return this._dataView.getUint16(offset, littleEndian);\n  }\n\n  getInt16(offset, littleEndian) {\n    return this._dataView.getInt16(offset, littleEndian);\n  }\n\n  getUint32(offset, littleEndian) {\n    return this._dataView.getUint32(offset, littleEndian);\n  }\n\n  getInt32(offset, littleEndian) {\n    return this._dataView.getInt32(offset, littleEndian);\n  }\n\n  getFloat16(offset, littleEndian) {\n    return (0,_petamoriken_float16__WEBPACK_IMPORTED_MODULE_0__.getFloat16)(this._dataView, offset, littleEndian);\n  }\n\n  getFloat32(offset, littleEndian) {\n    return this._dataView.getFloat32(offset, littleEndian);\n  }\n\n  getFloat64(offset, littleEndian) {\n    return this._dataView.getFloat64(offset, littleEndian);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2RhdGF2aWV3NjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0Q7O0FBRW5DO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxnRUFBVTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvZGF0YXZpZXc2NC5qcz9lY2U2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEZsb2F0MTYgfSBmcm9tICdAcGV0YW1vcmlrZW4vZmxvYXQxNic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGFWaWV3NjQge1xuICBjb25zdHJ1Y3RvcihhcnJheUJ1ZmZlcikge1xuICAgIHRoaXMuX2RhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgfVxuXG4gIGdldCBidWZmZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmJ1ZmZlcjtcbiAgfVxuXG4gIGdldFVpbnQ2NChvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIGNvbnN0IGxlZnQgPSB0aGlzLmdldFVpbnQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gICAgY29uc3QgcmlnaHQgPSB0aGlzLmdldFVpbnQzMihvZmZzZXQgKyA0LCBsaXR0bGVFbmRpYW4pO1xuICAgIGxldCBjb21iaW5lZDtcbiAgICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgICBjb21iaW5lZCA9IGxlZnQgKyAoKDIgKiogMzIpICogcmlnaHQpO1xuICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihjb21iaW5lZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAke2NvbWJpbmVkfSBleGNlZWRzIE1BWF9TQUZFX0lOVEVHRVIuIGBcbiAgICAgICAgICArICdQcmVjaXNpb24gbWF5IGJlIGxvc3QuIFBsZWFzZSByZXBvcnQgaWYgeW91IGdldCB0aGlzIG1lc3NhZ2UgdG8gaHR0cHM6Ly9naXRodWIuY29tL2dlb3RpZmZqcy9nZW90aWZmLmpzL2lzc3VlcycsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tYmluZWQ7XG4gICAgfVxuICAgIGNvbWJpbmVkID0gKCgyICoqIDMyKSAqIGxlZnQpICsgcmlnaHQ7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihjb21iaW5lZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYCR7Y29tYmluZWR9IGV4Y2VlZHMgTUFYX1NBRkVfSU5URUdFUi4gYFxuICAgICAgICArICdQcmVjaXNpb24gbWF5IGJlIGxvc3QuIFBsZWFzZSByZXBvcnQgaWYgeW91IGdldCB0aGlzIG1lc3NhZ2UgdG8gaHR0cHM6Ly9naXRodWIuY29tL2dlb3RpZmZqcy9nZW90aWZmLmpzL2lzc3VlcycsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBjb21iaW5lZDtcbiAgfVxuXG4gIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTUzMzgzODQvODA2MDU5MVxuICBnZXRJbnQ2NChvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgY29uc3QgaXNOZWdhdGl2ZSA9ICh0aGlzLl9kYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyAobGl0dGxlRW5kaWFuID8gNyA6IDApKSAmIDB4ODApID4gMDtcbiAgICBsZXQgY2FycnlpbmcgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICBsZXQgYnl0ZSA9IHRoaXMuX2RhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIChsaXR0bGVFbmRpYW4gPyBpIDogNyAtIGkpKTtcbiAgICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICAgIGlmIChjYXJyeWluZykge1xuICAgICAgICAgIGlmIChieXRlICE9PSAweDAwKSB7XG4gICAgICAgICAgICBieXRlID0gfihieXRlIC0gMSkgJiAweGZmO1xuICAgICAgICAgICAgY2FycnlpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnl0ZSA9IH5ieXRlICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFsdWUgKz0gYnl0ZSAqICgyNTYgKiogaSk7XG4gICAgfVxuICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICB2YWx1ZSA9IC12YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZ2V0VWludDgob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICB9XG5cbiAgZ2V0SW50OChvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRJbnQ4KG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgfVxuXG4gIGdldFVpbnQxNihvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICB9XG5cbiAgZ2V0SW50MTYob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0SW50MTYob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICB9XG5cbiAgZ2V0VWludDMyKG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gIH1cblxuICBnZXRJbnQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRJbnQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gIH1cblxuICBnZXRGbG9hdDE2KG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIGdldEZsb2F0MTYodGhpcy5fZGF0YVZpZXcsIG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgfVxuXG4gIGdldEZsb2F0MzIob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0RmxvYXQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gIH1cblxuICBnZXRGbG9hdDY0KG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldEZsb2F0NjQob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/dataview64.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/geotiff.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/dist-module/geotiff.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseClient: function() { return /* reexport safe */ _source_client_base_js__WEBPACK_IMPORTED_MODULE_14__.BaseClient; },\n/* harmony export */   BaseDecoder: function() { return /* reexport safe */ _compression_basedecoder_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; },\n/* harmony export */   BaseResponse: function() { return /* reexport safe */ _source_client_base_js__WEBPACK_IMPORTED_MODULE_14__.BaseResponse; },\n/* harmony export */   GeoTIFF: function() { return /* binding */ GeoTIFF; },\n/* harmony export */   GeoTIFFImage: function() { return /* reexport safe */ _geotiffimage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]; },\n/* harmony export */   MultiGeoTIFF: function() { return /* binding */ MultiGeoTIFF; },\n/* harmony export */   Pool: function() { return /* reexport safe */ _pool_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"]; },\n/* harmony export */   addDecoder: function() { return /* reexport safe */ _compression_index_js__WEBPACK_IMPORTED_MODULE_3__.addDecoder; },\n/* harmony export */   fromArrayBuffer: function() { return /* binding */ fromArrayBuffer; },\n/* harmony export */   fromBlob: function() { return /* binding */ fromBlob; },\n/* harmony export */   fromCustomClient: function() { return /* binding */ fromCustomClient; },\n/* harmony export */   fromFile: function() { return /* binding */ fromFile; },\n/* harmony export */   fromUrl: function() { return /* binding */ fromUrl; },\n/* harmony export */   fromUrls: function() { return /* binding */ fromUrls; },\n/* harmony export */   getDecoder: function() { return /* reexport safe */ _compression_index_js__WEBPACK_IMPORTED_MODULE_3__.getDecoder; },\n/* harmony export */   globals: function() { return /* reexport module object */ _globals_js__WEBPACK_IMPORTED_MODULE_0__; },\n/* harmony export */   rgb: function() { return /* reexport module object */ _rgb_js__WEBPACK_IMPORTED_MODULE_1__; },\n/* harmony export */   setLogger: function() { return /* reexport safe */ _logging_js__WEBPACK_IMPORTED_MODULE_4__.setLogger; },\n/* harmony export */   writeArrayBuffer: function() { return /* binding */ writeArrayBuffer; }\n/* harmony export */ });\n/* harmony import */ var _geotiffimage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./geotiffimage.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/geotiffimage.js\");\n/* harmony import */ var _dataview64_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dataview64.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/dataview64.js\");\n/* harmony import */ var _dataslice_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dataslice.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/dataslice.js\");\n/* harmony import */ var _pool_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./pool.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/pool.js\");\n/* harmony import */ var _source_remote_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./source/remote.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/remote.js\");\n/* harmony import */ var _source_arraybuffer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./source/arraybuffer.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/arraybuffer.js\");\n/* harmony import */ var _source_filereader_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./source/filereader.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/filereader.js\");\n/* harmony import */ var _source_file_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./source/file.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/file.js\");\n/* harmony import */ var _source_client_base_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./source/client/base.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/base.js\");\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/globals.js\");\n/* harmony import */ var _geotiffwriter_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./geotiffwriter.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/geotiffwriter.js\");\n/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rgb.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/rgb.js\");\n/* harmony import */ var _compression_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./compression/index.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/compression/index.js\");\n/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./logging.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/logging.js\");\n/* harmony import */ var _compression_basedecoder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./compression/basedecoder.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/compression/basedecoder.js\");\n/** @module geotiff */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\n/**\n * @typedef {{ height:number, width: number }} Dimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray & { height: number; width: number}`\n * @typedef {TypedArray & Dimensions} TypedArrayWithDimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray[] & { height: number; width: number}`\n * @typedef {TypedArray[] & Dimensions} TypedArrayArrayWithDimensions\n */\n\n/**\n *  The autogenerated docs are a little confusing here. The effective type is:\n *\n * `(TypedArray | TypedArray[]) & { height: number; width: number}`\n * @typedef {TypedArrayWithDimensions | TypedArrayArrayWithDimensions} ReadRasterResult\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.BYTE: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SBYTE: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.UNDEFINED:\n      return 1;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SHORT: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SSHORT:\n      return 2;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.FLOAT: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD:\n      return 4;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.DOUBLE:\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG8: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG8: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = _globals_js__WEBPACK_IMPORTED_MODULE_0__.geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (_globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.BYTE: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG8: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL || fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new _dataslice_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && _globals_js__WEBPACK_IMPORTED_MODULE_0__.arrayFields.indexOf(fieldTag) === -1\n        && !(fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL || fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[_globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new _geotiffimage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new _dataview64_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (GeoTIFF);\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new _geotiffimage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\n\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_8__.makeRemoteSource)(url, options), signal);\n}\n\n/**\n * Creates a new GeoTIFF from a custom {@link BaseClient}.\n * @param {BaseClient} client The client.\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromCustomClient(client, options = {}, signal) {\n  return GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_8__.makeCustomSource)(client, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource((0,_source_arraybuffer_js__WEBPACK_IMPORTED_MODULE_9__.makeBufferSource)(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromFile(path, signal) {\n  return GeoTIFF.fromSource((0,_source_file_js__WEBPACK_IMPORTED_MODULE_10__.makeFileSource)(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource((0,_source_filereader_js__WEBPACK_IMPORTED_MODULE_11__.makeFileReaderSource)(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nasync function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_8__.makeRemoteSource)(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_8__.makeRemoteSource)(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nfunction writeArrayBuffer(values, metadata) {\n  return (0,_geotiffwriter_js__WEBPACK_IMPORTED_MODULE_12__.writeGeotiff)(values, metadata);\n}\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2dlb3RpZmYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQzZDO0FBQ0o7QUFDRjtBQUNWOztBQUUyQztBQUNiO0FBQ0c7QUFDWjtBQUNpQjs7QUFFZ0I7QUFDakM7QUFDVjtBQUNSO0FBQ2dDO0FBQ3ZCOztBQUV0QjtBQUNKO0FBQ3VEO0FBQ3BDO0FBQ2I7O0FBRXJCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGdDQUFnQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCLGNBQWM7QUFDakQsYUFBYSx5QkFBeUI7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQixjQUFjO0FBQ25ELGFBQWEsMkJBQTJCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0IsY0FBYztBQUNsRSxhQUFhLDBEQUEwRDtBQUN2RTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxtREFBVSxZQUFZLG1EQUFVLGFBQWEsbURBQVUsYUFBYSxtREFBVTtBQUN2RjtBQUNBLFNBQVMsbURBQVUsYUFBYSxtREFBVTtBQUMxQztBQUNBLFNBQVMsbURBQVUsWUFBWSxtREFBVSxhQUFhLG1EQUFVLGFBQWEsbURBQVU7QUFDdkY7QUFDQSxTQUFTLG1EQUFVLGdCQUFnQixtREFBVSxpQkFBaUIsbURBQVU7QUFDeEUsU0FBUyxtREFBVSxhQUFhLG1EQUFVLGNBQWMsbURBQVU7QUFDbEU7QUFDQTtBQUNBLGtEQUFrRCxVQUFVO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixnQ0FBZ0M7QUFDbEQsZ0JBQWdCLG9EQUFXO0FBQzNCO0FBQ0EsU0FBUyxzREFBYTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUFDL0I7QUFDTztBQUNQLDRCQUE0Qiw0RUFBb0I7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLG9EQUFvRDtBQUNwRDtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ08sZ0VBQWdFO0FBQ3ZFLDRDQUE0QyxtRUFBZ0I7QUFDNUQ7QUFDQSxpREFBaUQsbUVBQWdCO0FBQ2pFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFVBQVU7QUFDdkI7QUFDTztBQUNQLFNBQVMsZ0VBQVk7QUFDckI7O0FBRWdCO0FBQ1E7QUFDWSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nZW90aWZmLmpzPzc2YzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBtb2R1bGUgZ2VvdGlmZiAqL1xuaW1wb3J0IEdlb1RJRkZJbWFnZSBmcm9tICcuL2dlb3RpZmZpbWFnZS5qcyc7XG5pbXBvcnQgRGF0YVZpZXc2NCBmcm9tICcuL2RhdGF2aWV3NjQuanMnO1xuaW1wb3J0IERhdGFTbGljZSBmcm9tICcuL2RhdGFzbGljZS5qcyc7XG5pbXBvcnQgUG9vbCBmcm9tICcuL3Bvb2wuanMnO1xuXG5pbXBvcnQgeyBtYWtlUmVtb3RlU291cmNlLCBtYWtlQ3VzdG9tU291cmNlIH0gZnJvbSAnLi9zb3VyY2UvcmVtb3RlLmpzJztcbmltcG9ydCB7IG1ha2VCdWZmZXJTb3VyY2UgfSBmcm9tICcuL3NvdXJjZS9hcnJheWJ1ZmZlci5qcyc7XG5pbXBvcnQgeyBtYWtlRmlsZVJlYWRlclNvdXJjZSB9IGZyb20gJy4vc291cmNlL2ZpbGVyZWFkZXIuanMnO1xuaW1wb3J0IHsgbWFrZUZpbGVTb3VyY2UgfSBmcm9tICcuL3NvdXJjZS9maWxlLmpzJztcbmltcG9ydCB7IEJhc2VDbGllbnQsIEJhc2VSZXNwb25zZSB9IGZyb20gJy4vc291cmNlL2NsaWVudC9iYXNlLmpzJztcblxuaW1wb3J0IHsgZmllbGRUeXBlcywgZmllbGRUYWdOYW1lcywgYXJyYXlGaWVsZHMsIGdlb0tleU5hbWVzIH0gZnJvbSAnLi9nbG9iYWxzLmpzJztcbmltcG9ydCB7IHdyaXRlR2VvdGlmZiB9IGZyb20gJy4vZ2VvdGlmZndyaXRlci5qcyc7XG5pbXBvcnQgKiBhcyBnbG9iYWxzIGZyb20gJy4vZ2xvYmFscy5qcyc7XG5pbXBvcnQgKiBhcyByZ2IgZnJvbSAnLi9yZ2IuanMnO1xuaW1wb3J0IHsgZ2V0RGVjb2RlciwgYWRkRGVjb2RlciB9IGZyb20gJy4vY29tcHJlc3Npb24vaW5kZXguanMnO1xuaW1wb3J0IHsgc2V0TG9nZ2VyIH0gZnJvbSAnLi9sb2dnaW5nLmpzJztcblxuZXhwb3J0IHsgZ2xvYmFscyB9O1xuZXhwb3J0IHsgcmdiIH07XG5leHBvcnQgeyBkZWZhdWx0IGFzIEJhc2VEZWNvZGVyIH0gZnJvbSAnLi9jb21wcmVzc2lvbi9iYXNlZGVjb2Rlci5qcyc7XG5leHBvcnQgeyBnZXREZWNvZGVyLCBhZGREZWNvZGVyIH07XG5leHBvcnQgeyBzZXRMb2dnZXIgfTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7VWludDhBcnJheSB8IEludDhBcnJheSB8IFVpbnQxNkFycmF5IHwgSW50MTZBcnJheSB8IFVpbnQzMkFycmF5IHwgSW50MzJBcnJheSB8IEZsb2F0MzJBcnJheSB8IEZsb2F0NjRBcnJheX1cbiAqIFR5cGVkQXJyYXlcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7IGhlaWdodDpudW1iZXIsIHdpZHRoOiBudW1iZXIgfX0gRGltZW5zaW9uc1xuICovXG5cbi8qKlxuICogVGhlIGF1dG9nZW5lcmF0ZWQgZG9jcyBhcmUgYSBsaXR0bGUgY29uZnVzaW5nIGhlcmUuIFRoZSBlZmZlY3RpdmUgdHlwZSBpczpcbiAqXG4gKiBgVHlwZWRBcnJheSAmIHsgaGVpZ2h0OiBudW1iZXI7IHdpZHRoOiBudW1iZXJ9YFxuICogQHR5cGVkZWYge1R5cGVkQXJyYXkgJiBEaW1lbnNpb25zfSBUeXBlZEFycmF5V2l0aERpbWVuc2lvbnNcbiAqL1xuXG4vKipcbiAqIFRoZSBhdXRvZ2VuZXJhdGVkIGRvY3MgYXJlIGEgbGl0dGxlIGNvbmZ1c2luZyBoZXJlLiBUaGUgZWZmZWN0aXZlIHR5cGUgaXM6XG4gKlxuICogYFR5cGVkQXJyYXlbXSAmIHsgaGVpZ2h0OiBudW1iZXI7IHdpZHRoOiBudW1iZXJ9YFxuICogQHR5cGVkZWYge1R5cGVkQXJyYXlbXSAmIERpbWVuc2lvbnN9IFR5cGVkQXJyYXlBcnJheVdpdGhEaW1lbnNpb25zXG4gKi9cblxuLyoqXG4gKiAgVGhlIGF1dG9nZW5lcmF0ZWQgZG9jcyBhcmUgYSBsaXR0bGUgY29uZnVzaW5nIGhlcmUuIFRoZSBlZmZlY3RpdmUgdHlwZSBpczpcbiAqXG4gKiBgKFR5cGVkQXJyYXkgfCBUeXBlZEFycmF5W10pICYgeyBoZWlnaHQ6IG51bWJlcjsgd2lkdGg6IG51bWJlcn1gXG4gKiBAdHlwZWRlZiB7VHlwZWRBcnJheVdpdGhEaW1lbnNpb25zIHwgVHlwZWRBcnJheUFycmF5V2l0aERpbWVuc2lvbnN9IFJlYWRSYXN0ZXJSZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBnZXRGaWVsZFR5cGVMZW5ndGgoZmllbGRUeXBlKSB7XG4gIHN3aXRjaCAoZmllbGRUeXBlKSB7XG4gICAgY2FzZSBmaWVsZFR5cGVzLkJZVEU6IGNhc2UgZmllbGRUeXBlcy5BU0NJSTogY2FzZSBmaWVsZFR5cGVzLlNCWVRFOiBjYXNlIGZpZWxkVHlwZXMuVU5ERUZJTkVEOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSBmaWVsZFR5cGVzLlNIT1JUOiBjYXNlIGZpZWxkVHlwZXMuU1NIT1JUOlxuICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSBmaWVsZFR5cGVzLkxPTkc6IGNhc2UgZmllbGRUeXBlcy5TTE9ORzogY2FzZSBmaWVsZFR5cGVzLkZMT0FUOiBjYXNlIGZpZWxkVHlwZXMuSUZEOlxuICAgICAgcmV0dXJuIDQ7XG4gICAgY2FzZSBmaWVsZFR5cGVzLlJBVElPTkFMOiBjYXNlIGZpZWxkVHlwZXMuU1JBVElPTkFMOiBjYXNlIGZpZWxkVHlwZXMuRE9VQkxFOlxuICAgIGNhc2UgZmllbGRUeXBlcy5MT05HODogY2FzZSBmaWVsZFR5cGVzLlNMT05HODogY2FzZSBmaWVsZFR5cGVzLklGRDg6XG4gICAgICByZXR1cm4gODtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgZmllbGQgdHlwZTogJHtmaWVsZFR5cGV9YCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VHZW9LZXlEaXJlY3RvcnkoZmlsZURpcmVjdG9yeSkge1xuICBjb25zdCByYXdHZW9LZXlEaXJlY3RvcnkgPSBmaWxlRGlyZWN0b3J5Lkdlb0tleURpcmVjdG9yeTtcbiAgaWYgKCFyYXdHZW9LZXlEaXJlY3RvcnkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGdlb0tleURpcmVjdG9yeSA9IHt9O1xuICBmb3IgKGxldCBpID0gNDsgaSA8PSByYXdHZW9LZXlEaXJlY3RvcnlbM10gKiA0OyBpICs9IDQpIHtcbiAgICBjb25zdCBrZXkgPSBnZW9LZXlOYW1lc1tyYXdHZW9LZXlEaXJlY3RvcnlbaV1dO1xuICAgIGNvbnN0IGxvY2F0aW9uID0gKHJhd0dlb0tleURpcmVjdG9yeVtpICsgMV0pXG4gICAgICA/IChmaWVsZFRhZ05hbWVzW3Jhd0dlb0tleURpcmVjdG9yeVtpICsgMV1dKSA6IG51bGw7XG4gICAgY29uc3QgY291bnQgPSByYXdHZW9LZXlEaXJlY3RvcnlbaSArIDJdO1xuICAgIGNvbnN0IG9mZnNldCA9IHJhd0dlb0tleURpcmVjdG9yeVtpICsgM107XG5cbiAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgIGlmICghbG9jYXRpb24pIHtcbiAgICAgIHZhbHVlID0gb2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGZpbGVEaXJlY3RvcnlbbG9jYXRpb25dO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZ2V0IHZhbHVlIG9mIGdlb0tleSAnJHtrZXl9Jy5gKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIGNvdW50IC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLnN1YmFycmF5KSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBjb3VudCk7XG4gICAgICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWVbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZ2VvS2V5RGlyZWN0b3J5W2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gZ2VvS2V5RGlyZWN0b3J5O1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZXMoZGF0YVNsaWNlLCBmaWVsZFR5cGUsIGNvdW50LCBvZmZzZXQpIHtcbiAgbGV0IHZhbHVlcyA9IG51bGw7XG4gIGxldCByZWFkTWV0aG9kID0gbnVsbDtcbiAgY29uc3QgZmllbGRUeXBlTGVuZ3RoID0gZ2V0RmllbGRUeXBlTGVuZ3RoKGZpZWxkVHlwZSk7XG5cbiAgc3dpdGNoIChmaWVsZFR5cGUpIHtcbiAgICBjYXNlIGZpZWxkVHlwZXMuQllURTogY2FzZSBmaWVsZFR5cGVzLkFTQ0lJOiBjYXNlIGZpZWxkVHlwZXMuVU5ERUZJTkVEOlxuICAgICAgdmFsdWVzID0gbmV3IFVpbnQ4QXJyYXkoY291bnQpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRVaW50ODtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TQllURTpcbiAgICAgIHZhbHVlcyA9IG5ldyBJbnQ4QXJyYXkoY291bnQpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRJbnQ4O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmaWVsZFR5cGVzLlNIT1JUOlxuICAgICAgdmFsdWVzID0gbmV3IFVpbnQxNkFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkVWludDE2O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmaWVsZFR5cGVzLlNTSE9SVDpcbiAgICAgIHZhbHVlcyA9IG5ldyBJbnQxNkFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkSW50MTY7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZpZWxkVHlwZXMuTE9ORzogY2FzZSBmaWVsZFR5cGVzLklGRDpcbiAgICAgIHZhbHVlcyA9IG5ldyBVaW50MzJBcnJheShjb3VudCk7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZFVpbnQzMjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TTE9ORzpcbiAgICAgIHZhbHVlcyA9IG5ldyBJbnQzMkFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkSW50MzI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZpZWxkVHlwZXMuTE9ORzg6IGNhc2UgZmllbGRUeXBlcy5JRkQ4OlxuICAgICAgdmFsdWVzID0gbmV3IEFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkVWludDY0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmaWVsZFR5cGVzLlNMT05HODpcbiAgICAgIHZhbHVlcyA9IG5ldyBBcnJheShjb3VudCk7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZEludDY0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmaWVsZFR5cGVzLlJBVElPTkFMOlxuICAgICAgdmFsdWVzID0gbmV3IFVpbnQzMkFycmF5KGNvdW50ICogMik7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZFVpbnQzMjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TUkFUSU9OQUw6XG4gICAgICB2YWx1ZXMgPSBuZXcgSW50MzJBcnJheShjb3VudCAqIDIpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRJbnQzMjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5GTE9BVDpcbiAgICAgIHZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoY291bnQpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRGbG9hdDMyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmaWVsZFR5cGVzLkRPVUJMRTpcbiAgICAgIHZhbHVlcyA9IG5ldyBGbG9hdDY0QXJyYXkoY291bnQpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRGbG9hdDY0O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGZpZWxkIHR5cGU6ICR7ZmllbGRUeXBlfWApO1xuICB9XG5cbiAgLy8gbm9ybWFsIGZpZWxkc1xuICBpZiAoIShmaWVsZFR5cGUgPT09IGZpZWxkVHlwZXMuUkFUSU9OQUwgfHwgZmllbGRUeXBlID09PSBmaWVsZFR5cGVzLlNSQVRJT05BTCkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIHZhbHVlc1tpXSA9IHJlYWRNZXRob2QuY2FsbChcbiAgICAgICAgZGF0YVNsaWNlLCBvZmZzZXQgKyAoaSAqIGZpZWxkVHlwZUxlbmd0aCksXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHsgLy8gUkFUSU9OQUwgb3IgU1JBVElPTkFMXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSArPSAyKSB7XG4gICAgICB2YWx1ZXNbaV0gPSByZWFkTWV0aG9kLmNhbGwoXG4gICAgICAgIGRhdGFTbGljZSwgb2Zmc2V0ICsgKGkgKiBmaWVsZFR5cGVMZW5ndGgpLFxuICAgICAgKTtcbiAgICAgIHZhbHVlc1tpICsgMV0gPSByZWFkTWV0aG9kLmNhbGwoXG4gICAgICAgIGRhdGFTbGljZSwgb2Zmc2V0ICsgKChpICogZmllbGRUeXBlTGVuZ3RoKSArIDQpLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZmllbGRUeXBlID09PSBmaWVsZFR5cGVzLkFTQ0lJKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigndXRmLTgnKS5kZWNvZGUodmFsdWVzKTtcbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufVxuXG4vKipcbiAqIERhdGEgY2xhc3MgdG8gc3RvcmUgdGhlIHBhcnNlZCBmaWxlIGRpcmVjdG9yeSwgZ2VvIGtleSBkaXJlY3RvcnkgYW5kXG4gKiBvZmZzZXQgdG8gdGhlIG5leHQgSUZEXG4gKi9cbmNsYXNzIEltYWdlRmlsZURpcmVjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKGZpbGVEaXJlY3RvcnksIGdlb0tleURpcmVjdG9yeSwgbmV4dElGREJ5dGVPZmZzZXQpIHtcbiAgICB0aGlzLmZpbGVEaXJlY3RvcnkgPSBmaWxlRGlyZWN0b3J5O1xuICAgIHRoaXMuZ2VvS2V5RGlyZWN0b3J5ID0gZ2VvS2V5RGlyZWN0b3J5O1xuICAgIHRoaXMubmV4dElGREJ5dGVPZmZzZXQgPSBuZXh0SUZEQnl0ZU9mZnNldDtcbiAgfVxufVxuXG4vKipcbiAqIEVycm9yIGNsYXNzIGZvciBjYXNlcyB3aGVuIGFuIElGRCBpbmRleCB3YXMgcmVxdWVzdGVkLCB0aGF0IGRvZXMgbm90IGV4aXN0XG4gKiBpbiB0aGUgZmlsZS5cbiAqL1xuY2xhc3MgR2VvVElGRkltYWdlSW5kZXhFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoaW5kZXgpIHtcbiAgICBzdXBlcihgTm8gaW1hZ2UgYXQgaW5kZXggJHtpbmRleH1gKTtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gIH1cbn1cblxuY2xhc3MgR2VvVElGRkJhc2Uge1xuICAvKipcbiAgICogKGV4cGVyaW1lbnRhbCkgUmVhZHMgcmFzdGVyIGRhdGEgZnJvbSB0aGUgYmVzdCBmaXR0aW5nIGltYWdlLiBUaGlzIGZ1bmN0aW9uIHVzZXNcbiAgICogdGhlIGltYWdlIHdpdGggdGhlIGxvd2VzdCByZXNvbHV0aW9uIHRoYXQgaXMgc3RpbGwgYSBoaWdoZXIgcmVzb2x1dGlvbiB0aGFuIHRoZVxuICAgKiByZXF1ZXN0ZWQgcmVzb2x1dGlvbi5cbiAgICogV2hlbiBzcGVjaWZpZWQsIHRoZSBgYmJveGAgb3B0aW9uIGlzIHRyYW5zbGF0ZWQgdG8gdGhlIGB3aW5kb3dgIG9wdGlvbiBhbmQgdGhlXG4gICAqIGByZXNYYCBhbmQgYHJlc1lgIHRvIGB3aWR0aGAgYW5kIGBoZWlnaHRgIHJlc3BlY3RpdmVseS5cbiAgICogVGhlbiwgdGhlIFtyZWFkUmFzdGVyc117QGxpbmsgR2VvVElGRkltYWdlI3JlYWRSYXN0ZXJzfSBtZXRob2Qgb2YgdGhlIHNlbGVjdGVkXG4gICAqIGltYWdlIGlzIGNhbGxlZCBhbmQgdGhlIHJlc3VsdCByZXR1cm5lZC5cbiAgICogQHNlZSBHZW9USUZGSW1hZ2UucmVhZFJhc3RlcnNcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vZ2VvdGlmZmltYWdlJykuUmVhZFJhc3Rlck9wdGlvbnN9IFtvcHRpb25zPXt9XSBvcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFJlYWRSYXN0ZXJSZXN1bHQ+fSB0aGUgZGVjb2RlZCBhcnJheShzKSwgd2l0aCBgaGVpZ2h0YCBhbmQgYHdpZHRoYCwgYXMgYSBwcm9taXNlXG4gICAqL1xuICBhc3luYyByZWFkUmFzdGVycyhvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHdpbmRvdzogaW1hZ2VXaW5kb3csIHdpZHRoLCBoZWlnaHQgfSA9IG9wdGlvbnM7XG4gICAgbGV0IHsgcmVzWCwgcmVzWSwgYmJveCB9ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IGZpcnN0SW1hZ2UgPSBhd2FpdCB0aGlzLmdldEltYWdlKCk7XG4gICAgbGV0IHVzZWRJbWFnZSA9IGZpcnN0SW1hZ2U7XG4gICAgY29uc3QgaW1hZ2VDb3VudCA9IGF3YWl0IHRoaXMuZ2V0SW1hZ2VDb3VudCgpO1xuICAgIGNvbnN0IGltZ0JCb3ggPSBmaXJzdEltYWdlLmdldEJvdW5kaW5nQm94KCk7XG5cbiAgICBpZiAoaW1hZ2VXaW5kb3cgJiYgYmJveCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3RoIFwiYmJveFwiIGFuZCBcIndpbmRvd1wiIHBhc3NlZC4nKTtcbiAgICB9XG5cbiAgICAvLyBpZiB3aWR0aC9oZWlnaHQgaXMgcGFzc2VkLCB0cmFuc2Zvcm0gaXQgdG8gcmVzb2x1dGlvblxuICAgIGlmICh3aWR0aCB8fCBoZWlnaHQpIHtcbiAgICAgIC8vIGlmIHdlIGhhdmUgYW4gaW1hZ2Ugd2luZG93IChwaXhlbCBjb29yZGluYXRlcyksIHRyYW5zZm9ybSBpdCB0byBhIEJCb3hcbiAgICAgIC8vIHVzaW5nIHRoZSBvcmlnaW4vcmVzb2x1dGlvbiBvZiB0aGUgZmlyc3QgaW1hZ2UuXG4gICAgICBpZiAoaW1hZ2VXaW5kb3cpIHtcbiAgICAgICAgY29uc3QgW29YLCBvWV0gPSBmaXJzdEltYWdlLmdldE9yaWdpbigpO1xuICAgICAgICBjb25zdCBbclgsIHJZXSA9IGZpcnN0SW1hZ2UuZ2V0UmVzb2x1dGlvbigpO1xuXG4gICAgICAgIGJib3ggPSBbXG4gICAgICAgICAgb1ggKyAoaW1hZ2VXaW5kb3dbMF0gKiByWCksXG4gICAgICAgICAgb1kgKyAoaW1hZ2VXaW5kb3dbMV0gKiByWSksXG4gICAgICAgICAgb1ggKyAoaW1hZ2VXaW5kb3dbMl0gKiByWCksXG4gICAgICAgICAgb1kgKyAoaW1hZ2VXaW5kb3dbM10gKiByWSksXG4gICAgICAgIF07XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHdlIGhhdmUgYSBiYm94IChvciBjYWxjdWxhdGVkIG9uZSlcblxuICAgICAgY29uc3QgdXNlZEJCb3ggPSBiYm94IHx8IGltZ0JCb3g7XG5cbiAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICBpZiAocmVzWCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQm90aCB3aWR0aCBhbmQgcmVzWCBwYXNzZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXNYID0gKHVzZWRCQm94WzJdIC0gdXNlZEJCb3hbMF0pIC8gd2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0KSB7XG4gICAgICAgIGlmIChyZXNZKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3RoIHdpZHRoIGFuZCByZXNZIHBhc3NlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJlc1kgPSAodXNlZEJCb3hbM10gLSB1c2VkQkJveFsxXSkgLyBoZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgcmVzb2x1dGlvbiBpcyBzZXQgb3IgY2FsY3VsYXRlZCwgdHJ5IHRvIGdldCB0aGUgaW1hZ2Ugd2l0aCB0aGUgd29yc3QgYWNjZXB0YWJsZSByZXNvbHV0aW9uXG4gICAgaWYgKHJlc1ggfHwgcmVzWSkge1xuICAgICAgY29uc3QgYWxsSW1hZ2VzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGltYWdlQ291bnQ7ICsraSkge1xuICAgICAgICBjb25zdCBpbWFnZSA9IGF3YWl0IHRoaXMuZ2V0SW1hZ2UoaSk7XG4gICAgICAgIGNvbnN0IHsgU3ViZmlsZVR5cGU6IHN1YmZpbGVUeXBlLCBOZXdTdWJmaWxlVHlwZTogbmV3U3ViZmlsZVR5cGUgfSA9IGltYWdlLmZpbGVEaXJlY3Rvcnk7XG4gICAgICAgIGlmIChpID09PSAwIHx8IHN1YmZpbGVUeXBlID09PSAyIHx8IG5ld1N1YmZpbGVUeXBlICYgMSkge1xuICAgICAgICAgIGFsbEltYWdlcy5wdXNoKGltYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhbGxJbWFnZXMuc29ydCgoYSwgYikgPT4gYS5nZXRXaWR0aCgpIC0gYi5nZXRXaWR0aCgpKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsSW1hZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGltYWdlID0gYWxsSW1hZ2VzW2ldO1xuICAgICAgICBjb25zdCBpbWdSZXNYID0gKGltZ0JCb3hbMl0gLSBpbWdCQm94WzBdKSAvIGltYWdlLmdldFdpZHRoKCk7XG4gICAgICAgIGNvbnN0IGltZ1Jlc1kgPSAoaW1nQkJveFszXSAtIGltZ0JCb3hbMV0pIC8gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG5cbiAgICAgICAgdXNlZEltYWdlID0gaW1hZ2U7XG4gICAgICAgIGlmICgocmVzWCAmJiByZXNYID4gaW1nUmVzWCkgfHwgKHJlc1kgJiYgcmVzWSA+IGltZ1Jlc1kpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgd25kID0gaW1hZ2VXaW5kb3c7XG4gICAgaWYgKGJib3gpIHtcbiAgICAgIGNvbnN0IFtvWCwgb1ldID0gZmlyc3RJbWFnZS5nZXRPcmlnaW4oKTtcbiAgICAgIGNvbnN0IFtpbWFnZVJlc1gsIGltYWdlUmVzWV0gPSB1c2VkSW1hZ2UuZ2V0UmVzb2x1dGlvbihmaXJzdEltYWdlKTtcblxuICAgICAgd25kID0gW1xuICAgICAgICBNYXRoLnJvdW5kKChiYm94WzBdIC0gb1gpIC8gaW1hZ2VSZXNYKSxcbiAgICAgICAgTWF0aC5yb3VuZCgoYmJveFsxXSAtIG9ZKSAvIGltYWdlUmVzWSksXG4gICAgICAgIE1hdGgucm91bmQoKGJib3hbMl0gLSBvWCkgLyBpbWFnZVJlc1gpLFxuICAgICAgICBNYXRoLnJvdW5kKChiYm94WzNdIC0gb1kpIC8gaW1hZ2VSZXNZKSxcbiAgICAgIF07XG4gICAgICB3bmQgPSBbXG4gICAgICAgIE1hdGgubWluKHduZFswXSwgd25kWzJdKSxcbiAgICAgICAgTWF0aC5taW4od25kWzFdLCB3bmRbM10pLFxuICAgICAgICBNYXRoLm1heCh3bmRbMF0sIHduZFsyXSksXG4gICAgICAgIE1hdGgubWF4KHduZFsxXSwgd25kWzNdKSxcbiAgICAgIF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHVzZWRJbWFnZS5yZWFkUmFzdGVycyh7IC4uLm9wdGlvbnMsIHdpbmRvdzogd25kIH0pO1xuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gR2VvVElGRk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NhY2hlPWZhbHNlXSB3aGV0aGVyIG9yIG5vdCBkZWNvZGVkIHRpbGVzIHNoYWxsIGJlIGNhY2hlZC5cbiAqL1xuXG4vKipcbiAqIFRoZSBhYnN0cmFjdGlvbiBmb3IgYSB3aG9sZSBHZW9USUZGIGZpbGUuXG4gKiBAYXVnbWVudHMgR2VvVElGRkJhc2VcbiAqL1xuY2xhc3MgR2VvVElGRiBleHRlbmRzIEdlb1RJRkZCYXNlIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0geyp9IHNvdXJjZSBUaGUgZGF0YXNvdXJjZSB0byByZWFkIGZyb20uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdGhlIGltYWdlIHVzZXMgbGl0dGxlIGVuZGlhbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBiaWdUaWZmIFdoZXRoZXIgdGhlIGltYWdlIHVzZXMgYmlnVElGRiBjb252ZW50aW9ucy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZpcnN0SUZET2Zmc2V0IFRoZSBudW1lcmljIGJ5dGUtb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBpbWFnZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gdGhlIGZpcnN0IElGRC5cbiAgICogQHBhcmFtIHtHZW9USUZGT3B0aW9uc30gW29wdGlvbnNdIGZ1cnRoZXIgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgbGl0dGxlRW5kaWFuLCBiaWdUaWZmLCBmaXJzdElGRE9mZnNldCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLmxpdHRsZUVuZGlhbiA9IGxpdHRsZUVuZGlhbjtcbiAgICB0aGlzLmJpZ1RpZmYgPSBiaWdUaWZmO1xuICAgIHRoaXMuZmlyc3RJRkRPZmZzZXQgPSBmaXJzdElGRE9mZnNldDtcbiAgICB0aGlzLmNhY2hlID0gb3B0aW9ucy5jYWNoZSB8fCBmYWxzZTtcbiAgICB0aGlzLmlmZFJlcXVlc3RzID0gW107XG4gICAgdGhpcy5naG9zdFZhbHVlcyA9IG51bGw7XG4gIH1cblxuICBhc3luYyBnZXRTbGljZShvZmZzZXQsIHNpemUpIHtcbiAgICBjb25zdCBmYWxsYmFja1NpemUgPSB0aGlzLmJpZ1RpZmYgPyA0MDQ4IDogMTAyNDtcbiAgICByZXR1cm4gbmV3IERhdGFTbGljZShcbiAgICAgIChhd2FpdCB0aGlzLnNvdXJjZS5mZXRjaChbe1xuICAgICAgICBvZmZzZXQsXG4gICAgICAgIGxlbmd0aDogdHlwZW9mIHNpemUgIT09ICd1bmRlZmluZWQnID8gc2l6ZSA6IGZhbGxiYWNrU2l6ZSxcbiAgICAgIH1dKSlbMF0sXG4gICAgICBvZmZzZXQsXG4gICAgICB0aGlzLmxpdHRsZUVuZGlhbixcbiAgICAgIHRoaXMuYmlnVGlmZixcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc3RydWN0cyB0byBwYXJzZSBhbiBpbWFnZSBmaWxlIGRpcmVjdG9yeSBhdCB0aGUgZ2l2ZW4gZmlsZSBvZmZzZXQuXG4gICAqIEFzIHRoZXJlIGlzIG5vIHdheSB0byBlbnN1cmUgdGhhdCBhIGxvY2F0aW9uIGlzIGluZGVlZCB0aGUgc3RhcnQgb2YgYW4gSUZELFxuICAgKiB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIHdpdGggY2F1dGlvbiAoZS5nIG9ubHkgdXNpbmcgdGhlIElGRCBvZmZzZXRzIGZyb21cbiAgICogdGhlIGhlYWRlcnMgb3Igb3RoZXIgSUZEcykuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgdGhlIG9mZnNldCB0byBwYXJzZSB0aGUgSUZEIGF0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEltYWdlRmlsZURpcmVjdG9yeT59IHRoZSBwYXJzZWQgSUZEXG4gICAqL1xuICBhc3luYyBwYXJzZUZpbGVEaXJlY3RvcnlBdChvZmZzZXQpIHtcbiAgICBjb25zdCBlbnRyeVNpemUgPSB0aGlzLmJpZ1RpZmYgPyAyMCA6IDEyO1xuICAgIGNvbnN0IG9mZnNldFNpemUgPSB0aGlzLmJpZ1RpZmYgPyA4IDogMjtcblxuICAgIGxldCBkYXRhU2xpY2UgPSBhd2FpdCB0aGlzLmdldFNsaWNlKG9mZnNldCk7XG4gICAgY29uc3QgbnVtRGlyRW50cmllcyA9IHRoaXMuYmlnVGlmZlxuICAgICAgPyBkYXRhU2xpY2UucmVhZFVpbnQ2NChvZmZzZXQpXG4gICAgICA6IGRhdGFTbGljZS5yZWFkVWludDE2KG9mZnNldCk7XG5cbiAgICAvLyBpZiB0aGUgc2xpY2UgZG9lcyBub3QgY292ZXIgdGhlIHdob2xlIElGRCwgcmVxdWVzdCBhIGJpZ2dlciBzbGljZSwgd2hlcmUgdGhlXG4gICAgLy8gd2hvbGUgSUZEIGZpdHM6IG51bSBvZiBlbnRyaWVzICsgbiB4IHRhZyBsZW5ndGggKyBvZmZzZXQgdG8gbmV4dCBJRkRcbiAgICBjb25zdCBieXRlU2l6ZSA9IChudW1EaXJFbnRyaWVzICogZW50cnlTaXplKSArICh0aGlzLmJpZ1RpZmYgPyAxNiA6IDYpO1xuICAgIGlmICghZGF0YVNsaWNlLmNvdmVycyhvZmZzZXQsIGJ5dGVTaXplKSkge1xuICAgICAgZGF0YVNsaWNlID0gYXdhaXQgdGhpcy5nZXRTbGljZShvZmZzZXQsIGJ5dGVTaXplKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlRGlyZWN0b3J5ID0ge307XG5cbiAgICAvLyBsb29wIG92ZXIgdGhlIElGRCBhbmQgY3JlYXRlIGEgZmlsZSBkaXJlY3Rvcnkgb2JqZWN0XG4gICAgbGV0IGkgPSBvZmZzZXQgKyAodGhpcy5iaWdUaWZmID8gOCA6IDIpO1xuICAgIGZvciAobGV0IGVudHJ5Q291bnQgPSAwOyBlbnRyeUNvdW50IDwgbnVtRGlyRW50cmllczsgaSArPSBlbnRyeVNpemUsICsrZW50cnlDb3VudCkge1xuICAgICAgY29uc3QgZmllbGRUYWcgPSBkYXRhU2xpY2UucmVhZFVpbnQxNihpKTtcbiAgICAgIGNvbnN0IGZpZWxkVHlwZSA9IGRhdGFTbGljZS5yZWFkVWludDE2KGkgKyAyKTtcbiAgICAgIGNvbnN0IHR5cGVDb3VudCA9IHRoaXMuYmlnVGlmZlxuICAgICAgICA/IGRhdGFTbGljZS5yZWFkVWludDY0KGkgKyA0KVxuICAgICAgICA6IGRhdGFTbGljZS5yZWFkVWludDMyKGkgKyA0KTtcblxuICAgICAgbGV0IGZpZWxkVmFsdWVzO1xuICAgICAgbGV0IHZhbHVlO1xuICAgICAgY29uc3QgZmllbGRUeXBlTGVuZ3RoID0gZ2V0RmllbGRUeXBlTGVuZ3RoKGZpZWxkVHlwZSk7XG4gICAgICBjb25zdCB2YWx1ZU9mZnNldCA9IGkgKyAodGhpcy5iaWdUaWZmID8gMTIgOiA4KTtcblxuICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgdmFsdWUgaXMgZGlyZWN0bHkgZW5jb2RlZCBpbiB0aGUgdGFnIG9yIHJlZmVycyB0byBhXG4gICAgICAvLyBkaWZmZXJlbnQgZXh0ZXJuYWwgYnl0ZSByYW5nZVxuICAgICAgaWYgKGZpZWxkVHlwZUxlbmd0aCAqIHR5cGVDb3VudCA8PSAodGhpcy5iaWdUaWZmID8gOCA6IDQpKSB7XG4gICAgICAgIGZpZWxkVmFsdWVzID0gZ2V0VmFsdWVzKGRhdGFTbGljZSwgZmllbGRUeXBlLCB0eXBlQ291bnQsIHZhbHVlT2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlc29sdmUgdGhlIHJlZmVyZW5jZSB0byB0aGUgYWN0dWFsIGJ5dGUgcmFuZ2VcbiAgICAgICAgY29uc3QgYWN0dWFsT2Zmc2V0ID0gZGF0YVNsaWNlLnJlYWRPZmZzZXQodmFsdWVPZmZzZXQpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBnZXRGaWVsZFR5cGVMZW5ndGgoZmllbGRUeXBlKSAqIHR5cGVDb3VudDtcblxuICAgICAgICAvLyBjaGVjaywgd2hldGhlciB3ZSBhY3R1YWxseSBjb3ZlciB0aGUgcmVmZXJlbmNlZCBieXRlIHJhbmdlOyBpZiBub3QsXG4gICAgICAgIC8vIHJlcXVlc3QgYSBuZXcgc2xpY2Ugb2YgYnl0ZXMgdG8gcmVhZCBmcm9tIGl0XG4gICAgICAgIGlmIChkYXRhU2xpY2UuY292ZXJzKGFjdHVhbE9mZnNldCwgbGVuZ3RoKSkge1xuICAgICAgICAgIGZpZWxkVmFsdWVzID0gZ2V0VmFsdWVzKGRhdGFTbGljZSwgZmllbGRUeXBlLCB0eXBlQ291bnQsIGFjdHVhbE9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZmllbGREYXRhU2xpY2UgPSBhd2FpdCB0aGlzLmdldFNsaWNlKGFjdHVhbE9mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgICBmaWVsZFZhbHVlcyA9IGdldFZhbHVlcyhmaWVsZERhdGFTbGljZSwgZmllbGRUeXBlLCB0eXBlQ291bnQsIGFjdHVhbE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdW5wYWNrIHNpbmdsZSB2YWx1ZXMgZnJvbSB0aGUgYXJyYXlcbiAgICAgIGlmICh0eXBlQ291bnQgPT09IDEgJiYgYXJyYXlGaWVsZHMuaW5kZXhPZihmaWVsZFRhZykgPT09IC0xXG4gICAgICAgICYmICEoZmllbGRUeXBlID09PSBmaWVsZFR5cGVzLlJBVElPTkFMIHx8IGZpZWxkVHlwZSA9PT0gZmllbGRUeXBlcy5TUkFUSU9OQUwpKSB7XG4gICAgICAgIHZhbHVlID0gZmllbGRWYWx1ZXNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGZpZWxkVmFsdWVzO1xuICAgICAgfVxuXG4gICAgICAvLyB3cml0ZSB0aGUgdGFncyB2YWx1ZSB0byB0aGUgZmlsZSBkaXJlY3RseVxuICAgICAgZmlsZURpcmVjdG9yeVtmaWVsZFRhZ05hbWVzW2ZpZWxkVGFnXV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgZ2VvS2V5RGlyZWN0b3J5ID0gcGFyc2VHZW9LZXlEaXJlY3RvcnkoZmlsZURpcmVjdG9yeSk7XG4gICAgY29uc3QgbmV4dElGREJ5dGVPZmZzZXQgPSBkYXRhU2xpY2UucmVhZE9mZnNldChcbiAgICAgIG9mZnNldCArIG9mZnNldFNpemUgKyAoZW50cnlTaXplICogbnVtRGlyRW50cmllcyksXG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgSW1hZ2VGaWxlRGlyZWN0b3J5KFxuICAgICAgZmlsZURpcmVjdG9yeSxcbiAgICAgIGdlb0tleURpcmVjdG9yeSxcbiAgICAgIG5leHRJRkRCeXRlT2Zmc2V0LFxuICAgICk7XG4gIH1cblxuICBhc3luYyByZXF1ZXN0SUZEKGluZGV4KSB7XG4gICAgLy8gc2VlIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGF0IElGRCBpbmRleCByZXF1ZXN0ZWQuXG4gICAgaWYgKHRoaXMuaWZkUmVxdWVzdHNbaW5kZXhdKSB7XG4gICAgICAvLyBhdHRhY2ggdG8gYW4gYWxyZWFkeSByZXF1ZXN0ZWQgSUZEXG4gICAgICByZXR1cm4gdGhpcy5pZmRSZXF1ZXN0c1tpbmRleF07XG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciBpbmRleCAwXG4gICAgICB0aGlzLmlmZFJlcXVlc3RzW2luZGV4XSA9IHRoaXMucGFyc2VGaWxlRGlyZWN0b3J5QXQodGhpcy5maXJzdElGRE9mZnNldCk7XG4gICAgICByZXR1cm4gdGhpcy5pZmRSZXF1ZXN0c1tpbmRleF07XG4gICAgfSBlbHNlIGlmICghdGhpcy5pZmRSZXF1ZXN0c1tpbmRleCAtIDFdKSB7XG4gICAgICAvLyBpZiB0aGUgcHJldmlvdXMgSUZEIHdhcyBub3QgeWV0IGxvYWRlZCwgbG9hZCB0aGF0IG9uZSBmaXJzdFxuICAgICAgLy8gdGhpcyBpcyB0aGUgcmVjdXJzaXZlIGNhbGwuXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmlmZFJlcXVlc3RzW2luZGV4IC0gMV0gPSB0aGlzLnJlcXVlc3RJRkQoaW5kZXggLSAxKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaWYgdGhlIHByZXZpb3VzIG9uZSBhbHJlYWR5IHdhcyBhbiBpbmRleCBlcnJvciwgcmV0aHJvd1xuICAgICAgICAvLyB3aXRoIHRoZSBjdXJyZW50IGluZGV4XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgR2VvVElGRkltYWdlSW5kZXhFcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBHZW9USUZGSW1hZ2VJbmRleEVycm9yKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXRocm93IGFueXRoaW5nIGVsc2VcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgdGhlIHByZXZpb3VzIElGRCB3YXMgbG9hZGVkLCB3ZSBjYW4gZmluYWxseSBmZXRjaCB0aGUgb25lIHdlIGFyZSBpbnRlcmVzdGVkIGluLlxuICAgIC8vIHdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIGFuIElJRkUsIG90aGVyd2lzZSB0aGlzLmlmZFJlcXVlc3RzW2luZGV4XSB3b3VsZCBiZSBkZWxheWVkXG4gICAgdGhpcy5pZmRSZXF1ZXN0c1tpbmRleF0gPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJldmlvdXNJZmQgPSBhd2FpdCB0aGlzLmlmZFJlcXVlc3RzW2luZGV4IC0gMV07XG4gICAgICBpZiAocHJldmlvdXNJZmQubmV4dElGREJ5dGVPZmZzZXQgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEdlb1RJRkZJbWFnZUluZGV4RXJyb3IoaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGaWxlRGlyZWN0b3J5QXQocHJldmlvdXNJZmQubmV4dElGREJ5dGVPZmZzZXQpO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIHRoaXMuaWZkUmVxdWVzdHNbaW5kZXhdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbi10aCBpbnRlcm5hbCBzdWJmaWxlIG9mIGFuIGltYWdlLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9MF0gdGhlIGluZGV4IG9mIHRoZSBpbWFnZSB0byByZXR1cm4uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEdlb1RJRkZJbWFnZT59IHRoZSBpbWFnZSBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICovXG4gIGFzeW5jIGdldEltYWdlKGluZGV4ID0gMCkge1xuICAgIGNvbnN0IGlmZCA9IGF3YWl0IHRoaXMucmVxdWVzdElGRChpbmRleCk7XG4gICAgcmV0dXJuIG5ldyBHZW9USUZGSW1hZ2UoXG4gICAgICBpZmQuZmlsZURpcmVjdG9yeSwgaWZkLmdlb0tleURpcmVjdG9yeSxcbiAgICAgIHRoaXMuZGF0YVZpZXcsIHRoaXMubGl0dGxlRW5kaWFuLCB0aGlzLmNhY2hlLCB0aGlzLnNvdXJjZSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvdW50IG9mIHRoZSBpbnRlcm5hbCBzdWJmaWxlcy5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn0gdGhlIG51bWJlciBvZiBpbnRlcm5hbCBzdWJmaWxlIGltYWdlc1xuICAgKi9cbiAgYXN5bmMgZ2V0SW1hZ2VDb3VudCgpIHtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIC8vIGxvb3AgdW50aWwgd2UgcnVuIG91dCBvZiBJRkRzXG4gICAgbGV0IGhhc05leHQgPSB0cnVlO1xuICAgIHdoaWxlIChoYXNOZXh0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLnJlcXVlc3RJRkQoaW5kZXgpO1xuICAgICAgICArK2luZGV4O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEdlb1RJRkZJbWFnZUluZGV4RXJyb3IpIHtcbiAgICAgICAgICBoYXNOZXh0ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZXMgb2YgdGhlIENPRyBnaG9zdCBhcmVhIGFzIGEgcGFyc2VkIG1hcC5cbiAgICogU2VlIGh0dHBzOi8vZ2RhbC5vcmcvZHJpdmVycy9yYXN0ZXIvY29nLmh0bWwjaGVhZGVyLWdob3N0LWFyZWEgZm9yIHJlZmVyZW5jZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSB0aGUgcGFyc2VkIGdob3N0IGFyZWEgb3IgbnVsbCwgaWYgbm8gc3VjaCBhcmVhIHdhcyBmb3VuZFxuICAgKi9cbiAgYXN5bmMgZ2V0R2hvc3RWYWx1ZXMoKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5iaWdUaWZmID8gMTYgOiA4O1xuICAgIGlmICh0aGlzLmdob3N0VmFsdWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5naG9zdFZhbHVlcztcbiAgICB9XG4gICAgY29uc3QgZGV0ZWN0aW9uU3RyaW5nID0gJ0dEQUxfU1RSVUNUVVJBTF9NRVRBREFUQV9TSVpFPSc7XG4gICAgY29uc3QgaGV1cmlzdGljQXJlYVNpemUgPSBkZXRlY3Rpb25TdHJpbmcubGVuZ3RoICsgMTAwO1xuICAgIGxldCBzbGljZSA9IGF3YWl0IHRoaXMuZ2V0U2xpY2Uob2Zmc2V0LCBoZXVyaXN0aWNBcmVhU2l6ZSk7XG4gICAgaWYgKGRldGVjdGlvblN0cmluZyA9PT0gZ2V0VmFsdWVzKHNsaWNlLCBmaWVsZFR5cGVzLkFTQ0lJLCBkZXRlY3Rpb25TdHJpbmcubGVuZ3RoLCBvZmZzZXQpKSB7XG4gICAgICBjb25zdCB2YWx1ZXNTdHJpbmcgPSBnZXRWYWx1ZXMoc2xpY2UsIGZpZWxkVHlwZXMuQVNDSUksIGhldXJpc3RpY0FyZWFTaXplLCBvZmZzZXQpO1xuICAgICAgY29uc3QgZmlyc3RMaW5lID0gdmFsdWVzU3RyaW5nLnNwbGl0KCdcXG4nKVswXTtcbiAgICAgIGNvbnN0IG1ldGFkYXRhU2l6ZSA9IE51bWJlcihmaXJzdExpbmUuc3BsaXQoJz0nKVsxXS5zcGxpdCgnICcpWzBdKSArIGZpcnN0TGluZS5sZW5ndGg7XG4gICAgICBpZiAobWV0YWRhdGFTaXplID4gaGV1cmlzdGljQXJlYVNpemUpIHtcbiAgICAgICAgc2xpY2UgPSBhd2FpdCB0aGlzLmdldFNsaWNlKG9mZnNldCwgbWV0YWRhdGFTaXplKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZ1bGxTdHJpbmcgPSBnZXRWYWx1ZXMoc2xpY2UsIGZpZWxkVHlwZXMuQVNDSUksIG1ldGFkYXRhU2l6ZSwgb2Zmc2V0KTtcbiAgICAgIHRoaXMuZ2hvc3RWYWx1ZXMgPSB7fTtcbiAgICAgIGZ1bGxTdHJpbmdcbiAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAuZmlsdGVyKChsaW5lKSA9PiBsaW5lLmxlbmd0aCA+IDApXG4gICAgICAgIC5tYXAoKGxpbmUpID0+IGxpbmUuc3BsaXQoJz0nKSlcbiAgICAgICAgLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgIHRoaXMuZ2hvc3RWYWx1ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2hvc3RWYWx1ZXM7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSAoR2VvKVRJRkYgZmlsZSBmcm9tIHRoZSBnaXZlbiBzb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gc291cmNlIFRoZSBzb3VyY2Ugb2YgZGF0YSB0byBwYXJzZSBmcm9tLlxuICAgKiBAcGFyYW0ge0dlb1RJRkZPcHRpb25zfSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBbc2lnbmFsXSBBbiBBYm9ydFNpZ25hbCB0aGF0IG1heSBiZSBzaWduYWxsZWQgaWYgdGhlIHJlcXVlc3QgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21Tb3VyY2Uoc291cmNlLCBvcHRpb25zLCBzaWduYWwpIHtcbiAgICBjb25zdCBoZWFkZXJEYXRhID0gKGF3YWl0IHNvdXJjZS5mZXRjaChbeyBvZmZzZXQ6IDAsIGxlbmd0aDogMTAyNCB9XSwgc2lnbmFsKSlbMF07XG4gICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXc2NChoZWFkZXJEYXRhKTtcblxuICAgIGNvbnN0IEJPTSA9IGRhdGFWaWV3LmdldFVpbnQxNigwLCAwKTtcbiAgICBsZXQgbGl0dGxlRW5kaWFuO1xuICAgIGlmIChCT00gPT09IDB4NDk0OSkge1xuICAgICAgbGl0dGxlRW5kaWFuID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKEJPTSA9PT0gMHg0RDREKSB7XG4gICAgICBsaXR0bGVFbmRpYW4gPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBieXRlIG9yZGVyIHZhbHVlLicpO1xuICAgIH1cblxuICAgIGNvbnN0IG1hZ2ljTnVtYmVyID0gZGF0YVZpZXcuZ2V0VWludDE2KDIsIGxpdHRsZUVuZGlhbik7XG4gICAgbGV0IGJpZ1RpZmY7XG4gICAgaWYgKG1hZ2ljTnVtYmVyID09PSA0Mikge1xuICAgICAgYmlnVGlmZiA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAobWFnaWNOdW1iZXIgPT09IDQzKSB7XG4gICAgICBiaWdUaWZmID0gdHJ1ZTtcbiAgICAgIGNvbnN0IG9mZnNldEJ5dGVTaXplID0gZGF0YVZpZXcuZ2V0VWludDE2KDQsIGxpdHRsZUVuZGlhbik7XG4gICAgICBpZiAob2Zmc2V0Qnl0ZVNpemUgIT09IDgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBvZmZzZXQgYnl0ZS1zaXplLicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1hZ2ljIG51bWJlci4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdElGRE9mZnNldCA9IGJpZ1RpZmZcbiAgICAgID8gZGF0YVZpZXcuZ2V0VWludDY0KDgsIGxpdHRsZUVuZGlhbilcbiAgICAgIDogZGF0YVZpZXcuZ2V0VWludDMyKDQsIGxpdHRsZUVuZGlhbik7XG4gICAgcmV0dXJuIG5ldyBHZW9USUZGKHNvdXJjZSwgbGl0dGxlRW5kaWFuLCBiaWdUaWZmLCBmaXJzdElGRE9mZnNldCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSB1bmRlcmx5aW5nIGZpbGUgYnVmZmVyXG4gICAqIE4uQi4gQWZ0ZXIgdGhlIEdlb1RJRkYgaGFzIGJlZW4gY29tcGxldGVseSBwcm9jZXNzZWQgaXQgbmVlZHNcbiAgICogdG8gYmUgY2xvc2VkIGJ1dCBvbmx5IGlmIGl0IGhhcyBiZWVuIGNvbnN0cnVjdGVkIGZyb20gYSBmaWxlLlxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZS5jbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmNsb3NlKCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgeyBHZW9USUZGIH07XG5leHBvcnQgZGVmYXVsdCBHZW9USUZGO1xuXG4vKipcbiAqIFdyYXBwZXIgZm9yIEdlb1RJRkYgZmlsZXMgdGhhdCBoYXZlIGV4dGVybmFsIG92ZXJ2aWV3cy5cbiAqIEBhdWdtZW50cyBHZW9USUZGQmFzZVxuICovXG5jbGFzcyBNdWx0aUdlb1RJRkYgZXh0ZW5kcyBHZW9USUZGQmFzZSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgTXVsdGlHZW9USUZGIGZyb20gYSBtYWluIGFuZCBzZXZlcmFsIG92ZXJ2aWV3IGZpbGVzLlxuICAgKiBAcGFyYW0ge0dlb1RJRkZ9IG1haW5GaWxlIFRoZSBtYWluIEdlb1RJRkYgZmlsZS5cbiAgICogQHBhcmFtIHtHZW9USUZGW119IG92ZXJ2aWV3RmlsZXMgQW4gYXJyYXkgb2Ygb3ZlcnZpZXcgZmlsZXMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtYWluRmlsZSwgb3ZlcnZpZXdGaWxlcykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5tYWluRmlsZSA9IG1haW5GaWxlO1xuICAgIHRoaXMub3ZlcnZpZXdGaWxlcyA9IG92ZXJ2aWV3RmlsZXM7XG4gICAgdGhpcy5pbWFnZUZpbGVzID0gW21haW5GaWxlXS5jb25jYXQob3ZlcnZpZXdGaWxlcyk7XG5cbiAgICB0aGlzLmZpbGVEaXJlY3Rvcmllc1BlckZpbGUgPSBudWxsO1xuICAgIHRoaXMuZmlsZURpcmVjdG9yaWVzUGVyRmlsZVBhcnNpbmcgPSBudWxsO1xuICAgIHRoaXMuaW1hZ2VDb3VudCA9IG51bGw7XG4gIH1cblxuICBhc3luYyBwYXJzZUZpbGVEaXJlY3Rvcmllc1BlckZpbGUoKSB7XG4gICAgY29uc3QgcmVxdWVzdHMgPSBbdGhpcy5tYWluRmlsZS5wYXJzZUZpbGVEaXJlY3RvcnlBdCh0aGlzLm1haW5GaWxlLmZpcnN0SUZET2Zmc2V0KV1cbiAgICAgIC5jb25jYXQodGhpcy5vdmVydmlld0ZpbGVzLm1hcCgoZmlsZSkgPT4gZmlsZS5wYXJzZUZpbGVEaXJlY3RvcnlBdChmaWxlLmZpcnN0SUZET2Zmc2V0KSkpO1xuXG4gICAgdGhpcy5maWxlRGlyZWN0b3JpZXNQZXJGaWxlID0gYXdhaXQgUHJvbWlzZS5hbGwocmVxdWVzdHMpO1xuICAgIHJldHVybiB0aGlzLmZpbGVEaXJlY3Rvcmllc1BlckZpbGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBuLXRoIGludGVybmFsIHN1YmZpbGUgb2YgYW4gaW1hZ2UuIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBpcyByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleD0wXSB0aGUgaW5kZXggb2YgdGhlIGltYWdlIHRvIHJldHVybi5cbiAgICogQHJldHVybnMge1Byb21pc2U8R2VvVElGRkltYWdlPn0gdGhlIGltYWdlIGF0IHRoZSBnaXZlbiBpbmRleFxuICAgKi9cbiAgYXN5bmMgZ2V0SW1hZ2UoaW5kZXggPSAwKSB7XG4gICAgYXdhaXQgdGhpcy5nZXRJbWFnZUNvdW50KCk7XG4gICAgYXdhaXQgdGhpcy5wYXJzZUZpbGVEaXJlY3Rvcmllc1BlckZpbGUoKTtcbiAgICBsZXQgdmlzaXRlZCA9IDA7XG4gICAgbGV0IHJlbGF0aXZlSW5kZXggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbWFnZUZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpbWFnZUZpbGUgPSB0aGlzLmltYWdlRmlsZXNbaV07XG4gICAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgdGhpcy5pbWFnZUNvdW50c1tpXTsgaWkrKykge1xuICAgICAgICBpZiAoaW5kZXggPT09IHZpc2l0ZWQpIHtcbiAgICAgICAgICBjb25zdCBpZmQgPSBhd2FpdCBpbWFnZUZpbGUucmVxdWVzdElGRChyZWxhdGl2ZUluZGV4KTtcbiAgICAgICAgICByZXR1cm4gbmV3IEdlb1RJRkZJbWFnZShcbiAgICAgICAgICAgIGlmZC5maWxlRGlyZWN0b3J5LCBpZmQuZ2VvS2V5RGlyZWN0b3J5LFxuICAgICAgICAgICAgaW1hZ2VGaWxlLmRhdGFWaWV3LCBpbWFnZUZpbGUubGl0dGxlRW5kaWFuLCBpbWFnZUZpbGUuY2FjaGUsIGltYWdlRmlsZS5zb3VyY2UsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2aXNpdGVkKys7XG4gICAgICAgIHJlbGF0aXZlSW5kZXgrKztcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlSW5kZXggPSAwO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGltYWdlIGluZGV4Jyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY291bnQgb2YgdGhlIGludGVybmFsIHN1YmZpbGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fSB0aGUgbnVtYmVyIG9mIGludGVybmFsIHN1YmZpbGUgaW1hZ2VzXG4gICAqL1xuICBhc3luYyBnZXRJbWFnZUNvdW50KCkge1xuICAgIGlmICh0aGlzLmltYWdlQ291bnQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlQ291bnQ7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RzID0gW3RoaXMubWFpbkZpbGUuZ2V0SW1hZ2VDb3VudCgpXVxuICAgICAgLmNvbmNhdCh0aGlzLm92ZXJ2aWV3RmlsZXMubWFwKChmaWxlKSA9PiBmaWxlLmdldEltYWdlQ291bnQoKSkpO1xuICAgIHRoaXMuaW1hZ2VDb3VudHMgPSBhd2FpdCBQcm9taXNlLmFsbChyZXF1ZXN0cyk7XG4gICAgdGhpcy5pbWFnZUNvdW50ID0gdGhpcy5pbWFnZUNvdW50cy5yZWR1Y2UoKGNvdW50LCBpZmRzKSA9PiBjb3VudCArIGlmZHMsIDApO1xuICAgIHJldHVybiB0aGlzLmltYWdlQ291bnQ7XG4gIH1cbn1cblxuZXhwb3J0IHsgTXVsdGlHZW9USUZGIH07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBHZW9USUZGIGZyb20gYSByZW1vdGUgVVJMLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIGFjY2VzcyB0aGUgaW1hZ2UgZnJvbVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgc291cmNlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUge0BsaW5rIG1ha2VSZW1vdGVTb3VyY2V9IGZvciBkZXRhaWxzLlxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxHZW9USUZGPn0gVGhlIHJlc3VsdGluZyBHZW9USUZGIGZpbGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmcm9tVXJsKHVybCwgb3B0aW9ucyA9IHt9LCBzaWduYWwpIHtcbiAgcmV0dXJuIEdlb1RJRkYuZnJvbVNvdXJjZShtYWtlUmVtb3RlU291cmNlKHVybCwgb3B0aW9ucyksIHNpZ25hbCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBHZW9USUZGIGZyb20gYSBjdXN0b20ge0BsaW5rIEJhc2VDbGllbnR9LlxuICogQHBhcmFtIHtCYXNlQ2xpZW50fSBjbGllbnQgVGhlIGNsaWVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHNvdXJjZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIHtAbGluayBtYWtlUmVtb3RlU291cmNlfSBmb3IgZGV0YWlscy5cbiAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICogQHJldHVybnMge1Byb21pc2U8R2VvVElGRj59IFRoZSByZXN1bHRpbmcgR2VvVElGRiBmaWxlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZnJvbUN1c3RvbUNsaWVudChjbGllbnQsIG9wdGlvbnMgPSB7fSwgc2lnbmFsKSB7XG4gIHJldHVybiBHZW9USUZGLmZyb21Tb3VyY2UobWFrZUN1c3RvbVNvdXJjZShjbGllbnQsIG9wdGlvbnMpLCBzaWduYWwpO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdCBhIG5ldyBHZW9USUZGIGZyb20gYW5cbiAqIFtBcnJheUJ1ZmZlcl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXlCdWZmZXJ9LlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGRhdGEgdG8gcmVhZCB0aGUgZmlsZSBmcm9tLlxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxHZW9USUZGPn0gVGhlIHJlc3VsdGluZyBHZW9USUZGIGZpbGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIsIHNpZ25hbCkge1xuICByZXR1cm4gR2VvVElGRi5mcm9tU291cmNlKG1ha2VCdWZmZXJTb3VyY2UoYXJyYXlCdWZmZXIpLCBzaWduYWwpO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdCBhIEdlb1RJRkYgZnJvbSBhIGxvY2FsIGZpbGUgcGF0aC4gVGhpcyB1c2VzIHRoZSBub2RlXG4gKiBbZmlsZXN5c3RlbSBBUElde0BsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZnMuaHRtbH0gYW5kIGlzXG4gKiBub3QgYXZhaWxhYmxlIG9uIGJyb3dzZXJzLlxuICpcbiAqIE4uQi4gQWZ0ZXIgdGhlIEdlb1RJRkYgaGFzIGJlZW4gY29tcGxldGVseSBwcm9jZXNzZWQgaXQgbmVlZHNcbiAqIHRvIGJlIGNsb3NlZCBidXQgb25seSBpZiBpdCBoYXMgYmVlbiBjb25zdHJ1Y3RlZCBmcm9tIGEgZmlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBmaWxlIHBhdGggdG8gcmVhZCBmcm9tLlxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxHZW9USUZGPn0gVGhlIHJlc3VsdGluZyBHZW9USUZGIGZpbGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmcm9tRmlsZShwYXRoLCBzaWduYWwpIHtcbiAgcmV0dXJuIEdlb1RJRkYuZnJvbVNvdXJjZShtYWtlRmlsZVNvdXJjZShwYXRoKSwgc2lnbmFsKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3QgYSBHZW9USUZGIGZyb20gYW4gSFRNTFxuICogW0Jsb2Jde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9ifSBvclxuICogW0ZpbGVde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlfVxuICogb2JqZWN0LlxuICogQHBhcmFtIHtCbG9ifEZpbGV9IGJsb2IgVGhlIEJsb2Igb3IgRmlsZSBvYmplY3QgdG8gcmVhZCBmcm9tLlxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxHZW9USUZGPn0gVGhlIHJlc3VsdGluZyBHZW9USUZGIGZpbGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmcm9tQmxvYihibG9iLCBzaWduYWwpIHtcbiAgcmV0dXJuIEdlb1RJRkYuZnJvbVNvdXJjZShtYWtlRmlsZVJlYWRlclNvdXJjZShibG9iKSwgc2lnbmFsKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3QgYSBNdWx0aUdlb1RJRkYgZnJvbSB0aGUgZ2l2ZW4gVVJMcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtYWluVXJsIFRoZSBVUkwgZm9yIHRoZSBtYWluIGZpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvdmVydmlld1VybHMgQW4gYXJyYXkgb2YgVVJMcyBmb3IgdGhlIG92ZXJ2aWV3IGltYWdlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHNvdXJjZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIFttYWtlUmVtb3RlU291cmNlXXtAbGluayBtb2R1bGU6c291cmNlLm1ha2VSZW1vdGVTb3VyY2V9XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBkZXRhaWxzLlxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxNdWx0aUdlb1RJRkY+fSBUaGUgcmVzdWx0aW5nIE11bHRpR2VvVElGRiBmaWxlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZnJvbVVybHMobWFpblVybCwgb3ZlcnZpZXdVcmxzID0gW10sIG9wdGlvbnMgPSB7fSwgc2lnbmFsKSB7XG4gIGNvbnN0IG1haW5GaWxlID0gYXdhaXQgR2VvVElGRi5mcm9tU291cmNlKG1ha2VSZW1vdGVTb3VyY2UobWFpblVybCwgb3B0aW9ucyksIHNpZ25hbCk7XG4gIGNvbnN0IG92ZXJ2aWV3RmlsZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBvdmVydmlld1VybHMubWFwKCh1cmwpID0+IEdlb1RJRkYuZnJvbVNvdXJjZShtYWtlUmVtb3RlU291cmNlKHVybCwgb3B0aW9ucykpKSxcbiAgKTtcblxuICByZXR1cm4gbmV3IE11bHRpR2VvVElGRihtYWluRmlsZSwgb3ZlcnZpZXdGaWxlcyk7XG59XG5cbi8qKlxuICogTWFpbiBjcmVhdGluZyBmdW5jdGlvbiBmb3IgR2VvVElGRiBmaWxlcy5cbiAqIEBwYXJhbSB7KEFycmF5KX0gYXJyYXkgb2YgcGl4ZWwgdmFsdWVzXG4gKiBAcmV0dXJucyB7bWV0YWRhdGF9IG1ldGFkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZUFycmF5QnVmZmVyKHZhbHVlcywgbWV0YWRhdGEpIHtcbiAgcmV0dXJuIHdyaXRlR2VvdGlmZih2YWx1ZXMsIG1ldGFkYXRhKTtcbn1cblxuZXhwb3J0IHsgUG9vbCB9O1xuZXhwb3J0IHsgR2VvVElGRkltYWdlIH07XG5leHBvcnQgeyBCYXNlQ2xpZW50LCBCYXNlUmVzcG9uc2UgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/geotiff.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/geotiffimage.js":
/*!**********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/geotiffimage.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _petamoriken_float16__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @petamoriken/float16 */ \"(app-pages-browser)/./node_modules/@petamoriken/float16/src/DataView.mjs\");\n/* harmony import */ var xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xml-utils/get-attribute.js */ \"(app-pages-browser)/./node_modules/xml-utils/get-attribute.js\");\n/* harmony import */ var xml_utils_find_tags_by_name_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xml-utils/find-tags-by-name.js */ \"(app-pages-browser)/./node_modules/xml-utils/find-tags-by-name.js\");\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./globals.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/globals.js\");\n/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rgb.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/rgb.js\");\n/* harmony import */ var _compression_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./compression/index.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/compression/index.js\");\n/* harmony import */ var _resample_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resample.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/resample.js\");\n/** @module geotiffimage */\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n/** @typedef {import(\"./geotiff.js\").ReadRasterResult} ReadRasterResult */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {import('./source/basesource').BaseSource} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return (0,_petamoriken_float16__WEBPACK_IMPORTED_MODULE_2__.getFloat16)(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|import(\"./geotiff\").BaseDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray|TypedArray[]} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<ReadRasterResult>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        let getPromise;\n        if (this.planarConfiguration === 1) {\n          getPromise = this.getTileOrStrip(xTile, yTile, 0, poolOrDecoder, signal);\n        }\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sample);\n            getPromise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          }\n          const promise = getPromise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n          promises.push(promise);\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = (0,_resample_js__WEBPACK_IMPORTED_MODULE_3__.resampleInterleaved)(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = (0,_resample_js__WEBPACK_IMPORTED_MODULE_3__.resample)(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await (0,_compression_index_js__WEBPACK_IMPORTED_MODULE_4__.getDecoder)(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * grayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<ReadRasterResult>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === _globals_js__WEBPACK_IMPORTED_MODULE_5__.ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.WhiteIsZero:\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.BlackIsZero:\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.YCbCr:\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.WhiteIsZero:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromWhiteIsZero)(raster, max);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.BlackIsZero:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromBlackIsZero)(raster, max);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.Palette:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromPalette)(raster, fileDirectory.ColorMap);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CMYK:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromCMYK)(raster);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.YCbCr:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromYCbCr)(raster);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CIELab:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromCIELab)(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = xml_utils_find_tags_by_name_js__WEBPACK_IMPORTED_MODULE_1__(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter((item) => xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__(item, 'sample') === undefined);\n    } else {\n      items = items.filter((item) => Number(xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      if (modelTransformation[1] === 0 && modelTransformation[4] === 0) {\n        return [\n          modelTransformation[0],\n          -modelTransformation[5],\n          modelTransformation[10],\n        ];\n      }\n      return [\n        Math.sqrt((modelTransformation[0] * modelTransformation[0])\n          + (modelTransformation[4] * modelTransformation[4])),\n        -Math.sqrt((modelTransformation[1] * modelTransformation[1])\n          + (modelTransformation[5] * modelTransformation[5])),\n        modelTransformation[10]];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @param {boolean} [tilegrid=false] If true return extent for a tilegrid\n   *                                   without adjustment for ModelTransformation.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox(tilegrid = false) {\n    const height = this.getHeight();\n    const width = this.getWidth();\n\n    if (this.fileDirectory.ModelTransformation && !tilegrid) {\n      // eslint-disable-next-line no-unused-vars\n      const [a, b, c, d, e, f, g, h] = this.fileDirectory.ModelTransformation;\n\n      const corners = [\n        [0, 0],\n        [0, height],\n        [width, 0],\n        [width, height],\n      ];\n\n      const projected = corners.map(([I, J]) => [\n        d + (a * I) + (b * J),\n        h + (e * I) + (f * J),\n      ]);\n\n      const xs = projected.map((pt) => pt[0]);\n      const ys = projected.map((pt) => pt[1]);\n\n      return [\n        Math.min(...xs),\n        Math.min(...ys),\n        Math.max(...xs),\n        Math.max(...ys),\n      ];\n    } else {\n      const origin = this.getOrigin();\n      const resolution = this.getResolution();\n\n      const x1 = origin[0];\n      const y1 = origin[1];\n\n      const x2 = x1 + (resolution[0] * width);\n      const y2 = y1 + (resolution[1] * height);\n\n      return [\n        Math.min(x1, x2),\n        Math.min(y1, y2),\n        Math.max(x1, x2),\n        Math.max(y1, y2),\n      ];\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (GeoTIFFImage);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2dlb3RpZmZpbWFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ2tEO0FBQ0k7QUFDTTs7QUFFa0I7QUFDNEI7QUFDdEQ7QUFDVTs7QUFFOUQ7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxlQUFlO0FBQzdCLGNBQWMsZUFBZTtBQUM3QjtBQUNBLGNBQWMsZUFBZTtBQUM3QixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxhQUFhO0FBQzNCO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxtQ0FBbUM7QUFDakQsY0FBYyx5Q0FBeUM7O0FBRXZEO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztB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LGtCQUFrQjtBQUN0QztBQUNBLGVBQWUsdURBQVk7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrREFBZSxZQUFZLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvZ2VvdGlmZmltYWdlLmpzPzEzMDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBtb2R1bGUgZ2VvdGlmZmltYWdlICovXG5pbXBvcnQgeyBnZXRGbG9hdDE2IH0gZnJvbSAnQHBldGFtb3Jpa2VuL2Zsb2F0MTYnO1xuaW1wb3J0IGdldEF0dHJpYnV0ZSBmcm9tICd4bWwtdXRpbHMvZ2V0LWF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgZmluZFRhZ3NCeU5hbWUgZnJvbSAneG1sLXV0aWxzL2ZpbmQtdGFncy1ieS1uYW1lLmpzJztcblxuaW1wb3J0IHsgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMsIEV4dHJhU2FtcGxlc1ZhbHVlcyB9IGZyb20gJy4vZ2xvYmFscy5qcyc7XG5pbXBvcnQgeyBmcm9tV2hpdGVJc1plcm8sIGZyb21CbGFja0lzWmVybywgZnJvbVBhbGV0dGUsIGZyb21DTVlLLCBmcm9tWUNiQ3IsIGZyb21DSUVMYWIgfSBmcm9tICcuL3JnYi5qcyc7XG5pbXBvcnQgeyBnZXREZWNvZGVyIH0gZnJvbSAnLi9jb21wcmVzc2lvbi9pbmRleC5qcyc7XG5pbXBvcnQgeyByZXNhbXBsZSwgcmVzYW1wbGVJbnRlcmxlYXZlZCB9IGZyb20gJy4vcmVzYW1wbGUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlYWRSYXN0ZXJPcHRpb25zXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFt3aW5kb3c9d2hvbGUgd2luZG93XSB0aGUgc3Vic2V0IHRvIHJlYWQgZGF0YSBmcm9tIGluIHBpeGVscy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW2Jib3g9d2hvbGUgaW1hZ2VdIHRoZSBzdWJzZXQgdG8gcmVhZCBkYXRhIGZyb20gaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW3NhbXBsZXM9YWxsIHNhbXBsZXNdIHRoZSBzZWxlY3Rpb24gb2Ygc2FtcGxlcyB0byByZWFkIGZyb20uIERlZmF1bHQgaXMgYWxsIHNhbXBsZXMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnRlcmxlYXZlPWZhbHNlXSB3aGV0aGVyIHRoZSBkYXRhIHNoYWxsIGJlIHJlYWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gb25lIHNpbmdsZSBhcnJheSBvciBzZXBhcmF0ZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheXMuXG4gKiBAcHJvcGVydHkge1Bvb2x9IFtwb29sPW51bGxdIFRoZSBvcHRpb25hbCBkZWNvZGVyIHBvb2wgdG8gdXNlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt3aWR0aF0gVGhlIGRlc2lyZWQgd2lkdGggb2YgdGhlIG91dHB1dC4gV2hlbiB0aGUgd2lkdGggaXMgbm90IHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1lIGFzIHRoZSBpbWFnZXMsIHJlc2FtcGxpbmcgd2lsbCBiZSBwZXJmb3JtZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2hlaWdodF0gVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBvdXRwdXQuIFdoZW4gdGhlIHdpZHRoIGlzIG5vdCB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbWUgYXMgdGhlIGltYWdlcywgcmVzYW1wbGluZyB3aWxsIGJlIHBlcmZvcm1lZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcmVzYW1wbGVNZXRob2Q9J25lYXJlc3QnXSBUaGUgZGVzaXJlZCByZXNhbXBsaW5nIG1ldGhvZC5cbiAqIEBwcm9wZXJ0eSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gKiBAcHJvcGVydHkge251bWJlcnxudW1iZXJbXX0gW2ZpbGxWYWx1ZV0gVGhlIHZhbHVlIHRvIHVzZSBmb3IgcGFydHMgb2YgdGhlIGltYWdlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRzaWRlIG9mIHRoZSBpbWFnZXMgZXh0ZW50LiBXaGVuIG11bHRpcGxlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVzIGFyZSByZXF1ZXN0ZWQsIGFuIGFycmF5IG9mIGZpbGwgdmFsdWVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW4gYmUgcGFzc2VkLlxuICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi9nZW90aWZmLmpzXCIpLlR5cGVkQXJyYXl9IFR5cGVkQXJyYXkgKi9cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi9nZW90aWZmLmpzXCIpLlJlYWRSYXN0ZXJSZXN1bHR9IFJlYWRSYXN0ZXJSZXN1bHQgKi9cblxuZnVuY3Rpb24gc3VtKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIGxldCBzID0gMDtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBzICs9IGFycmF5W2ldO1xuICB9XG4gIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiBhcnJheUZvclR5cGUoZm9ybWF0LCBiaXRzUGVyU2FtcGxlLCBzaXplKSB7XG4gIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgY2FzZSAxOiAvLyB1bnNpZ25lZCBpbnRlZ2VyIGRhdGFcbiAgICAgIGlmIChiaXRzUGVyU2FtcGxlIDw9IDgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgfSBlbHNlIGlmIChiaXRzUGVyU2FtcGxlIDw9IDE2KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDE2QXJyYXkoc2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKGJpdHNQZXJTYW1wbGUgPD0gMzIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShzaXplKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjogLy8gdHdvcyBjb21wbGVtZW50IHNpZ25lZCBpbnRlZ2VyIGRhdGFcbiAgICAgIGlmIChiaXRzUGVyU2FtcGxlID09PSA4KSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50OEFycmF5KHNpemUpO1xuICAgICAgfSBlbHNlIGlmIChiaXRzUGVyU2FtcGxlID09PSAxNikge1xuICAgICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoc2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKGJpdHNQZXJTYW1wbGUgPT09IDMyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShzaXplKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzogLy8gZmxvYXRpbmcgcG9pbnQgZGF0YVxuICAgICAgc3dpdGNoIChiaXRzUGVyU2FtcGxlKSB7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG4gICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkoc2l6ZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cbiAgdGhyb3cgRXJyb3IoJ1Vuc3VwcG9ydGVkIGRhdGEgZm9ybWF0L2JpdHNQZXJTYW1wbGUnKTtcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uKGZvcm1hdCwgYml0c1BlclNhbXBsZSkge1xuICBpZiAoKGZvcm1hdCA9PT0gMSB8fCBmb3JtYXQgPT09IDIpICYmIGJpdHNQZXJTYW1wbGUgPD0gMzIgJiYgYml0c1BlclNhbXBsZSAlIDggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAzICYmIChiaXRzUGVyU2FtcGxlID09PSAxNiB8fCBiaXRzUGVyU2FtcGxlID09PSAzMiB8fCBiaXRzUGVyU2FtcGxlID09PSA2NCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KGluQnVmZmVyLCBmb3JtYXQsIHBsYW5hckNvbmZpZ3VyYXRpb24sIHNhbXBsZXNQZXJQaXhlbCwgYml0c1BlclNhbXBsZSwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0KSB7XG4gIC8vIGNvbnN0IGluQnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoaW5CdWZmZXIpO1xuICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGluQnVmZmVyKTtcbiAgY29uc3Qgb3V0U2l6ZSA9IHBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDJcbiAgICA/IHRpbGVIZWlnaHQgKiB0aWxlV2lkdGhcbiAgICA6IHRpbGVIZWlnaHQgKiB0aWxlV2lkdGggKiBzYW1wbGVzUGVyUGl4ZWw7XG4gIGNvbnN0IHNhbXBsZXNUb1RyYW5zZmVyID0gcGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMlxuICAgID8gMSA6IHNhbXBsZXNQZXJQaXhlbDtcbiAgY29uc3Qgb3V0QXJyYXkgPSBhcnJheUZvclR5cGUoZm9ybWF0LCBiaXRzUGVyU2FtcGxlLCBvdXRTaXplKTtcbiAgLy8gbGV0IHBpeGVsID0gMDtcblxuICBjb25zdCBiaXRNYXNrID0gcGFyc2VJbnQoJzEnLnJlcGVhdChiaXRzUGVyU2FtcGxlKSwgMik7XG5cbiAgaWYgKGZvcm1hdCA9PT0gMSkgeyAvLyB1bnNpZ25lZCBpbnRlZ2VyXG4gICAgLy8gdHJhbnNsYXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL09TR2VvL2dkYWwvYmxvYi9tYXN0ZXIvZ2RhbC9mcm10cy9ndGlmZi9nZW90aWZmLmNwcCNMNzMzN1xuICAgIGxldCBwaXhlbEJpdFNraXA7XG4gICAgLy8gbGV0IHNhbXBsZUJpdE9mZnNldCA9IDA7XG4gICAgaWYgKHBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDEpIHtcbiAgICAgIHBpeGVsQml0U2tpcCA9IHNhbXBsZXNQZXJQaXhlbCAqIGJpdHNQZXJTYW1wbGU7XG4gICAgICAvLyBzYW1wbGVCaXRPZmZzZXQgPSAoc2FtcGxlc1BlclBpeGVsIC0gMSkgKiBiaXRzUGVyU2FtcGxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwaXhlbEJpdFNraXAgPSBiaXRzUGVyU2FtcGxlO1xuICAgIH1cblxuICAgIC8vIEJpdHMgcGVyIGxpbmUgcm91bmRzIHVwIHRvIG5leHQgYnl0ZSBib3VuZGFyeS5cbiAgICBsZXQgYml0c1BlckxpbmUgPSB0aWxlV2lkdGggKiBwaXhlbEJpdFNraXA7XG4gICAgaWYgKChiaXRzUGVyTGluZSAmIDcpICE9PSAwKSB7XG4gICAgICBiaXRzUGVyTGluZSA9IChiaXRzUGVyTGluZSArIDcpICYgKH43KTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRpbGVIZWlnaHQ7ICsreSkge1xuICAgICAgY29uc3QgbGluZUJpdE9mZnNldCA9IHkgKiBiaXRzUGVyTGluZTtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGlsZVdpZHRoOyArK3gpIHtcbiAgICAgICAgY29uc3QgcGl4ZWxCaXRPZmZzZXQgPSBsaW5lQml0T2Zmc2V0ICsgKHggKiBzYW1wbGVzVG9UcmFuc2ZlciAqIGJpdHNQZXJTYW1wbGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXNUb1RyYW5zZmVyOyArK2kpIHtcbiAgICAgICAgICBjb25zdCBiaXRPZmZzZXQgPSBwaXhlbEJpdE9mZnNldCArIChpICogYml0c1BlclNhbXBsZSk7XG4gICAgICAgICAgY29uc3Qgb3V0SW5kZXggPSAoKCh5ICogdGlsZVdpZHRoKSArIHgpICogc2FtcGxlc1RvVHJhbnNmZXIpICsgaTtcblxuICAgICAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBNYXRoLmZsb29yKGJpdE9mZnNldCAvIDgpO1xuICAgICAgICAgIGNvbnN0IGlubmVyQml0T2Zmc2V0ID0gYml0T2Zmc2V0ICUgODtcbiAgICAgICAgICBpZiAoaW5uZXJCaXRPZmZzZXQgKyBiaXRzUGVyU2FtcGxlIDw9IDgpIHtcbiAgICAgICAgICAgIG91dEFycmF5W291dEluZGV4XSA9ICh2aWV3LmdldFVpbnQ4KGJ5dGVPZmZzZXQpID4+ICg4IC0gYml0c1BlclNhbXBsZSkgLSBpbm5lckJpdE9mZnNldCkgJiBiaXRNYXNrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5uZXJCaXRPZmZzZXQgKyBiaXRzUGVyU2FtcGxlIDw9IDE2KSB7XG4gICAgICAgICAgICBvdXRBcnJheVtvdXRJbmRleF0gPSAodmlldy5nZXRVaW50MTYoYnl0ZU9mZnNldCkgPj4gKDE2IC0gYml0c1BlclNhbXBsZSkgLSBpbm5lckJpdE9mZnNldCkgJiBiaXRNYXNrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5uZXJCaXRPZmZzZXQgKyBiaXRzUGVyU2FtcGxlIDw9IDI0KSB7XG4gICAgICAgICAgICBjb25zdCByYXcgPSAodmlldy5nZXRVaW50MTYoYnl0ZU9mZnNldCkgPDwgOCkgfCAodmlldy5nZXRVaW50OChieXRlT2Zmc2V0ICsgMikpO1xuICAgICAgICAgICAgb3V0QXJyYXlbb3V0SW5kZXhdID0gKHJhdyA+PiAoMjQgLSBiaXRzUGVyU2FtcGxlKSAtIGlubmVyQml0T2Zmc2V0KSAmIGJpdE1hc2s7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dEFycmF5W291dEluZGV4XSA9ICh2aWV3LmdldFVpbnQzMihieXRlT2Zmc2V0KSA+PiAoMzIgLSBiaXRzUGVyU2FtcGxlKSAtIGlubmVyQml0T2Zmc2V0KSAmIGJpdE1hc2s7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbGV0IG91dFdvcmQgPSAwO1xuICAgICAgICAgIC8vIGZvciAobGV0IGJpdCA9IDA7IGJpdCA8IGJpdHNQZXJTYW1wbGU7ICsrYml0KSB7XG4gICAgICAgICAgLy8gICBpZiAoaW5CeXRlQXJyYXlbYml0T2Zmc2V0ID4+IDNdXG4gICAgICAgICAgLy8gICAgICYgKDB4ODAgPj4gKGJpdE9mZnNldCAmIDcpKSkge1xuICAgICAgICAgIC8vICAgICBvdXRXb3JkIHw9ICgxIDw8IChiaXRzUGVyU2FtcGxlIC0gMSAtIGJpdCkpO1xuICAgICAgICAgIC8vICAgfVxuICAgICAgICAgIC8vICAgKytiaXRPZmZzZXQ7XG4gICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgLy8gb3V0QXJyYXlbb3V0SW5kZXhdID0gb3V0V29yZDtcbiAgICAgICAgICAvLyBvdXRBcnJheVtwaXhlbF0gPSBvdXRXb3JkO1xuICAgICAgICAgIC8vIHBpeGVsICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYml0T2Zmc2V0ID0gYml0T2Zmc2V0ICsgcGl4ZWxCaXRTa2lwIC0gYml0c1BlclNhbXBsZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAzKSB7IC8vIGZsb2F0aW5nIHBvaW50XG4gICAgLy8gRmxvYXQxNiBpcyBoYW5kbGVkIGVsc2V3aGVyZVxuICAgIC8vIG5vcm1hbGl6ZSAxNi8yNCBiaXQgZmxvYXRzIHRvIDMyIGJpdCBmbG9hdHMgaW4gdGhlIGFycmF5XG4gICAgLy8gY29uc29sZS50aW1lKCk7XG4gICAgLy8gaWYgKGJpdHNQZXJTYW1wbGUgPT09IDE2KSB7XG4gICAgLy8gICBmb3IgKGxldCBieXRlID0gMCwgb3V0SW5kZXggPSAwOyBieXRlIDwgaW5CdWZmZXIuYnl0ZUxlbmd0aDsgYnl0ZSArPSAyLCArK291dEluZGV4KSB7XG4gICAgLy8gICAgIG91dEFycmF5W291dEluZGV4XSA9IGdldEZsb2F0MTYodmlldywgYnl0ZSk7XG4gICAgLy8gICB9XG4gICAgLy8gfVxuICAgIC8vIGNvbnNvbGUudGltZUVuZCgpXG4gIH1cblxuICByZXR1cm4gb3V0QXJyYXkuYnVmZmVyO1xufVxuXG4vKipcbiAqIEdlb1RJRkYgc3ViLWZpbGUgaW1hZ2UuXG4gKi9cbmNsYXNzIEdlb1RJRkZJbWFnZSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IGZpbGVEaXJlY3RvcnkgVGhlIHBhcnNlZCBmaWxlIGRpcmVjdG9yeVxuICAgKiBAcGFyYW0ge09iamVjdH0gZ2VvS2V5cyBUaGUgcGFyc2VkIGdlby1rZXlzXG4gICAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGFWaWV3IFRoZSBEYXRhVmlldyBmb3IgdGhlIHVuZGVybHlpbmcgZmlsZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBsaXR0bGVFbmRpYW4gV2hldGhlciB0aGUgZmlsZSBpcyBlbmNvZGVkIGluIGxpdHRsZSBvciBiaWcgZW5kaWFuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FjaGUgV2hldGhlciBvciBub3QgZGVjb2RlZCB0aWxlcyBzaGFsbCBiZSBjYWNoZWRcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vc291cmNlL2Jhc2Vzb3VyY2UnKS5CYXNlU291cmNlfSBzb3VyY2UgVGhlIGRhdGFzb3VyY2UgdG8gcmVhZCBmcm9tXG4gICAqL1xuICBjb25zdHJ1Y3RvcihmaWxlRGlyZWN0b3J5LCBnZW9LZXlzLCBkYXRhVmlldywgbGl0dGxlRW5kaWFuLCBjYWNoZSwgc291cmNlKSB7XG4gICAgdGhpcy5maWxlRGlyZWN0b3J5ID0gZmlsZURpcmVjdG9yeTtcbiAgICB0aGlzLmdlb0tleXMgPSBnZW9LZXlzO1xuICAgIHRoaXMuZGF0YVZpZXcgPSBkYXRhVmlldztcbiAgICB0aGlzLmxpdHRsZUVuZGlhbiA9IGxpdHRsZUVuZGlhbjtcbiAgICB0aGlzLnRpbGVzID0gY2FjaGUgPyB7fSA6IG51bGw7XG4gICAgdGhpcy5pc1RpbGVkID0gIWZpbGVEaXJlY3RvcnkuU3RyaXBPZmZzZXRzO1xuICAgIGNvbnN0IHBsYW5hckNvbmZpZ3VyYXRpb24gPSBmaWxlRGlyZWN0b3J5LlBsYW5hckNvbmZpZ3VyYXRpb247XG4gICAgdGhpcy5wbGFuYXJDb25maWd1cmF0aW9uID0gKHR5cGVvZiBwbGFuYXJDb25maWd1cmF0aW9uID09PSAndW5kZWZpbmVkJykgPyAxIDogcGxhbmFyQ29uZmlndXJhdGlvbjtcbiAgICBpZiAodGhpcy5wbGFuYXJDb25maWd1cmF0aW9uICE9PSAxICYmIHRoaXMucGxhbmFyQ29uZmlndXJhdGlvbiAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBsYW5hciBjb25maWd1cmF0aW9uLicpO1xuICAgIH1cblxuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFzc29jaWF0ZWQgcGFyc2VkIGZpbGUgZGlyZWN0b3J5LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgcGFyc2VkIGZpbGUgZGlyZWN0b3J5XG4gICAqL1xuICBnZXRGaWxlRGlyZWN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLmZpbGVEaXJlY3Rvcnk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXNzb2NpYXRlZCBwYXJzZWQgZ2VvIGtleXMuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBwYXJzZWQgZ2VvIGtleXNcbiAgICovXG4gIGdldEdlb0tleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvS2V5cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgaW1hZ2UuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSB3aWR0aCBvZiB0aGUgaW1hZ2VcbiAgICovXG4gIGdldFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmZpbGVEaXJlY3RvcnkuSW1hZ2VXaWR0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIGltYWdlLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgaGVpZ2h0IG9mIHRoZSBpbWFnZVxuICAgKi9cbiAgZ2V0SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbGVEaXJlY3RvcnkuSW1hZ2VMZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHNhbXBsZXMgcGVyIHBpeGVsLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgbnVtYmVyIG9mIHNhbXBsZXMgcGVyIHBpeGVsXG4gICAqL1xuICBnZXRTYW1wbGVzUGVyUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLmZpbGVEaXJlY3RvcnkuU2FtcGxlc1BlclBpeGVsICE9PSAndW5kZWZpbmVkJ1xuICAgICAgPyB0aGlzLmZpbGVEaXJlY3RvcnkuU2FtcGxlc1BlclBpeGVsIDogMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiBlYWNoIHRpbGUuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSB3aWR0aCBvZiBlYWNoIHRpbGVcbiAgICovXG4gIGdldFRpbGVXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1RpbGVkID8gdGhpcy5maWxlRGlyZWN0b3J5LlRpbGVXaWR0aCA6IHRoaXMuZ2V0V2lkdGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgZWFjaCB0aWxlLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgaGVpZ2h0IG9mIGVhY2ggdGlsZVxuICAgKi9cbiAgZ2V0VGlsZUhlaWdodCgpIHtcbiAgICBpZiAodGhpcy5pc1RpbGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWxlRGlyZWN0b3J5LlRpbGVMZW5ndGg7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5maWxlRGlyZWN0b3J5LlJvd3NQZXJTdHJpcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmZpbGVEaXJlY3RvcnkuUm93c1BlclN0cmlwLCB0aGlzLmdldEhlaWdodCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0SGVpZ2h0KCk7XG4gIH1cblxuICBnZXRCbG9ja1dpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmdldFRpbGVXaWR0aCgpO1xuICB9XG5cbiAgZ2V0QmxvY2tIZWlnaHQoeSkge1xuICAgIGlmICh0aGlzLmlzVGlsZWQgfHwgKHkgKyAxKSAqIHRoaXMuZ2V0VGlsZUhlaWdodCgpIDw9IHRoaXMuZ2V0SGVpZ2h0KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRpbGVIZWlnaHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SGVpZ2h0KCkgLSAoeSAqIHRoaXMuZ2V0VGlsZUhlaWdodCgpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGZvciBlYWNoIHBpeGVsIGFjcm9zcyBhbGwgc2FtcGxlcy4gT25seSBmdWxsXG4gICAqIGJ5dGVzIGFyZSBzdXBwb3J0ZWQsIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gd2hlbiB0aGlzIGlzIG5vdCB0aGUgY2FzZS5cbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIGJ5dGVzIHBlciBwaXhlbFxuICAgKi9cbiAgZ2V0Qnl0ZXNQZXJQaXhlbCgpIHtcbiAgICBsZXQgYnl0ZXMgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzICs9IHRoaXMuZ2V0U2FtcGxlQnl0ZVNpemUoaSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbiAgfVxuXG4gIGdldFNhbXBsZUJ5dGVTaXplKGkpIHtcbiAgICBpZiAoaSA+PSB0aGlzLmZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBTYW1wbGUgaW5kZXggJHtpfSBpcyBvdXQgb2YgcmFuZ2UuYCk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5maWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGVbaV0gLyA4KTtcbiAgfVxuXG4gIGdldFJlYWRlckZvclNhbXBsZShzYW1wbGVJbmRleCkge1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZmlsZURpcmVjdG9yeS5TYW1wbGVGb3JtYXRcbiAgICAgID8gdGhpcy5maWxlRGlyZWN0b3J5LlNhbXBsZUZvcm1hdFtzYW1wbGVJbmRleF0gOiAxO1xuICAgIGNvbnN0IGJpdHNQZXJTYW1wbGUgPSB0aGlzLmZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZVtzYW1wbGVJbmRleF07XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgIGNhc2UgMTogLy8gdW5zaWduZWQgaW50ZWdlciBkYXRhXG4gICAgICAgIGlmIChiaXRzUGVyU2FtcGxlIDw9IDgpIHtcbiAgICAgICAgICByZXR1cm4gRGF0YVZpZXcucHJvdG90eXBlLmdldFVpbnQ4O1xuICAgICAgICB9IGVsc2UgaWYgKGJpdHNQZXJTYW1wbGUgPD0gMTYpIHtcbiAgICAgICAgICByZXR1cm4gRGF0YVZpZXcucHJvdG90eXBlLmdldFVpbnQxNjtcbiAgICAgICAgfSBlbHNlIGlmIChiaXRzUGVyU2FtcGxlIDw9IDMyKSB7XG4gICAgICAgICAgcmV0dXJuIERhdGFWaWV3LnByb3RvdHlwZS5nZXRVaW50MzI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6IC8vIHR3b3MgY29tcGxlbWVudCBzaWduZWQgaW50ZWdlciBkYXRhXG4gICAgICAgIGlmIChiaXRzUGVyU2FtcGxlIDw9IDgpIHtcbiAgICAgICAgICByZXR1cm4gRGF0YVZpZXcucHJvdG90eXBlLmdldEludDg7XG4gICAgICAgIH0gZWxzZSBpZiAoYml0c1BlclNhbXBsZSA8PSAxNikge1xuICAgICAgICAgIHJldHVybiBEYXRhVmlldy5wcm90b3R5cGUuZ2V0SW50MTY7XG4gICAgICAgIH0gZWxzZSBpZiAoYml0c1BlclNhbXBsZSA8PSAzMikge1xuICAgICAgICAgIHJldHVybiBEYXRhVmlldy5wcm90b3R5cGUuZ2V0SW50MzI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHN3aXRjaCAoYml0c1BlclNhbXBsZSkge1xuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRGbG9hdDE2KHRoaXMsIG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgIHJldHVybiBEYXRhVmlldy5wcm90b3R5cGUuZ2V0RmxvYXQzMjtcbiAgICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgICAgcmV0dXJuIERhdGFWaWV3LnByb3RvdHlwZS5nZXRGbG9hdDY0O1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcignVW5zdXBwb3J0ZWQgZGF0YSBmb3JtYXQvYml0c1BlclNhbXBsZScpO1xuICB9XG5cbiAgZ2V0U2FtcGxlRm9ybWF0KHNhbXBsZUluZGV4ID0gMCkge1xuICAgIHJldHVybiB0aGlzLmZpbGVEaXJlY3RvcnkuU2FtcGxlRm9ybWF0XG4gICAgICA/IHRoaXMuZmlsZURpcmVjdG9yeS5TYW1wbGVGb3JtYXRbc2FtcGxlSW5kZXhdIDogMTtcbiAgfVxuXG4gIGdldEJpdHNQZXJTYW1wbGUoc2FtcGxlSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlW3NhbXBsZUluZGV4XTtcbiAgfVxuXG4gIGdldEFycmF5Rm9yU2FtcGxlKHNhbXBsZUluZGV4LCBzaXplKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5nZXRTYW1wbGVGb3JtYXQoc2FtcGxlSW5kZXgpO1xuICAgIGNvbnN0IGJpdHNQZXJTYW1wbGUgPSB0aGlzLmdldEJpdHNQZXJTYW1wbGUoc2FtcGxlSW5kZXgpO1xuICAgIHJldHVybiBhcnJheUZvclR5cGUoZm9ybWF0LCBiaXRzUGVyU2FtcGxlLCBzaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZWNvZGVkIHN0cmlwIG9yIHRpbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4IHRoZSBzdHJpcCBvciB0aWxlIHgtb2Zmc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5IHRoZSB0aWxlIHktb2Zmc2V0ICgwIGZvciBzdHJpcHBlZCBpbWFnZXMpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzYW1wbGUgdGhlIHNhbXBsZSB0byBnZXQgZm9yIHNlcGFyYXRlZCBzYW1wbGVzXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW90aWZmXCIpLlBvb2x8aW1wb3J0KFwiLi9nZW90aWZmXCIpLkJhc2VEZWNvZGVyfSBwb29sT3JEZWNvZGVyIHRoZSBkZWNvZGVyIG9yIGRlY29kZXIgcG9vbFxuICAgKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBbc2lnbmFsXSBBbiBBYm9ydFNpZ25hbCB0aGF0IG1heSBiZSBzaWduYWxsZWQgaWYgdGhlIHJlcXVlc3QgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48QXJyYXlCdWZmZXI+fVxuICAgKi9cbiAgYXN5bmMgZ2V0VGlsZU9yU3RyaXAoeCwgeSwgc2FtcGxlLCBwb29sT3JEZWNvZGVyLCBzaWduYWwpIHtcbiAgICBjb25zdCBudW1UaWxlc1BlclJvdyA9IE1hdGguY2VpbCh0aGlzLmdldFdpZHRoKCkgLyB0aGlzLmdldFRpbGVXaWR0aCgpKTtcbiAgICBjb25zdCBudW1UaWxlc1BlckNvbCA9IE1hdGguY2VpbCh0aGlzLmdldEhlaWdodCgpIC8gdGhpcy5nZXRUaWxlSGVpZ2h0KCkpO1xuICAgIGxldCBpbmRleDtcbiAgICBjb25zdCB7IHRpbGVzIH0gPSB0aGlzO1xuICAgIGlmICh0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDEpIHtcbiAgICAgIGluZGV4ID0gKHkgKiBudW1UaWxlc1BlclJvdykgKyB4O1xuICAgIH0gZWxzZSBpZiAodGhpcy5wbGFuYXJDb25maWd1cmF0aW9uID09PSAyKSB7XG4gICAgICBpbmRleCA9IChzYW1wbGUgKiBudW1UaWxlc1BlclJvdyAqIG51bVRpbGVzUGVyQ29sKSArICh5ICogbnVtVGlsZXNQZXJSb3cpICsgeDtcbiAgICB9XG5cbiAgICBsZXQgb2Zmc2V0O1xuICAgIGxldCBieXRlQ291bnQ7XG4gICAgaWYgKHRoaXMuaXNUaWxlZCkge1xuICAgICAgb2Zmc2V0ID0gdGhpcy5maWxlRGlyZWN0b3J5LlRpbGVPZmZzZXRzW2luZGV4XTtcbiAgICAgIGJ5dGVDb3VudCA9IHRoaXMuZmlsZURpcmVjdG9yeS5UaWxlQnl0ZUNvdW50c1tpbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCA9IHRoaXMuZmlsZURpcmVjdG9yeS5TdHJpcE9mZnNldHNbaW5kZXhdO1xuICAgICAgYnl0ZUNvdW50ID0gdGhpcy5maWxlRGlyZWN0b3J5LlN0cmlwQnl0ZUNvdW50c1tpbmRleF07XG4gICAgfVxuICAgIGNvbnN0IHNsaWNlID0gKGF3YWl0IHRoaXMuc291cmNlLmZldGNoKFt7IG9mZnNldCwgbGVuZ3RoOiBieXRlQ291bnQgfV0sIHNpZ25hbCkpWzBdO1xuXG4gICAgbGV0IHJlcXVlc3Q7XG4gICAgaWYgKHRpbGVzID09PSBudWxsIHx8ICF0aWxlc1tpbmRleF0pIHtcbiAgICAvLyByZXNvbHZlIGVhY2ggcmVxdWVzdCBieSBwb3RlbnRpYWxseSBhcHBseWluZyBhcnJheSBub3JtYWxpemF0aW9uXG4gICAgICByZXF1ZXN0ID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgbGV0IGRhdGEgPSBhd2FpdCBwb29sT3JEZWNvZGVyLmRlY29kZSh0aGlzLmZpbGVEaXJlY3RvcnksIHNsaWNlKTtcbiAgICAgICAgY29uc3Qgc2FtcGxlRm9ybWF0ID0gdGhpcy5nZXRTYW1wbGVGb3JtYXQoKTtcbiAgICAgICAgY29uc3QgYml0c1BlclNhbXBsZSA9IHRoaXMuZ2V0Qml0c1BlclNhbXBsZSgpO1xuICAgICAgICBpZiAobmVlZHNOb3JtYWxpemF0aW9uKHNhbXBsZUZvcm1hdCwgYml0c1BlclNhbXBsZSkpIHtcbiAgICAgICAgICBkYXRhID0gbm9ybWFsaXplQXJyYXkoXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgc2FtcGxlRm9ybWF0LFxuICAgICAgICAgICAgdGhpcy5wbGFuYXJDb25maWd1cmF0aW9uLFxuICAgICAgICAgICAgdGhpcy5nZXRTYW1wbGVzUGVyUGl4ZWwoKSxcbiAgICAgICAgICAgIGJpdHNQZXJTYW1wbGUsXG4gICAgICAgICAgICB0aGlzLmdldFRpbGVXaWR0aCgpLFxuICAgICAgICAgICAgdGhpcy5nZXRCbG9ja0hlaWdodCh5KSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfSkoKTtcblxuICAgICAgLy8gc2V0IHRoZSBjYWNoZVxuICAgICAgaWYgKHRpbGVzICE9PSBudWxsKSB7XG4gICAgICAgIHRpbGVzW2luZGV4XSA9IHJlcXVlc3Q7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGdldCBmcm9tIHRoZSBjYWNoZVxuICAgICAgcmVxdWVzdCA9IHRpbGVzW2luZGV4XTtcbiAgICB9XG5cbiAgICAvLyBjYWNoZSB0aGUgdGlsZSByZXF1ZXN0XG4gICAgcmV0dXJuIHsgeCwgeSwgc2FtcGxlLCBkYXRhOiBhd2FpdCByZXF1ZXN0IH07XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWwgcmVhZCBmdW5jdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gaW1hZ2VXaW5kb3cgVGhlIGltYWdlIHdpbmRvdyBpbiBwaXhlbCBjb29yZGluYXRlc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzYW1wbGVzIFRoZSBzZWxlY3RlZCBzYW1wbGVzICgwLWJhc2VkIGluZGljZXMpXG4gICAqIEBwYXJhbSB7VHlwZWRBcnJheXxUeXBlZEFycmF5W119IHZhbHVlQXJyYXlzIFRoZSBhcnJheShzKSB0byB3cml0ZSBpbnRvXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW50ZXJsZWF2ZSBXaGV0aGVyIG9yIG5vdCB0byB3cml0ZSBpbiBhbiBpbnRlcmxlYXZlZCBtYW5uZXJcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2dlb3RpZmZcIikuUG9vbHxBYnN0cmFjdERlY29kZXJ9IHBvb2xPckRlY29kZXIgdGhlIGRlY29kZXIgb3IgZGVjb2RlciBwb29sXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCB0aGUgd2lkdGggb2Ygd2luZG93IHRvIGJlIHJlYWQgaW50b1xuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IHRoZSBoZWlnaHQgb2Ygd2luZG93IHRvIGJlIHJlYWQgaW50b1xuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzYW1wbGVNZXRob2QgdGhlIHJlc2FtcGxpbmcgbWV0aG9kIHRvIGJlIHVzZWQgd2hlbiBpbnRlcnBvbGF0aW5nXG4gICAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFJlYWRSYXN0ZXJSZXN1bHQ+fVxuICAgKi9cbiAgYXN5bmMgX3JlYWRSYXN0ZXIoaW1hZ2VXaW5kb3csIHNhbXBsZXMsIHZhbHVlQXJyYXlzLCBpbnRlcmxlYXZlLCBwb29sT3JEZWNvZGVyLCB3aWR0aCxcbiAgICBoZWlnaHQsIHJlc2FtcGxlTWV0aG9kLCBzaWduYWwpIHtcbiAgICBjb25zdCB0aWxlV2lkdGggPSB0aGlzLmdldFRpbGVXaWR0aCgpO1xuICAgIGNvbnN0IHRpbGVIZWlnaHQgPSB0aGlzLmdldFRpbGVIZWlnaHQoKTtcbiAgICBjb25zdCBpbWFnZVdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgIGNvbnN0IGltYWdlSGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcblxuICAgIGNvbnN0IG1pblhUaWxlID0gTWF0aC5tYXgoTWF0aC5mbG9vcihpbWFnZVdpbmRvd1swXSAvIHRpbGVXaWR0aCksIDApO1xuICAgIGNvbnN0IG1heFhUaWxlID0gTWF0aC5taW4oXG4gICAgICBNYXRoLmNlaWwoaW1hZ2VXaW5kb3dbMl0gLyB0aWxlV2lkdGgpLFxuICAgICAgTWF0aC5jZWlsKGltYWdlV2lkdGggLyB0aWxlV2lkdGgpLFxuICAgICk7XG4gICAgY29uc3QgbWluWVRpbGUgPSBNYXRoLm1heChNYXRoLmZsb29yKGltYWdlV2luZG93WzFdIC8gdGlsZUhlaWdodCksIDApO1xuICAgIGNvbnN0IG1heFlUaWxlID0gTWF0aC5taW4oXG4gICAgICBNYXRoLmNlaWwoaW1hZ2VXaW5kb3dbM10gLyB0aWxlSGVpZ2h0KSxcbiAgICAgIE1hdGguY2VpbChpbWFnZUhlaWdodCAvIHRpbGVIZWlnaHQpLFxuICAgICk7XG4gICAgY29uc3Qgd2luZG93V2lkdGggPSBpbWFnZVdpbmRvd1syXSAtIGltYWdlV2luZG93WzBdO1xuXG4gICAgbGV0IGJ5dGVzUGVyUGl4ZWwgPSB0aGlzLmdldEJ5dGVzUGVyUGl4ZWwoKTtcblxuICAgIGNvbnN0IHNyY1NhbXBsZU9mZnNldHMgPSBbXTtcbiAgICBjb25zdCBzYW1wbGVSZWFkZXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAodGhpcy5wbGFuYXJDb25maWd1cmF0aW9uID09PSAxKSB7XG4gICAgICAgIHNyY1NhbXBsZU9mZnNldHMucHVzaChzdW0odGhpcy5maWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGUsIDAsIHNhbXBsZXNbaV0pIC8gOCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcmNTYW1wbGVPZmZzZXRzLnB1c2goMCk7XG4gICAgICB9XG4gICAgICBzYW1wbGVSZWFkZXJzLnB1c2godGhpcy5nZXRSZWFkZXJGb3JTYW1wbGUoc2FtcGxlc1tpXSkpO1xuICAgIH1cblxuICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgY29uc3QgeyBsaXR0bGVFbmRpYW4gfSA9IHRoaXM7XG5cbiAgICBmb3IgKGxldCB5VGlsZSA9IG1pbllUaWxlOyB5VGlsZSA8IG1heFlUaWxlOyArK3lUaWxlKSB7XG4gICAgICBmb3IgKGxldCB4VGlsZSA9IG1pblhUaWxlOyB4VGlsZSA8IG1heFhUaWxlOyArK3hUaWxlKSB7XG4gICAgICAgIGxldCBnZXRQcm9taXNlO1xuICAgICAgICBpZiAodGhpcy5wbGFuYXJDb25maWd1cmF0aW9uID09PSAxKSB7XG4gICAgICAgICAgZ2V0UHJvbWlzZSA9IHRoaXMuZ2V0VGlsZU9yU3RyaXAoeFRpbGUsIHlUaWxlLCAwLCBwb29sT3JEZWNvZGVyLCBzaWduYWwpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHNhbXBsZUluZGV4ID0gMDsgc2FtcGxlSW5kZXggPCBzYW1wbGVzLmxlbmd0aDsgKytzYW1wbGVJbmRleCkge1xuICAgICAgICAgIGNvbnN0IHNpID0gc2FtcGxlSW5kZXg7XG4gICAgICAgICAgY29uc3Qgc2FtcGxlID0gc2FtcGxlc1tzYW1wbGVJbmRleF07XG4gICAgICAgICAgaWYgKHRoaXMucGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMikge1xuICAgICAgICAgICAgYnl0ZXNQZXJQaXhlbCA9IHRoaXMuZ2V0U2FtcGxlQnl0ZVNpemUoc2FtcGxlKTtcbiAgICAgICAgICAgIGdldFByb21pc2UgPSB0aGlzLmdldFRpbGVPclN0cmlwKHhUaWxlLCB5VGlsZSwgc2FtcGxlLCBwb29sT3JEZWNvZGVyLCBzaWduYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwcm9taXNlID0gZ2V0UHJvbWlzZS50aGVuKCh0aWxlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSB0aWxlLmRhdGE7XG4gICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tIZWlnaHQgPSB0aGlzLmdldEJsb2NrSGVpZ2h0KHRpbGUueSk7XG4gICAgICAgICAgICBjb25zdCBmaXJzdExpbmUgPSB0aWxlLnkgKiB0aWxlSGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgZmlyc3RDb2wgPSB0aWxlLnggKiB0aWxlV2lkdGg7XG4gICAgICAgICAgICBjb25zdCBsYXN0TGluZSA9IGZpcnN0TGluZSArIGJsb2NrSGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgbGFzdENvbCA9ICh0aWxlLnggKyAxKSAqIHRpbGVXaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHNhbXBsZVJlYWRlcnNbc2ldO1xuXG4gICAgICAgICAgICBjb25zdCB5bWF4ID0gTWF0aC5taW4oYmxvY2tIZWlnaHQsIGJsb2NrSGVpZ2h0IC0gKGxhc3RMaW5lIC0gaW1hZ2VXaW5kb3dbM10pLCBpbWFnZUhlaWdodCAtIGZpcnN0TGluZSk7XG4gICAgICAgICAgICBjb25zdCB4bWF4ID0gTWF0aC5taW4odGlsZVdpZHRoLCB0aWxlV2lkdGggLSAobGFzdENvbCAtIGltYWdlV2luZG93WzJdKSwgaW1hZ2VXaWR0aCAtIGZpcnN0Q29sKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IE1hdGgubWF4KDAsIGltYWdlV2luZG93WzFdIC0gZmlyc3RMaW5lKTsgeSA8IHltYXg7ICsreSkge1xuICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gTWF0aC5tYXgoMCwgaW1hZ2VXaW5kb3dbMF0gLSBmaXJzdENvbCk7IHggPCB4bWF4OyArK3gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwaXhlbE9mZnNldCA9ICgoeSAqIHRpbGVXaWR0aCkgKyB4KSAqIGJ5dGVzUGVyUGl4ZWw7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZWFkZXIuY2FsbChcbiAgICAgICAgICAgICAgICAgIGRhdGFWaWV3LCBwaXhlbE9mZnNldCArIHNyY1NhbXBsZU9mZnNldHNbc2ldLCBsaXR0bGVFbmRpYW4sXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBsZXQgd2luZG93Q29vcmRpbmF0ZTtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJsZWF2ZSkge1xuICAgICAgICAgICAgICAgICAgd2luZG93Q29vcmRpbmF0ZSA9ICgoeSArIGZpcnN0TGluZSAtIGltYWdlV2luZG93WzFdKSAqIHdpbmRvd1dpZHRoICogc2FtcGxlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICsgKCh4ICsgZmlyc3RDb2wgLSBpbWFnZVdpbmRvd1swXSkgKiBzYW1wbGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgKyBzaTtcbiAgICAgICAgICAgICAgICAgIHZhbHVlQXJyYXlzW3dpbmRvd0Nvb3JkaW5hdGVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHdpbmRvd0Nvb3JkaW5hdGUgPSAoXG4gICAgICAgICAgICAgICAgICAgICh5ICsgZmlyc3RMaW5lIC0gaW1hZ2VXaW5kb3dbMV0pICogd2luZG93V2lkdGhcbiAgICAgICAgICAgICAgICAgICkgKyB4ICsgZmlyc3RDb2wgLSBpbWFnZVdpbmRvd1swXTtcbiAgICAgICAgICAgICAgICAgIHZhbHVlQXJyYXlzW3NpXVt3aW5kb3dDb29yZGluYXRlXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgaWYgKCh3aWR0aCAmJiAoaW1hZ2VXaW5kb3dbMl0gLSBpbWFnZVdpbmRvd1swXSkgIT09IHdpZHRoKVxuICAgICAgICB8fCAoaGVpZ2h0ICYmIChpbWFnZVdpbmRvd1szXSAtIGltYWdlV2luZG93WzFdKSAhPT0gaGVpZ2h0KSkge1xuICAgICAgbGV0IHJlc2FtcGxlZDtcbiAgICAgIGlmIChpbnRlcmxlYXZlKSB7XG4gICAgICAgIHJlc2FtcGxlZCA9IHJlc2FtcGxlSW50ZXJsZWF2ZWQoXG4gICAgICAgICAgdmFsdWVBcnJheXMsXG4gICAgICAgICAgaW1hZ2VXaW5kb3dbMl0gLSBpbWFnZVdpbmRvd1swXSxcbiAgICAgICAgICBpbWFnZVdpbmRvd1szXSAtIGltYWdlV2luZG93WzFdLFxuICAgICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgc2FtcGxlcy5sZW5ndGgsXG4gICAgICAgICAgcmVzYW1wbGVNZXRob2QsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNhbXBsZWQgPSByZXNhbXBsZShcbiAgICAgICAgICB2YWx1ZUFycmF5cyxcbiAgICAgICAgICBpbWFnZVdpbmRvd1syXSAtIGltYWdlV2luZG93WzBdLFxuICAgICAgICAgIGltYWdlV2luZG93WzNdIC0gaW1hZ2VXaW5kb3dbMV0sXG4gICAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgICByZXNhbXBsZU1ldGhvZCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJlc2FtcGxlZC53aWR0aCA9IHdpZHRoO1xuICAgICAgcmVzYW1wbGVkLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHJldHVybiByZXNhbXBsZWQ7XG4gICAgfVxuXG4gICAgdmFsdWVBcnJheXMud2lkdGggPSB3aWR0aCB8fCBpbWFnZVdpbmRvd1syXSAtIGltYWdlV2luZG93WzBdO1xuICAgIHZhbHVlQXJyYXlzLmhlaWdodCA9IGhlaWdodCB8fCBpbWFnZVdpbmRvd1szXSAtIGltYWdlV2luZG93WzFdO1xuXG4gICAgcmV0dXJuIHZhbHVlQXJyYXlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHJhc3RlciBkYXRhIGZyb20gdGhlIGltYWdlLiBUaGlzIGZ1bmN0aW9uIHJlYWRzIGFsbCBzZWxlY3RlZCBzYW1wbGVzXG4gICAqIGludG8gc2VwYXJhdGUgYXJyYXlzIG9mIHRoZSBjb3JyZWN0IHR5cGUgZm9yIHRoYXQgc2FtcGxlIG9yIGludG8gYSBzaW5nbGVcbiAgICogY29tYmluZWQgYXJyYXkgd2hlbiBgaW50ZXJsZWF2ZWAgaXMgc2V0LiBXaGVuIHByb3ZpZGVkLCBvbmx5IGEgc3Vic2V0XG4gICAqIG9mIHRoZSByYXN0ZXIgaXMgcmVhZCBmb3IgZWFjaCBzYW1wbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhZFJhc3Rlck9wdGlvbnN9IFtvcHRpb25zPXt9XSBvcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFJlYWRSYXN0ZXJSZXN1bHQ+fSB0aGUgZGVjb2RlZCBhcnJheXMgYXMgYSBwcm9taXNlXG4gICAqL1xuICBhc3luYyByZWFkUmFzdGVycyh7XG4gICAgd2luZG93OiB3bmQsIHNhbXBsZXMgPSBbXSwgaW50ZXJsZWF2ZSwgcG9vbCA9IG51bGwsXG4gICAgd2lkdGgsIGhlaWdodCwgcmVzYW1wbGVNZXRob2QsIGZpbGxWYWx1ZSwgc2lnbmFsLFxuICB9ID0ge30pIHtcbiAgICBjb25zdCBpbWFnZVdpbmRvdyA9IHduZCB8fCBbMCwgMCwgdGhpcy5nZXRXaWR0aCgpLCB0aGlzLmdldEhlaWdodCgpXTtcblxuICAgIC8vIGNoZWNrIHBhcmFtZXRlcnNcbiAgICBpZiAoaW1hZ2VXaW5kb3dbMF0gPiBpbWFnZVdpbmRvd1syXSB8fCBpbWFnZVdpbmRvd1sxXSA+IGltYWdlV2luZG93WzNdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3Vic2V0cycpO1xuICAgIH1cblxuICAgIGNvbnN0IGltYWdlV2luZG93V2lkdGggPSBpbWFnZVdpbmRvd1syXSAtIGltYWdlV2luZG93WzBdO1xuICAgIGNvbnN0IGltYWdlV2luZG93SGVpZ2h0ID0gaW1hZ2VXaW5kb3dbM10gLSBpbWFnZVdpbmRvd1sxXTtcbiAgICBjb25zdCBudW1QaXhlbHMgPSBpbWFnZVdpbmRvd1dpZHRoICogaW1hZ2VXaW5kb3dIZWlnaHQ7XG4gICAgY29uc3Qgc2FtcGxlc1BlclBpeGVsID0gdGhpcy5nZXRTYW1wbGVzUGVyUGl4ZWwoKTtcblxuICAgIGlmICghc2FtcGxlcyB8fCAhc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlc1BlclBpeGVsOyArK2kpIHtcbiAgICAgICAgc2FtcGxlcy5wdXNoKGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHNhbXBsZXNbaV0gPj0gc2FtcGxlc1BlclBpeGVsKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIHNhbXBsZSBpbmRleCAnJHtzYW1wbGVzW2ldfScuYCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB2YWx1ZUFycmF5cztcbiAgICBpZiAoaW50ZXJsZWF2ZSkge1xuICAgICAgY29uc3QgZm9ybWF0ID0gdGhpcy5maWxlRGlyZWN0b3J5LlNhbXBsZUZvcm1hdFxuICAgICAgICA/IE1hdGgubWF4LmFwcGx5KG51bGwsIHRoaXMuZmlsZURpcmVjdG9yeS5TYW1wbGVGb3JtYXQpIDogMTtcbiAgICAgIGNvbnN0IGJpdHNQZXJTYW1wbGUgPSBNYXRoLm1heC5hcHBseShudWxsLCB0aGlzLmZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZSk7XG4gICAgICB2YWx1ZUFycmF5cyA9IGFycmF5Rm9yVHlwZShmb3JtYXQsIGJpdHNQZXJTYW1wbGUsIG51bVBpeGVscyAqIHNhbXBsZXMubGVuZ3RoKTtcbiAgICAgIGlmIChmaWxsVmFsdWUpIHtcbiAgICAgICAgdmFsdWVBcnJheXMuZmlsbChmaWxsVmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZUFycmF5cyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlQXJyYXkgPSB0aGlzLmdldEFycmF5Rm9yU2FtcGxlKHNhbXBsZXNbaV0sIG51bVBpeGVscyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpbGxWYWx1ZSkgJiYgaSA8IGZpbGxWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YWx1ZUFycmF5LmZpbGwoZmlsbFZhbHVlW2ldKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxsVmFsdWUgJiYgIUFycmF5LmlzQXJyYXkoZmlsbFZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlQXJyYXkuZmlsbChmaWxsVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlQXJyYXlzLnB1c2godmFsdWVBcnJheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcG9vbE9yRGVjb2RlciA9IHBvb2wgfHwgYXdhaXQgZ2V0RGVjb2Rlcih0aGlzLmZpbGVEaXJlY3RvcnkpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fcmVhZFJhc3RlcihcbiAgICAgIGltYWdlV2luZG93LCBzYW1wbGVzLCB2YWx1ZUFycmF5cywgaW50ZXJsZWF2ZSwgcG9vbE9yRGVjb2Rlciwgd2lkdGgsIGhlaWdodCwgcmVzYW1wbGVNZXRob2QsIHNpZ25hbCxcbiAgICApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgcmFzdGVyIGRhdGEgZnJvbSB0aGUgaW1hZ2UgYXMgUkdCLiBUaGUgcmVzdWx0IGlzIGFsd2F5cyBhblxuICAgKiBpbnRlcmxlYXZlZCB0eXBlZCBhcnJheS5cbiAgICogQ29sb3JzcGFjZXMgb3RoZXIgdGhhbiBSR0Igd2lsbCBiZSB0cmFuc2Zvcm1lZCB0byBSR0IsIGNvbG9yIG1hcHMgZXhwYW5kZWQuXG4gICAqIFdoZW4gbm8gb3RoZXIgbWV0aG9kIGlzIGFwcGxpY2FibGUsIHRoZSBmaXJzdCBzYW1wbGUgaXMgdXNlZCB0byBwcm9kdWNlIGFcbiAgICogZ3JheXNjYWxlIGltYWdlLlxuICAgKiBXaGVuIHByb3ZpZGVkLCBvbmx5IGEgc3Vic2V0IG9mIHRoZSByYXN0ZXIgaXMgcmVhZCBmb3IgZWFjaCBzYW1wbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLndpbmRvd10gdGhlIHN1YnNldCB0byByZWFkIGRhdGEgZnJvbSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaW50ZXJsZWF2ZT10cnVlXSB3aGV0aGVyIHRoZSBkYXRhIHNoYWxsIGJlIHJlYWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBvbmUgc2luZ2xlIGFycmF5IG9yIHNlcGFyYXRlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vZ2VvdGlmZlwiKS5Qb29sfSBbb3B0aW9ucy5wb29sPW51bGxdIFRoZSBvcHRpb25hbCBkZWNvZGVyIHBvb2wgdG8gdXNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMud2lkdGhdIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBvdXRwdXQuIFdoZW4gdGhlIHdpZHRoIGlzIG5vIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbWUgYXMgdGhlIGltYWdlcywgcmVzYW1wbGluZyB3aWxsIGJlIHBlcmZvcm1lZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBvdXRwdXQuIFdoZW4gdGhlIHdpZHRoIGlzIG5vIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1lIGFzIHRoZSBpbWFnZXMsIHJlc2FtcGxpbmcgd2lsbCBiZSBwZXJmb3JtZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5yZXNhbXBsZU1ldGhvZD0nbmVhcmVzdCddIFRoZSBkZXNpcmVkIHJlc2FtcGxpbmcgbWV0aG9kLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZUFscGhhPWZhbHNlXSBFbmFibGUgcmVhZGluZyBhbHBoYSBjaGFubmVsIGlmIHByZXNlbnQuXG4gICAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtvcHRpb25zLnNpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWFkUmFzdGVyUmVzdWx0Pn0gdGhlIFJHQiBhcnJheSBhcyBhIFByb21pc2VcbiAgICovXG4gIGFzeW5jIHJlYWRSR0IoeyB3aW5kb3csIGludGVybGVhdmUgPSB0cnVlLCBwb29sID0gbnVsbCwgd2lkdGgsIGhlaWdodCxcbiAgICByZXNhbXBsZU1ldGhvZCwgZW5hYmxlQWxwaGEgPSBmYWxzZSwgc2lnbmFsIH0gPSB7fSkge1xuICAgIGNvbnN0IGltYWdlV2luZG93ID0gd2luZG93IHx8IFswLCAwLCB0aGlzLmdldFdpZHRoKCksIHRoaXMuZ2V0SGVpZ2h0KCldO1xuXG4gICAgLy8gY2hlY2sgcGFyYW1ldGVyc1xuICAgIGlmIChpbWFnZVdpbmRvd1swXSA+IGltYWdlV2luZG93WzJdIHx8IGltYWdlV2luZG93WzFdID4gaW1hZ2VXaW5kb3dbM10pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdWJzZXRzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcGkgPSB0aGlzLmZpbGVEaXJlY3RvcnkuUGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbjtcblxuICAgIGlmIChwaSA9PT0gcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuUkdCKSB7XG4gICAgICBsZXQgcyA9IFswLCAxLCAyXTtcbiAgICAgIGlmICgoISh0aGlzLmZpbGVEaXJlY3RvcnkuRXh0cmFTYW1wbGVzID09PSBFeHRyYVNhbXBsZXNWYWx1ZXMuVW5zcGVjaWZpZWQpKSAmJiBlbmFibGVBbHBoYSkge1xuICAgICAgICBzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlYWRSYXN0ZXJzKHtcbiAgICAgICAgd2luZG93LFxuICAgICAgICBpbnRlcmxlYXZlLFxuICAgICAgICBzYW1wbGVzOiBzLFxuICAgICAgICBwb29sLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICByZXNhbXBsZU1ldGhvZCxcbiAgICAgICAgc2lnbmFsLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGV0IHNhbXBsZXM7XG4gICAgc3dpdGNoIChwaSkge1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5XaGl0ZUlzWmVybzpcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuQmxhY2tJc1plcm86XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLlBhbGV0dGU6XG4gICAgICAgIHNhbXBsZXMgPSBbMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5DTVlLOlxuICAgICAgICBzYW1wbGVzID0gWzAsIDEsIDIsIDNdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuWUNiQ3I6XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLkNJRUxhYjpcbiAgICAgICAgc2FtcGxlcyA9IFswLCAxLCAyXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3IgdW5zdXBwb3J0ZWQgcGhvdG9tZXRyaWMgaW50ZXJwcmV0YXRpb24uJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3ViT3B0aW9ucyA9IHtcbiAgICAgIHdpbmRvdzogaW1hZ2VXaW5kb3csXG4gICAgICBpbnRlcmxlYXZlOiB0cnVlLFxuICAgICAgc2FtcGxlcyxcbiAgICAgIHBvb2wsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHJlc2FtcGxlTWV0aG9kLFxuICAgICAgc2lnbmFsLFxuICAgIH07XG4gICAgY29uc3QgeyBmaWxlRGlyZWN0b3J5IH0gPSB0aGlzO1xuICAgIGNvbnN0IHJhc3RlciA9IGF3YWl0IHRoaXMucmVhZFJhc3RlcnMoc3ViT3B0aW9ucyk7XG5cbiAgICBjb25zdCBtYXggPSAyICoqIHRoaXMuZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlWzBdO1xuICAgIGxldCBkYXRhO1xuICAgIHN3aXRjaCAocGkpIHtcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuV2hpdGVJc1plcm86XG4gICAgICAgIGRhdGEgPSBmcm9tV2hpdGVJc1plcm8ocmFzdGVyLCBtYXgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuQmxhY2tJc1plcm86XG4gICAgICAgIGRhdGEgPSBmcm9tQmxhY2tJc1plcm8ocmFzdGVyLCBtYXgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuUGFsZXR0ZTpcbiAgICAgICAgZGF0YSA9IGZyb21QYWxldHRlKHJhc3RlciwgZmlsZURpcmVjdG9yeS5Db2xvck1hcCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5DTVlLOlxuICAgICAgICBkYXRhID0gZnJvbUNNWUsocmFzdGVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLllDYkNyOlxuICAgICAgICBkYXRhID0gZnJvbVlDYkNyKHJhc3Rlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5DSUVMYWI6XG4gICAgICAgIGRhdGEgPSBmcm9tQ0lFTGFiKHJhc3Rlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwaG90b21ldHJpYyBpbnRlcnByZXRhdGlvbi4nKTtcbiAgICB9XG5cbiAgICAvLyBpZiBub24taW50ZXJsZWF2ZWQgZGF0YSBpcyByZXF1ZXN0ZWQsIHdlIG11c3Qgc3BsaXQgdGhlIGNoYW5uZWxzXG4gICAgLy8gaW50byB0aGVpciByZXNwZWN0aXZlIGFycmF5c1xuICAgIGlmICghaW50ZXJsZWF2ZSkge1xuICAgICAgY29uc3QgcmVkID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggLyAzKTtcbiAgICAgIGNvbnN0IGdyZWVuID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggLyAzKTtcbiAgICAgIGNvbnN0IGJsdWUgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCAvIDMpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gMywgKytqKSB7XG4gICAgICAgIHJlZFtqXSA9IGRhdGFbaV07XG4gICAgICAgIGdyZWVuW2pdID0gZGF0YVtpICsgMV07XG4gICAgICAgIGJsdWVbal0gPSBkYXRhW2kgKyAyXTtcbiAgICAgIH1cbiAgICAgIGRhdGEgPSBbcmVkLCBncmVlbiwgYmx1ZV07XG4gICAgfVxuXG4gICAgZGF0YS53aWR0aCA9IHJhc3Rlci53aWR0aDtcbiAgICBkYXRhLmhlaWdodCA9IHJhc3Rlci5oZWlnaHQ7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aWVwb2ludHMuXG4gICAqIEByZXR1cm5zIHtPYmplY3RbXX1cbiAgICovXG4gIGdldFRpZVBvaW50cygpIHtcbiAgICBpZiAoIXRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRpZXBvaW50KSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgdGllUG9pbnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUaWVwb2ludC5sZW5ndGg7IGkgKz0gNikge1xuICAgICAgdGllUG9pbnRzLnB1c2goe1xuICAgICAgICBpOiB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUaWVwb2ludFtpXSxcbiAgICAgICAgajogdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVGllcG9pbnRbaSArIDFdLFxuICAgICAgICBrOiB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUaWVwb2ludFtpICsgMl0sXG4gICAgICAgIHg6IHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRpZXBvaW50W2kgKyAzXSxcbiAgICAgICAgeTogdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVGllcG9pbnRbaSArIDRdLFxuICAgICAgICB6OiB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUaWVwb2ludFtpICsgNV0sXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpZVBvaW50cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwYXJzZWQgR0RBTCBtZXRhZGF0YSBpdGVtcy5cbiAgICpcbiAgICogSWYgc2FtcGxlIGlzIHBhc3NlZCB0byBudWxsLCBkYXRhc2V0LWxldmVsIG1ldGFkYXRhIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIE90aGVyd2lzZSBvbmx5IG1ldGFkYXRhIHNwZWNpZmljIHRvIHRoZSBwcm92aWRlZCBzYW1wbGUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzYW1wbGU9bnVsbF0gVGhlIHNhbXBsZSBpbmRleC5cbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIGdldEdEQUxNZXRhZGF0YShzYW1wbGUgPSBudWxsKSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSB7fTtcbiAgICBpZiAoIXRoaXMuZmlsZURpcmVjdG9yeS5HREFMX01FVEFEQVRBKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc3RyaW5nID0gdGhpcy5maWxlRGlyZWN0b3J5LkdEQUxfTUVUQURBVEE7XG5cbiAgICBsZXQgaXRlbXMgPSBmaW5kVGFnc0J5TmFtZShzdHJpbmcsICdJdGVtJyk7XG5cbiAgICBpZiAoc2FtcGxlID09PSBudWxsKSB7XG4gICAgICBpdGVtcyA9IGl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gZ2V0QXR0cmlidXRlKGl0ZW0sICdzYW1wbGUnKSA9PT0gdW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlbXMgPSBpdGVtcy5maWx0ZXIoKGl0ZW0pID0+IE51bWJlcihnZXRBdHRyaWJ1dGUoaXRlbSwgJ3NhbXBsZScpKSA9PT0gc2FtcGxlKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICBtZXRhZGF0YVtnZXRBdHRyaWJ1dGUoaXRlbSwgJ25hbWUnKV0gPSBpdGVtLmlubmVyO1xuICAgIH1cbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgR0RBTCBub2RhdGEgdmFsdWVcbiAgICogQHJldHVybnMge251bWJlcnxudWxsfVxuICAgKi9cbiAgZ2V0R0RBTE5vRGF0YSgpIHtcbiAgICBpZiAoIXRoaXMuZmlsZURpcmVjdG9yeS5HREFMX05PREFUQSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHN0cmluZyA9IHRoaXMuZmlsZURpcmVjdG9yeS5HREFMX05PREFUQTtcbiAgICByZXR1cm4gTnVtYmVyKHN0cmluZy5zdWJzdHJpbmcoMCwgc3RyaW5nLmxlbmd0aCAtIDEpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbWFnZSBvcmlnaW4gYXMgYSBYWVotdmVjdG9yLiBXaGVuIHRoZSBpbWFnZSBoYXMgbm8gYWZmaW5lXG4gICAqIHRyYW5zZm9ybWF0aW9uLCB0aGVuIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSBUaGUgb3JpZ2luIGFzIGEgdmVjdG9yXG4gICAqL1xuICBnZXRPcmlnaW4oKSB7XG4gICAgY29uc3QgdGllUG9pbnRzID0gdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVGllcG9pbnQ7XG4gICAgY29uc3QgbW9kZWxUcmFuc2Zvcm1hdGlvbiA9IHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRyYW5zZm9ybWF0aW9uO1xuICAgIGlmICh0aWVQb2ludHMgJiYgdGllUG9pbnRzLmxlbmd0aCA9PT0gNikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdGllUG9pbnRzWzNdLFxuICAgICAgICB0aWVQb2ludHNbNF0sXG4gICAgICAgIHRpZVBvaW50c1s1XSxcbiAgICAgIF07XG4gICAgfVxuICAgIGlmIChtb2RlbFRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBtb2RlbFRyYW5zZm9ybWF0aW9uWzNdLFxuICAgICAgICBtb2RlbFRyYW5zZm9ybWF0aW9uWzddLFxuICAgICAgICBtb2RlbFRyYW5zZm9ybWF0aW9uWzExXSxcbiAgICAgIF07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGltYWdlIGRvZXMgbm90IGhhdmUgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uLicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGltYWdlIHJlc29sdXRpb24gYXMgYSBYWVotdmVjdG9yLiBXaGVuIHRoZSBpbWFnZSBoYXMgbm8gYWZmaW5lXG4gICAqIHRyYW5zZm9ybWF0aW9uLCB0aGVuIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAqIEBwYXJhbSB7R2VvVElGRkltYWdlfSBbcmVmZXJlbmNlSW1hZ2U9bnVsbF0gQSByZWZlcmVuY2UgaW1hZ2UgdG8gY2FsY3VsYXRlIHRoZSByZXNvbHV0aW9uIGZyb21cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBjYXNlcyB3aGVuIHRoZSBjdXJyZW50IGltYWdlIGRvZXMgbm90IGhhdmUgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQgdGFncyBvbiBpdHMgb3duLlxuICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gVGhlIHJlc29sdXRpb24gYXMgYSB2ZWN0b3JcbiAgICovXG4gIGdldFJlc29sdXRpb24ocmVmZXJlbmNlSW1hZ2UgPSBudWxsKSB7XG4gICAgY29uc3QgbW9kZWxQaXhlbFNjYWxlID0gdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsUGl4ZWxTY2FsZTtcbiAgICBjb25zdCBtb2RlbFRyYW5zZm9ybWF0aW9uID0gdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVHJhbnNmb3JtYXRpb247XG5cbiAgICBpZiAobW9kZWxQaXhlbFNjYWxlKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBtb2RlbFBpeGVsU2NhbGVbMF0sXG4gICAgICAgIC1tb2RlbFBpeGVsU2NhbGVbMV0sXG4gICAgICAgIG1vZGVsUGl4ZWxTY2FsZVsyXSxcbiAgICAgIF07XG4gICAgfVxuICAgIGlmIChtb2RlbFRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICBpZiAobW9kZWxUcmFuc2Zvcm1hdGlvblsxXSA9PT0gMCAmJiBtb2RlbFRyYW5zZm9ybWF0aW9uWzRdID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgbW9kZWxUcmFuc2Zvcm1hdGlvblswXSxcbiAgICAgICAgICAtbW9kZWxUcmFuc2Zvcm1hdGlvbls1XSxcbiAgICAgICAgICBtb2RlbFRyYW5zZm9ybWF0aW9uWzEwXSxcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXG4gICAgICAgIE1hdGguc3FydCgobW9kZWxUcmFuc2Zvcm1hdGlvblswXSAqIG1vZGVsVHJhbnNmb3JtYXRpb25bMF0pXG4gICAgICAgICAgKyAobW9kZWxUcmFuc2Zvcm1hdGlvbls0XSAqIG1vZGVsVHJhbnNmb3JtYXRpb25bNF0pKSxcbiAgICAgICAgLU1hdGguc3FydCgobW9kZWxUcmFuc2Zvcm1hdGlvblsxXSAqIG1vZGVsVHJhbnNmb3JtYXRpb25bMV0pXG4gICAgICAgICAgKyAobW9kZWxUcmFuc2Zvcm1hdGlvbls1XSAqIG1vZGVsVHJhbnNmb3JtYXRpb25bNV0pKSxcbiAgICAgICAgbW9kZWxUcmFuc2Zvcm1hdGlvblsxMF1dO1xuICAgIH1cblxuICAgIGlmIChyZWZlcmVuY2VJbWFnZSkge1xuICAgICAgY29uc3QgW3JlZlJlc1gsIHJlZlJlc1ksIHJlZlJlc1pdID0gcmVmZXJlbmNlSW1hZ2UuZ2V0UmVzb2x1dGlvbigpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgcmVmUmVzWCAqIHJlZmVyZW5jZUltYWdlLmdldFdpZHRoKCkgLyB0aGlzLmdldFdpZHRoKCksXG4gICAgICAgIHJlZlJlc1kgKiByZWZlcmVuY2VJbWFnZS5nZXRIZWlnaHQoKSAvIHRoaXMuZ2V0SGVpZ2h0KCksXG4gICAgICAgIHJlZlJlc1ogKiByZWZlcmVuY2VJbWFnZS5nZXRXaWR0aCgpIC8gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgXTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbWFnZSBkb2VzIG5vdCBoYXZlIGFuIGFmZmluZSB0cmFuc2Zvcm1hdGlvbi4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBwaXhlbHMgb2YgdGhlIGltYWdlIGRlcGljdCBhbiBhcmVhIChvciBwb2ludCkuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBwaXhlbHMgYXJlIGEgcG9pbnRcbiAgICovXG4gIHBpeGVsSXNBcmVhKCkge1xuICAgIHJldHVybiB0aGlzLmdlb0tleXMuR1RSYXN0ZXJUeXBlR2VvS2V5ID09PSAxO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGltYWdlIGJvdW5kaW5nIGJveCBhcyBhbiBhcnJheSBvZiA0IHZhbHVlczogbWluLXgsIG1pbi15LFxuICAgKiBtYXgteCBhbmQgbWF4LXkuIFdoZW4gdGhlIGltYWdlIGhhcyBubyBhZmZpbmUgdHJhbnNmb3JtYXRpb24sIHRoZW4gYW5cbiAgICogZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbdGlsZWdyaWQ9ZmFsc2VdIElmIHRydWUgcmV0dXJuIGV4dGVudCBmb3IgYSB0aWxlZ3JpZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aG91dCBhZGp1c3RtZW50IGZvciBNb2RlbFRyYW5zZm9ybWF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gVGhlIGJvdW5kaW5nIGJveFxuICAgKi9cbiAgZ2V0Qm91bmRpbmdCb3godGlsZWdyaWQgPSBmYWxzZSkge1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG5cbiAgICBpZiAodGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVHJhbnNmb3JtYXRpb24gJiYgIXRpbGVncmlkKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIGNvbnN0IFthLCBiLCBjLCBkLCBlLCBmLCBnLCBoXSA9IHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRyYW5zZm9ybWF0aW9uO1xuXG4gICAgICBjb25zdCBjb3JuZXJzID0gW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFswLCBoZWlnaHRdLFxuICAgICAgICBbd2lkdGgsIDBdLFxuICAgICAgICBbd2lkdGgsIGhlaWdodF0sXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBwcm9qZWN0ZWQgPSBjb3JuZXJzLm1hcCgoW0ksIEpdKSA9PiBbXG4gICAgICAgIGQgKyAoYSAqIEkpICsgKGIgKiBKKSxcbiAgICAgICAgaCArIChlICogSSkgKyAoZiAqIEopLFxuICAgICAgXSk7XG5cbiAgICAgIGNvbnN0IHhzID0gcHJvamVjdGVkLm1hcCgocHQpID0+IHB0WzBdKTtcbiAgICAgIGNvbnN0IHlzID0gcHJvamVjdGVkLm1hcCgocHQpID0+IHB0WzFdKTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgTWF0aC5taW4oLi4ueHMpLFxuICAgICAgICBNYXRoLm1pbiguLi55cyksXG4gICAgICAgIE1hdGgubWF4KC4uLnhzKSxcbiAgICAgICAgTWF0aC5tYXgoLi4ueXMpLFxuICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3JpZ2luID0gdGhpcy5nZXRPcmlnaW4oKTtcbiAgICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oKTtcblxuICAgICAgY29uc3QgeDEgPSBvcmlnaW5bMF07XG4gICAgICBjb25zdCB5MSA9IG9yaWdpblsxXTtcblxuICAgICAgY29uc3QgeDIgPSB4MSArIChyZXNvbHV0aW9uWzBdICogd2lkdGgpO1xuICAgICAgY29uc3QgeTIgPSB5MSArIChyZXNvbHV0aW9uWzFdICogaGVpZ2h0KTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgTWF0aC5taW4oeDEsIHgyKSxcbiAgICAgICAgTWF0aC5taW4oeTEsIHkyKSxcbiAgICAgICAgTWF0aC5tYXgoeDEsIHgyKSxcbiAgICAgICAgTWF0aC5tYXgoeTEsIHkyKSxcbiAgICAgIF07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEdlb1RJRkZJbWFnZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/geotiffimage.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/geotiffwriter.js":
/*!***********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/geotiffwriter.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   writeGeotiff: function() { return /* binding */ writeGeotiff; }\n/* harmony export */ });\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globals.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/globals.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/utils.js\");\n/*\n  Some parts of this file are based on UTIF.js,\n  which was released under the MIT License.\n  You can view that here:\n  https://github.com/photopea/UTIF.js/blob/master/LICENSE\n*/\n\n\n\nconst tagName2Code = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.invert)(_globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagNames);\nconst geoKeyName2Code = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.invert)(_globals_js__WEBPACK_IMPORTED_MODULE_1__.geoKeyNames);\nconst name2code = {};\n(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.assign)(name2code, tagName2Code);\n(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.assign)(name2code, geoKeyName2Code);\nconst typeName2byte = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.invert)(_globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTypeNames);\n\n// config variables\nconst numBytesInIfd = 1000;\n\nconst _binBE = {\n  nextZero: (data, o) => {\n    let oincr = o;\n    while (data[oincr] !== 0) {\n      oincr++;\n    }\n    return oincr;\n  },\n  readUshort: (buff, p) => {\n    return (buff[p] << 8) | buff[p + 1];\n  },\n  readShort: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 1];\n    a[1] = buff[p + 0];\n    return _binBE.i16[0];\n  },\n  readInt: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.i32[0];\n  },\n  readUint: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.ui32[0];\n  },\n  readASCII: (buff, p, l) => {\n    return l.map((i) => String.fromCharCode(buff[p + i])).join('');\n  },\n  readFloat: (buff, p) => {\n    const a = _binBE.ui8;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(4, (i) => {\n      a[i] = buff[p + 3 - i];\n    });\n    return _binBE.fl32[0];\n  },\n  readDouble: (buff, p) => {\n    const a = _binBE.ui8;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(8, (i) => {\n      a[i] = buff[p + 7 - i];\n    });\n    return _binBE.fl64[0];\n  },\n  writeUshort: (buff, p, n) => {\n    buff[p] = (n >> 8) & 255;\n    buff[p + 1] = n & 255;\n  },\n  writeUint: (buff, p, n) => {\n    buff[p] = (n >> 24) & 255;\n    buff[p + 1] = (n >> 16) & 255;\n    buff[p + 2] = (n >> 8) & 255;\n    buff[p + 3] = (n >> 0) & 255;\n  },\n  writeASCII: (buff, p, s) => {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(s.length, (i) => {\n      buff[p + i] = s.charCodeAt(i);\n    });\n  },\n  ui8: new Uint8Array(8),\n};\n\n_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);\n\n_binBE.writeDouble = (buff, p, n) => {\n  _binBE.fl64[0] = n;\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(8, (i) => {\n    buff[p + i] = _binBE.ui8[7 - i];\n  });\n};\n\nconst _writeIFD = (bin, data, _offset, ifd) => {\n  let offset = _offset;\n\n  const keys = Object.keys(ifd).filter((key) => {\n    return key !== undefined && key !== null && key !== 'undefined';\n  });\n\n  bin.writeUshort(data, offset, keys.length);\n  offset += 2;\n\n  let eoff = offset + (12 * keys.length) + 4;\n\n  for (const key of keys) {\n    let tag = null;\n    if (typeof key === 'number') {\n      tag = key;\n    } else if (typeof key === 'string') {\n      tag = parseInt(key, 10);\n    }\n\n    const typeName = _globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagTypes[tag];\n    const typeNum = typeName2byte[typeName];\n\n    if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {\n      throw new Error(`unknown type of tag: ${tag}`);\n    }\n\n    let val = ifd[key];\n\n    if (val === undefined) {\n      throw new Error(`failed to get value for key ${key}`);\n    }\n\n    // ASCIIZ format with trailing 0 character\n    // http://www.fileformat.info/format/tiff/corion.htm\n    // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii\n    if (typeName === 'ASCII' && typeof val === 'string' && (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.endsWith)(val, '\\u0000') === false) {\n      val += '\\u0000';\n    }\n\n    const num = val.length;\n\n    bin.writeUshort(data, offset, tag);\n    offset += 2;\n\n    bin.writeUshort(data, offset, typeNum);\n    offset += 2;\n\n    bin.writeUint(data, offset, num);\n    offset += 4;\n\n    let dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;\n    let toff = offset;\n\n    if (dlen > 4) {\n      bin.writeUint(data, offset, eoff);\n      toff = eoff;\n    }\n\n    if (typeName === 'ASCII') {\n      bin.writeASCII(data, toff, val);\n    } else if (typeName === 'SHORT') {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, (i) => {\n        bin.writeUshort(data, toff + (2 * i), val[i]);\n      });\n    } else if (typeName === 'LONG') {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, (i) => {\n        bin.writeUint(data, toff + (4 * i), val[i]);\n      });\n    } else if (typeName === 'RATIONAL') {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, (i) => {\n        bin.writeUint(data, toff + (8 * i), Math.round(val[i] * 10000));\n        bin.writeUint(data, toff + (8 * i) + 4, 10000);\n      });\n    } else if (typeName === 'DOUBLE') {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, (i) => {\n        bin.writeDouble(data, toff + (8 * i), val[i]);\n      });\n    }\n\n    if (dlen > 4) {\n      dlen += (dlen & 1);\n      eoff += dlen;\n    }\n\n    offset += 4;\n  }\n\n  return [offset, eoff];\n};\n\nconst encodeIfds = (ifds) => {\n  const data = new Uint8Array(numBytesInIfd);\n  let offset = 4;\n  const bin = _binBE;\n\n  // set big-endian byte-order\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[0] = 77;\n  data[1] = 77;\n\n  // set format-version number\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[3] = 42;\n\n  let ifdo = 8;\n\n  bin.writeUint(data, offset, ifdo);\n\n  offset += 4;\n\n  ifds.forEach((ifd, i) => {\n    const noffs = _writeIFD(bin, data, ifdo, ifd);\n    ifdo = noffs[1];\n    if (i < ifds.length - 1) {\n      bin.writeUint(data, noffs[0], ifdo);\n    }\n  });\n\n  if (data.slice) {\n    return data.slice(0, ifdo).buffer;\n  }\n\n  // node hasn't implemented slice on Uint8Array yet\n  const result = new Uint8Array(ifdo);\n  for (let i = 0; i < ifdo; i++) {\n    result[i] = data[i];\n  }\n  return result.buffer;\n};\n\nconst encodeImage = (values, width, height, metadata) => {\n  if (height === undefined || height === null) {\n    throw new Error(`you passed into encodeImage a width of type ${height}`);\n  }\n\n  if (width === undefined || width === null) {\n    throw new Error(`you passed into encodeImage a width of type ${width}`);\n  }\n\n  const ifd = {\n    256: [width], // ImageWidth\n    257: [height], // ImageLength\n    273: [numBytesInIfd], // strips offset\n    278: [height], // RowsPerStrip\n    305: 'geotiff.js', // no array for ASCII(Z)\n  };\n\n  if (metadata) {\n    for (const i in metadata) {\n      if (metadata.hasOwnProperty(i)) {\n        ifd[i] = metadata[i];\n      }\n    }\n  }\n\n  const prfx = new Uint8Array(encodeIfds([ifd]));\n\n  const img = new Uint8Array(values);\n\n  const samplesPerPixel = ifd[277];\n\n  const data = new Uint8Array(numBytesInIfd + (width * height * samplesPerPixel));\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(prfx.length, (i) => {\n    data[i] = prfx[i];\n  });\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.forEach)(img, (value, i) => {\n    data[numBytesInIfd + i] = value;\n  });\n\n  return data.buffer;\n};\n\nconst convertToTids = (input) => {\n  const result = {};\n  for (const key in input) {\n    if (key !== 'StripOffsets') {\n      if (!name2code[key]) {\n        console.error(key, 'not in name2code:', Object.keys(name2code));\n      }\n      result[name2code[key]] = input[key];\n    }\n  }\n  return result;\n};\n\nconst toArray = (input) => {\n  if (Array.isArray(input)) {\n    return input;\n  }\n  return [input];\n};\n\nconst metadataDefaults = [\n  ['Compression', 1], // no compression\n  ['PlanarConfiguration', 1],\n  ['ExtraSamples', 0],\n];\n\nfunction writeGeotiff(data, metadata) {\n  const isFlattened = typeof data[0] === 'number';\n\n  let height;\n  let numBands;\n  let width;\n  let flattenedValues;\n\n  if (isFlattened) {\n    height = metadata.height || metadata.ImageLength;\n    width = metadata.width || metadata.ImageWidth;\n    numBands = data.length / (height * width);\n    flattenedValues = data;\n  } else {\n    numBands = data.length;\n    height = data[0].length;\n    width = data[0][0].length;\n    flattenedValues = [];\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(height, (rowIndex) => {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(width, (columnIndex) => {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(numBands, (bandIndex) => {\n          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);\n        });\n      });\n    });\n  }\n\n  metadata.ImageLength = height;\n  delete metadata.height;\n  metadata.ImageWidth = width;\n  delete metadata.width;\n\n  // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n\n  if (!metadata.BitsPerSample) {\n    metadata.BitsPerSample = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(numBands, () => 8);\n  }\n\n  metadataDefaults.forEach((tag) => {\n    const key = tag[0];\n    if (!metadata[key]) {\n      const value = tag[1];\n      metadata[key] = value;\n    }\n  });\n\n  // The color space of the image data.\n  // 1=black is zero and 2=RGB.\n  if (!metadata.PhotometricInterpretation) {\n    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;\n  }\n\n  // The number of components per pixel.\n  if (!metadata.SamplesPerPixel) {\n    metadata.SamplesPerPixel = [numBands];\n  }\n\n  if (!metadata.StripByteCounts) {\n    // we are only writing one strip\n    metadata.StripByteCounts = [numBands * height * width];\n  }\n\n  if (!metadata.ModelPixelScale) {\n    // assumes raster takes up exactly the whole globe\n    metadata.ModelPixelScale = [360 / width, 180 / height, 0];\n  }\n\n  if (!metadata.SampleFormat) {\n    metadata.SampleFormat = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(numBands, () => 1);\n  }\n\n  // if didn't pass in projection information, assume the popular 4326 \"geographic projection\"\n  if (!metadata.hasOwnProperty('GeographicTypeGeoKey') && !metadata.hasOwnProperty('ProjectedCSTypeGeoKey')) {\n    metadata.GeographicTypeGeoKey = 4326;\n    metadata.ModelTiepoint = [0, 0, 0, -180, 90, 0]; // raster fits whole globe\n    metadata.GeogCitationGeoKey = 'WGS 84';\n    metadata.GTModelTypeGeoKey = 2;\n  }\n\n  const geoKeys = Object.keys(metadata)\n    .filter((key) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.endsWith)(key, 'GeoKey'))\n    .sort((a, b) => name2code[a] - name2code[b]);\n\n  if (!metadata.GeoAsciiParams) {\n    let geoAsciiParams = '';\n    geoKeys.forEach((name) => {\n      const code = Number(name2code[name]);\n      const tagType = _globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagTypes[code];\n      if (tagType === 'ASCII') {\n        geoAsciiParams += `${metadata[name].toString()}\\u0000`;\n      }\n    });\n    if (geoAsciiParams.length > 0) {\n      metadata.GeoAsciiParams = geoAsciiParams;\n    }\n  }\n\n  if (!metadata.GeoKeyDirectory) {\n    const NumberOfKeys = geoKeys.length;\n\n    const GeoKeyDirectory = [1, 1, 0, NumberOfKeys];\n    geoKeys.forEach((geoKey) => {\n      const KeyID = Number(name2code[geoKey]);\n      GeoKeyDirectory.push(KeyID);\n\n      let Count;\n      let TIFFTagLocation;\n      let valueOffset;\n      if (_globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagTypes[KeyID] === 'SHORT') {\n        Count = 1;\n        TIFFTagLocation = 0;\n        valueOffset = metadata[geoKey];\n      } else if (geoKey === 'GeogCitationGeoKey') {\n        Count = metadata.GeoAsciiParams.length;\n        TIFFTagLocation = Number(name2code.GeoAsciiParams);\n        valueOffset = 0;\n      } else {\n        console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${geoKey}`);\n      }\n      GeoKeyDirectory.push(TIFFTagLocation);\n      GeoKeyDirectory.push(Count);\n      GeoKeyDirectory.push(valueOffset);\n    });\n    metadata.GeoKeyDirectory = GeoKeyDirectory;\n  }\n\n  // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag\n  for (const geoKey of geoKeys) {\n    if (metadata.hasOwnProperty(geoKey)) {\n      delete metadata[geoKey];\n    }\n  }\n\n  [\n    'Compression',\n    'ExtraSamples',\n    'GeographicTypeGeoKey',\n    'GTModelTypeGeoKey',\n    'GTRasterTypeGeoKey',\n    'ImageLength', // synonym of ImageHeight\n    'ImageWidth',\n    'Orientation',\n    'PhotometricInterpretation',\n    'ProjectedCSTypeGeoKey',\n    'PlanarConfiguration',\n    'ResolutionUnit',\n    'SamplesPerPixel',\n    'XPosition',\n    'YPosition',\n    'RowsPerStrip',\n  ].forEach((name) => {\n    if (metadata[name]) {\n      metadata[name] = toArray(metadata[name]);\n    }\n  });\n\n  const encodedMetadata = convertToTids(metadata);\n\n  const outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);\n\n  return outputImage;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2dlb3RpZmZ3cml0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3lGO0FBQ25COztBQUV0RSxxQkFBcUIsaURBQU0sQ0FBQyxzREFBYTtBQUN6Qyx3QkFBd0IsaURBQU0sQ0FBQyxvREFBVztBQUMxQztBQUNBLGlEQUFNO0FBQ04saURBQU07QUFDTixzQkFBc0IsaURBQU0sQ0FBQyx1REFBYzs7QUFFM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSSxnREFBSztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJLGdEQUFLO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxJQUFJLGdEQUFLO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUUsZ0RBQUs7QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxxQkFBcUIsc0RBQWE7QUFDbEM7O0FBRUE7QUFD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Q0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nZW90aWZmd3JpdGVyLmpzP2IzZDgiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgU29tZSBwYXJ0cyBvZiB0aGlzIGZpbGUgYXJlIGJhc2VkIG9uIFVUSUYuanMsXG4gIHdoaWNoIHdhcyByZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gIFlvdSBjYW4gdmlldyB0aGF0IGhlcmU6XG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b3BlYS9VVElGLmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiovXG5pbXBvcnQgeyBmaWVsZFRhZ05hbWVzLCBmaWVsZFRhZ1R5cGVzLCBmaWVsZFR5cGVOYW1lcywgZ2VvS2V5TmFtZXMgfSBmcm9tICcuL2dsb2JhbHMuanMnO1xuaW1wb3J0IHsgYXNzaWduLCBlbmRzV2l0aCwgZm9yRWFjaCwgaW52ZXJ0LCB0aW1lcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG5jb25zdCB0YWdOYW1lMkNvZGUgPSBpbnZlcnQoZmllbGRUYWdOYW1lcyk7XG5jb25zdCBnZW9LZXlOYW1lMkNvZGUgPSBpbnZlcnQoZ2VvS2V5TmFtZXMpO1xuY29uc3QgbmFtZTJjb2RlID0ge307XG5hc3NpZ24obmFtZTJjb2RlLCB0YWdOYW1lMkNvZGUpO1xuYXNzaWduKG5hbWUyY29kZSwgZ2VvS2V5TmFtZTJDb2RlKTtcbmNvbnN0IHR5cGVOYW1lMmJ5dGUgPSBpbnZlcnQoZmllbGRUeXBlTmFtZXMpO1xuXG4vLyBjb25maWcgdmFyaWFibGVzXG5jb25zdCBudW1CeXRlc0luSWZkID0gMTAwMDtcblxuY29uc3QgX2JpbkJFID0ge1xuICBuZXh0WmVybzogKGRhdGEsIG8pID0+IHtcbiAgICBsZXQgb2luY3IgPSBvO1xuICAgIHdoaWxlIChkYXRhW29pbmNyXSAhPT0gMCkge1xuICAgICAgb2luY3IrKztcbiAgICB9XG4gICAgcmV0dXJuIG9pbmNyO1xuICB9LFxuICByZWFkVXNob3J0OiAoYnVmZiwgcCkgPT4ge1xuICAgIHJldHVybiAoYnVmZltwXSA8PCA4KSB8IGJ1ZmZbcCArIDFdO1xuICB9LFxuICByZWFkU2hvcnQ6IChidWZmLCBwKSA9PiB7XG4gICAgY29uc3QgYSA9IF9iaW5CRS51aTg7XG4gICAgYVswXSA9IGJ1ZmZbcCArIDFdO1xuICAgIGFbMV0gPSBidWZmW3AgKyAwXTtcbiAgICByZXR1cm4gX2JpbkJFLmkxNlswXTtcbiAgfSxcbiAgcmVhZEludDogKGJ1ZmYsIHApID0+IHtcbiAgICBjb25zdCBhID0gX2JpbkJFLnVpODtcbiAgICBhWzBdID0gYnVmZltwICsgM107XG4gICAgYVsxXSA9IGJ1ZmZbcCArIDJdO1xuICAgIGFbMl0gPSBidWZmW3AgKyAxXTtcbiAgICBhWzNdID0gYnVmZltwICsgMF07XG4gICAgcmV0dXJuIF9iaW5CRS5pMzJbMF07XG4gIH0sXG4gIHJlYWRVaW50OiAoYnVmZiwgcCkgPT4ge1xuICAgIGNvbnN0IGEgPSBfYmluQkUudWk4O1xuICAgIGFbMF0gPSBidWZmW3AgKyAzXTtcbiAgICBhWzFdID0gYnVmZltwICsgMl07XG4gICAgYVsyXSA9IGJ1ZmZbcCArIDFdO1xuICAgIGFbM10gPSBidWZmW3AgKyAwXTtcbiAgICByZXR1cm4gX2JpbkJFLnVpMzJbMF07XG4gIH0sXG4gIHJlYWRBU0NJSTogKGJ1ZmYsIHAsIGwpID0+IHtcbiAgICByZXR1cm4gbC5tYXAoKGkpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZltwICsgaV0pKS5qb2luKCcnKTtcbiAgfSxcbiAgcmVhZEZsb2F0OiAoYnVmZiwgcCkgPT4ge1xuICAgIGNvbnN0IGEgPSBfYmluQkUudWk4O1xuICAgIHRpbWVzKDQsIChpKSA9PiB7XG4gICAgICBhW2ldID0gYnVmZltwICsgMyAtIGldO1xuICAgIH0pO1xuICAgIHJldHVybiBfYmluQkUuZmwzMlswXTtcbiAgfSxcbiAgcmVhZERvdWJsZTogKGJ1ZmYsIHApID0+IHtcbiAgICBjb25zdCBhID0gX2JpbkJFLnVpODtcbiAgICB0aW1lcyg4LCAoaSkgPT4ge1xuICAgICAgYVtpXSA9IGJ1ZmZbcCArIDcgLSBpXTtcbiAgICB9KTtcbiAgICByZXR1cm4gX2JpbkJFLmZsNjRbMF07XG4gIH0sXG4gIHdyaXRlVXNob3J0OiAoYnVmZiwgcCwgbikgPT4ge1xuICAgIGJ1ZmZbcF0gPSAobiA+PiA4KSAmIDI1NTtcbiAgICBidWZmW3AgKyAxXSA9IG4gJiAyNTU7XG4gIH0sXG4gIHdyaXRlVWludDogKGJ1ZmYsIHAsIG4pID0+IHtcbiAgICBidWZmW3BdID0gKG4gPj4gMjQpICYgMjU1O1xuICAgIGJ1ZmZbcCArIDFdID0gKG4gPj4gMTYpICYgMjU1O1xuICAgIGJ1ZmZbcCArIDJdID0gKG4gPj4gOCkgJiAyNTU7XG4gICAgYnVmZltwICsgM10gPSAobiA+PiAwKSAmIDI1NTtcbiAgfSxcbiAgd3JpdGVBU0NJSTogKGJ1ZmYsIHAsIHMpID0+IHtcbiAgICB0aW1lcyhzLmxlbmd0aCwgKGkpID0+IHtcbiAgICAgIGJ1ZmZbcCArIGldID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIH0pO1xuICB9LFxuICB1aTg6IG5ldyBVaW50OEFycmF5KDgpLFxufTtcblxuX2JpbkJFLmZsNjQgPSBuZXcgRmxvYXQ2NEFycmF5KF9iaW5CRS51aTguYnVmZmVyKTtcblxuX2JpbkJFLndyaXRlRG91YmxlID0gKGJ1ZmYsIHAsIG4pID0+IHtcbiAgX2JpbkJFLmZsNjRbMF0gPSBuO1xuICB0aW1lcyg4LCAoaSkgPT4ge1xuICAgIGJ1ZmZbcCArIGldID0gX2JpbkJFLnVpOFs3IC0gaV07XG4gIH0pO1xufTtcblxuY29uc3QgX3dyaXRlSUZEID0gKGJpbiwgZGF0YSwgX29mZnNldCwgaWZkKSA9PiB7XG4gIGxldCBvZmZzZXQgPSBfb2Zmc2V0O1xuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpZmQpLmZpbHRlcigoa2V5KSA9PiB7XG4gICAgcmV0dXJuIGtleSAhPT0gdW5kZWZpbmVkICYmIGtleSAhPT0gbnVsbCAmJiBrZXkgIT09ICd1bmRlZmluZWQnO1xuICB9KTtcblxuICBiaW4ud3JpdGVVc2hvcnQoZGF0YSwgb2Zmc2V0LCBrZXlzLmxlbmd0aCk7XG4gIG9mZnNldCArPSAyO1xuXG4gIGxldCBlb2ZmID0gb2Zmc2V0ICsgKDEyICoga2V5cy5sZW5ndGgpICsgNDtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgbGV0IHRhZyA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdudW1iZXInKSB7XG4gICAgICB0YWcgPSBrZXk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgdGFnID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZU5hbWUgPSBmaWVsZFRhZ1R5cGVzW3RhZ107XG4gICAgY29uc3QgdHlwZU51bSA9IHR5cGVOYW1lMmJ5dGVbdHlwZU5hbWVdO1xuXG4gICAgaWYgKHR5cGVOYW1lID09IG51bGwgfHwgdHlwZU5hbWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZU5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gdHlwZSBvZiB0YWc6ICR7dGFnfWApO1xuICAgIH1cblxuICAgIGxldCB2YWwgPSBpZmRba2V5XTtcblxuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gZ2V0IHZhbHVlIGZvciBrZXkgJHtrZXl9YCk7XG4gICAgfVxuXG4gICAgLy8gQVNDSUlaIGZvcm1hdCB3aXRoIHRyYWlsaW5nIDAgY2hhcmFjdGVyXG4gICAgLy8gaHR0cDovL3d3dy5maWxlZm9ybWF0LmluZm8vZm9ybWF0L3RpZmYvY29yaW9uLmh0bVxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc3ODMwNDQvd2hhdHMtdGhlLWRpZmZlcmVuY2UtYmV0d2Vlbi1hc2NpaXotdnMtYXNjaWlcbiAgICBpZiAodHlwZU5hbWUgPT09ICdBU0NJSScgJiYgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgZW5kc1dpdGgodmFsLCAnXFx1MDAwMCcpID09PSBmYWxzZSkge1xuICAgICAgdmFsICs9ICdcXHUwMDAwJztcbiAgICB9XG5cbiAgICBjb25zdCBudW0gPSB2YWwubGVuZ3RoO1xuXG4gICAgYmluLndyaXRlVXNob3J0KGRhdGEsIG9mZnNldCwgdGFnKTtcbiAgICBvZmZzZXQgKz0gMjtcblxuICAgIGJpbi53cml0ZVVzaG9ydChkYXRhLCBvZmZzZXQsIHR5cGVOdW0pO1xuICAgIG9mZnNldCArPSAyO1xuXG4gICAgYmluLndyaXRlVWludChkYXRhLCBvZmZzZXQsIG51bSk7XG4gICAgb2Zmc2V0ICs9IDQ7XG5cbiAgICBsZXQgZGxlbiA9IFstMSwgMSwgMSwgMiwgNCwgOCwgMCwgMCwgMCwgMCwgMCwgMCwgOF1bdHlwZU51bV0gKiBudW07XG4gICAgbGV0IHRvZmYgPSBvZmZzZXQ7XG5cbiAgICBpZiAoZGxlbiA+IDQpIHtcbiAgICAgIGJpbi53cml0ZVVpbnQoZGF0YSwgb2Zmc2V0LCBlb2ZmKTtcbiAgICAgIHRvZmYgPSBlb2ZmO1xuICAgIH1cblxuICAgIGlmICh0eXBlTmFtZSA9PT0gJ0FTQ0lJJykge1xuICAgICAgYmluLndyaXRlQVNDSUkoZGF0YSwgdG9mZiwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVOYW1lID09PSAnU0hPUlQnKSB7XG4gICAgICB0aW1lcyhudW0sIChpKSA9PiB7XG4gICAgICAgIGJpbi53cml0ZVVzaG9ydChkYXRhLCB0b2ZmICsgKDIgKiBpKSwgdmFsW2ldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZU5hbWUgPT09ICdMT05HJykge1xuICAgICAgdGltZXMobnVtLCAoaSkgPT4ge1xuICAgICAgICBiaW4ud3JpdGVVaW50KGRhdGEsIHRvZmYgKyAoNCAqIGkpLCB2YWxbaV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlTmFtZSA9PT0gJ1JBVElPTkFMJykge1xuICAgICAgdGltZXMobnVtLCAoaSkgPT4ge1xuICAgICAgICBiaW4ud3JpdGVVaW50KGRhdGEsIHRvZmYgKyAoOCAqIGkpLCBNYXRoLnJvdW5kKHZhbFtpXSAqIDEwMDAwKSk7XG4gICAgICAgIGJpbi53cml0ZVVpbnQoZGF0YSwgdG9mZiArICg4ICogaSkgKyA0LCAxMDAwMCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVOYW1lID09PSAnRE9VQkxFJykge1xuICAgICAgdGltZXMobnVtLCAoaSkgPT4ge1xuICAgICAgICBiaW4ud3JpdGVEb3VibGUoZGF0YSwgdG9mZiArICg4ICogaSksIHZhbFtpXSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZGxlbiA+IDQpIHtcbiAgICAgIGRsZW4gKz0gKGRsZW4gJiAxKTtcbiAgICAgIGVvZmYgKz0gZGxlbjtcbiAgICB9XG5cbiAgICBvZmZzZXQgKz0gNDtcbiAgfVxuXG4gIHJldHVybiBbb2Zmc2V0LCBlb2ZmXTtcbn07XG5cbmNvbnN0IGVuY29kZUlmZHMgPSAoaWZkcykgPT4ge1xuICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkobnVtQnl0ZXNJbklmZCk7XG4gIGxldCBvZmZzZXQgPSA0O1xuICBjb25zdCBiaW4gPSBfYmluQkU7XG5cbiAgLy8gc2V0IGJpZy1lbmRpYW4gYnl0ZS1vcmRlclxuICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9USUZGI0J5dGVfb3JkZXJcbiAgZGF0YVswXSA9IDc3O1xuICBkYXRhWzFdID0gNzc7XG5cbiAgLy8gc2V0IGZvcm1hdC12ZXJzaW9uIG51bWJlclxuICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9USUZGI0J5dGVfb3JkZXJcbiAgZGF0YVszXSA9IDQyO1xuXG4gIGxldCBpZmRvID0gODtcblxuICBiaW4ud3JpdGVVaW50KGRhdGEsIG9mZnNldCwgaWZkbyk7XG5cbiAgb2Zmc2V0ICs9IDQ7XG5cbiAgaWZkcy5mb3JFYWNoKChpZmQsIGkpID0+IHtcbiAgICBjb25zdCBub2ZmcyA9IF93cml0ZUlGRChiaW4sIGRhdGEsIGlmZG8sIGlmZCk7XG4gICAgaWZkbyA9IG5vZmZzWzFdO1xuICAgIGlmIChpIDwgaWZkcy5sZW5ndGggLSAxKSB7XG4gICAgICBiaW4ud3JpdGVVaW50KGRhdGEsIG5vZmZzWzBdLCBpZmRvKTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkYXRhLnNsaWNlKSB7XG4gICAgcmV0dXJuIGRhdGEuc2xpY2UoMCwgaWZkbykuYnVmZmVyO1xuICB9XG5cbiAgLy8gbm9kZSBoYXNuJ3QgaW1wbGVtZW50ZWQgc2xpY2Ugb24gVWludDhBcnJheSB5ZXRcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoaWZkbyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWZkbzsgaSsrKSB7XG4gICAgcmVzdWx0W2ldID0gZGF0YVtpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcbn07XG5cbmNvbnN0IGVuY29kZUltYWdlID0gKHZhbHVlcywgd2lkdGgsIGhlaWdodCwgbWV0YWRhdGEpID0+IHtcbiAgaWYgKGhlaWdodCA9PT0gdW5kZWZpbmVkIHx8IGhlaWdodCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgeW91IHBhc3NlZCBpbnRvIGVuY29kZUltYWdlIGEgd2lkdGggb2YgdHlwZSAke2hlaWdodH1gKTtcbiAgfVxuXG4gIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkIHx8IHdpZHRoID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGB5b3UgcGFzc2VkIGludG8gZW5jb2RlSW1hZ2UgYSB3aWR0aCBvZiB0eXBlICR7d2lkdGh9YCk7XG4gIH1cblxuICBjb25zdCBpZmQgPSB7XG4gICAgMjU2OiBbd2lkdGhdLCAvLyBJbWFnZVdpZHRoXG4gICAgMjU3OiBbaGVpZ2h0XSwgLy8gSW1hZ2VMZW5ndGhcbiAgICAyNzM6IFtudW1CeXRlc0luSWZkXSwgLy8gc3RyaXBzIG9mZnNldFxuICAgIDI3ODogW2hlaWdodF0sIC8vIFJvd3NQZXJTdHJpcFxuICAgIDMwNTogJ2dlb3RpZmYuanMnLCAvLyBubyBhcnJheSBmb3IgQVNDSUkoWilcbiAgfTtcblxuICBpZiAobWV0YWRhdGEpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gbWV0YWRhdGEpIHtcbiAgICAgIGlmIChtZXRhZGF0YS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICBpZmRbaV0gPSBtZXRhZGF0YVtpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBwcmZ4ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlSWZkcyhbaWZkXSkpO1xuXG4gIGNvbnN0IGltZyA9IG5ldyBVaW50OEFycmF5KHZhbHVlcyk7XG5cbiAgY29uc3Qgc2FtcGxlc1BlclBpeGVsID0gaWZkWzI3N107XG5cbiAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KG51bUJ5dGVzSW5JZmQgKyAod2lkdGggKiBoZWlnaHQgKiBzYW1wbGVzUGVyUGl4ZWwpKTtcbiAgdGltZXMocHJmeC5sZW5ndGgsIChpKSA9PiB7XG4gICAgZGF0YVtpXSA9IHByZnhbaV07XG4gIH0pO1xuICBmb3JFYWNoKGltZywgKHZhbHVlLCBpKSA9PiB7XG4gICAgZGF0YVtudW1CeXRlc0luSWZkICsgaV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGEuYnVmZmVyO1xufTtcblxuY29uc3QgY29udmVydFRvVGlkcyA9IChpbnB1dCkgPT4ge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gaW5wdXQpIHtcbiAgICBpZiAoa2V5ICE9PSAnU3RyaXBPZmZzZXRzJykge1xuICAgICAgaWYgKCFuYW1lMmNvZGVba2V5XSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGtleSwgJ25vdCBpbiBuYW1lMmNvZGU6JywgT2JqZWN0LmtleXMobmFtZTJjb2RlKSk7XG4gICAgICB9XG4gICAgICByZXN1bHRbbmFtZTJjb2RlW2tleV1dID0gaW5wdXRba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHRvQXJyYXkgPSAoaW5wdXQpID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIHJldHVybiBbaW5wdXRdO1xufTtcblxuY29uc3QgbWV0YWRhdGFEZWZhdWx0cyA9IFtcbiAgWydDb21wcmVzc2lvbicsIDFdLCAvLyBubyBjb21wcmVzc2lvblxuICBbJ1BsYW5hckNvbmZpZ3VyYXRpb24nLCAxXSxcbiAgWydFeHRyYVNhbXBsZXMnLCAwXSxcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZUdlb3RpZmYoZGF0YSwgbWV0YWRhdGEpIHtcbiAgY29uc3QgaXNGbGF0dGVuZWQgPSB0eXBlb2YgZGF0YVswXSA9PT0gJ251bWJlcic7XG5cbiAgbGV0IGhlaWdodDtcbiAgbGV0IG51bUJhbmRzO1xuICBsZXQgd2lkdGg7XG4gIGxldCBmbGF0dGVuZWRWYWx1ZXM7XG5cbiAgaWYgKGlzRmxhdHRlbmVkKSB7XG4gICAgaGVpZ2h0ID0gbWV0YWRhdGEuaGVpZ2h0IHx8IG1ldGFkYXRhLkltYWdlTGVuZ3RoO1xuICAgIHdpZHRoID0gbWV0YWRhdGEud2lkdGggfHwgbWV0YWRhdGEuSW1hZ2VXaWR0aDtcbiAgICBudW1CYW5kcyA9IGRhdGEubGVuZ3RoIC8gKGhlaWdodCAqIHdpZHRoKTtcbiAgICBmbGF0dGVuZWRWYWx1ZXMgPSBkYXRhO1xuICB9IGVsc2Uge1xuICAgIG51bUJhbmRzID0gZGF0YS5sZW5ndGg7XG4gICAgaGVpZ2h0ID0gZGF0YVswXS5sZW5ndGg7XG4gICAgd2lkdGggPSBkYXRhWzBdWzBdLmxlbmd0aDtcbiAgICBmbGF0dGVuZWRWYWx1ZXMgPSBbXTtcbiAgICB0aW1lcyhoZWlnaHQsIChyb3dJbmRleCkgPT4ge1xuICAgICAgdGltZXMod2lkdGgsIChjb2x1bW5JbmRleCkgPT4ge1xuICAgICAgICB0aW1lcyhudW1CYW5kcywgKGJhbmRJbmRleCkgPT4ge1xuICAgICAgICAgIGZsYXR0ZW5lZFZhbHVlcy5wdXNoKGRhdGFbYmFuZEluZGV4XVtyb3dJbmRleF1bY29sdW1uSW5kZXhdKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIG1ldGFkYXRhLkltYWdlTGVuZ3RoID0gaGVpZ2h0O1xuICBkZWxldGUgbWV0YWRhdGEuaGVpZ2h0O1xuICBtZXRhZGF0YS5JbWFnZVdpZHRoID0gd2lkdGg7XG4gIGRlbGV0ZSBtZXRhZGF0YS53aWR0aDtcblxuICAvLyBjb25zdWx0IGh0dHBzOi8vd3d3LmxvYy5nb3YvcHJlc2VydmF0aW9uL2RpZ2l0YWwvZm9ybWF0cy9jb250ZW50L3RpZmZfdGFncy5zaHRtbFxuXG4gIGlmICghbWV0YWRhdGEuQml0c1BlclNhbXBsZSkge1xuICAgIG1ldGFkYXRhLkJpdHNQZXJTYW1wbGUgPSB0aW1lcyhudW1CYW5kcywgKCkgPT4gOCk7XG4gIH1cblxuICBtZXRhZGF0YURlZmF1bHRzLmZvckVhY2goKHRhZykgPT4ge1xuICAgIGNvbnN0IGtleSA9IHRhZ1swXTtcbiAgICBpZiAoIW1ldGFkYXRhW2tleV0pIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGFnWzFdO1xuICAgICAgbWV0YWRhdGFba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gVGhlIGNvbG9yIHNwYWNlIG9mIHRoZSBpbWFnZSBkYXRhLlxuICAvLyAxPWJsYWNrIGlzIHplcm8gYW5kIDI9UkdCLlxuICBpZiAoIW1ldGFkYXRhLlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24pIHtcbiAgICBtZXRhZGF0YS5QaG90b21ldHJpY0ludGVycHJldGF0aW9uID0gbWV0YWRhdGEuQml0c1BlclNhbXBsZS5sZW5ndGggPT09IDMgPyAyIDogMTtcbiAgfVxuXG4gIC8vIFRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBwZXIgcGl4ZWwuXG4gIGlmICghbWV0YWRhdGEuU2FtcGxlc1BlclBpeGVsKSB7XG4gICAgbWV0YWRhdGEuU2FtcGxlc1BlclBpeGVsID0gW251bUJhbmRzXTtcbiAgfVxuXG4gIGlmICghbWV0YWRhdGEuU3RyaXBCeXRlQ291bnRzKSB7XG4gICAgLy8gd2UgYXJlIG9ubHkgd3JpdGluZyBvbmUgc3RyaXBcbiAgICBtZXRhZGF0YS5TdHJpcEJ5dGVDb3VudHMgPSBbbnVtQmFuZHMgKiBoZWlnaHQgKiB3aWR0aF07XG4gIH1cblxuICBpZiAoIW1ldGFkYXRhLk1vZGVsUGl4ZWxTY2FsZSkge1xuICAgIC8vIGFzc3VtZXMgcmFzdGVyIHRha2VzIHVwIGV4YWN0bHkgdGhlIHdob2xlIGdsb2JlXG4gICAgbWV0YWRhdGEuTW9kZWxQaXhlbFNjYWxlID0gWzM2MCAvIHdpZHRoLCAxODAgLyBoZWlnaHQsIDBdO1xuICB9XG5cbiAgaWYgKCFtZXRhZGF0YS5TYW1wbGVGb3JtYXQpIHtcbiAgICBtZXRhZGF0YS5TYW1wbGVGb3JtYXQgPSB0aW1lcyhudW1CYW5kcywgKCkgPT4gMSk7XG4gIH1cblxuICAvLyBpZiBkaWRuJ3QgcGFzcyBpbiBwcm9qZWN0aW9uIGluZm9ybWF0aW9uLCBhc3N1bWUgdGhlIHBvcHVsYXIgNDMyNiBcImdlb2dyYXBoaWMgcHJvamVjdGlvblwiXG4gIGlmICghbWV0YWRhdGEuaGFzT3duUHJvcGVydHkoJ0dlb2dyYXBoaWNUeXBlR2VvS2V5JykgJiYgIW1ldGFkYXRhLmhhc093blByb3BlcnR5KCdQcm9qZWN0ZWRDU1R5cGVHZW9LZXknKSkge1xuICAgIG1ldGFkYXRhLkdlb2dyYXBoaWNUeXBlR2VvS2V5ID0gNDMyNjtcbiAgICBtZXRhZGF0YS5Nb2RlbFRpZXBvaW50ID0gWzAsIDAsIDAsIC0xODAsIDkwLCAwXTsgLy8gcmFzdGVyIGZpdHMgd2hvbGUgZ2xvYmVcbiAgICBtZXRhZGF0YS5HZW9nQ2l0YXRpb25HZW9LZXkgPSAnV0dTIDg0JztcbiAgICBtZXRhZGF0YS5HVE1vZGVsVHlwZUdlb0tleSA9IDI7XG4gIH1cblxuICBjb25zdCBnZW9LZXlzID0gT2JqZWN0LmtleXMobWV0YWRhdGEpXG4gICAgLmZpbHRlcigoa2V5KSA9PiBlbmRzV2l0aChrZXksICdHZW9LZXknKSlcbiAgICAuc29ydCgoYSwgYikgPT4gbmFtZTJjb2RlW2FdIC0gbmFtZTJjb2RlW2JdKTtcblxuICBpZiAoIW1ldGFkYXRhLkdlb0FzY2lpUGFyYW1zKSB7XG4gICAgbGV0IGdlb0FzY2lpUGFyYW1zID0gJyc7XG4gICAgZ2VvS2V5cy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICBjb25zdCBjb2RlID0gTnVtYmVyKG5hbWUyY29kZVtuYW1lXSk7XG4gICAgICBjb25zdCB0YWdUeXBlID0gZmllbGRUYWdUeXBlc1tjb2RlXTtcbiAgICAgIGlmICh0YWdUeXBlID09PSAnQVNDSUknKSB7XG4gICAgICAgIGdlb0FzY2lpUGFyYW1zICs9IGAke21ldGFkYXRhW25hbWVdLnRvU3RyaW5nKCl9XFx1MDAwMGA7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGdlb0FzY2lpUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIG1ldGFkYXRhLkdlb0FzY2lpUGFyYW1zID0gZ2VvQXNjaWlQYXJhbXM7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFtZXRhZGF0YS5HZW9LZXlEaXJlY3RvcnkpIHtcbiAgICBjb25zdCBOdW1iZXJPZktleXMgPSBnZW9LZXlzLmxlbmd0aDtcblxuICAgIGNvbnN0IEdlb0tleURpcmVjdG9yeSA9IFsxLCAxLCAwLCBOdW1iZXJPZktleXNdO1xuICAgIGdlb0tleXMuZm9yRWFjaCgoZ2VvS2V5KSA9PiB7XG4gICAgICBjb25zdCBLZXlJRCA9IE51bWJlcihuYW1lMmNvZGVbZ2VvS2V5XSk7XG4gICAgICBHZW9LZXlEaXJlY3RvcnkucHVzaChLZXlJRCk7XG5cbiAgICAgIGxldCBDb3VudDtcbiAgICAgIGxldCBUSUZGVGFnTG9jYXRpb247XG4gICAgICBsZXQgdmFsdWVPZmZzZXQ7XG4gICAgICBpZiAoZmllbGRUYWdUeXBlc1tLZXlJRF0gPT09ICdTSE9SVCcpIHtcbiAgICAgICAgQ291bnQgPSAxO1xuICAgICAgICBUSUZGVGFnTG9jYXRpb24gPSAwO1xuICAgICAgICB2YWx1ZU9mZnNldCA9IG1ldGFkYXRhW2dlb0tleV07XG4gICAgICB9IGVsc2UgaWYgKGdlb0tleSA9PT0gJ0dlb2dDaXRhdGlvbkdlb0tleScpIHtcbiAgICAgICAgQ291bnQgPSBtZXRhZGF0YS5HZW9Bc2NpaVBhcmFtcy5sZW5ndGg7XG4gICAgICAgIFRJRkZUYWdMb2NhdGlvbiA9IE51bWJlcihuYW1lMmNvZGUuR2VvQXNjaWlQYXJhbXMpO1xuICAgICAgICB2YWx1ZU9mZnNldCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhgW2dlb3RpZmYuanNdIGNvdWxkbid0IGdldCBUSUZGVGFnTG9jYXRpb24gZm9yICR7Z2VvS2V5fWApO1xuICAgICAgfVxuICAgICAgR2VvS2V5RGlyZWN0b3J5LnB1c2goVElGRlRhZ0xvY2F0aW9uKTtcbiAgICAgIEdlb0tleURpcmVjdG9yeS5wdXNoKENvdW50KTtcbiAgICAgIEdlb0tleURpcmVjdG9yeS5wdXNoKHZhbHVlT2Zmc2V0KTtcbiAgICB9KTtcbiAgICBtZXRhZGF0YS5HZW9LZXlEaXJlY3RvcnkgPSBHZW9LZXlEaXJlY3Rvcnk7XG4gIH1cblxuICAvLyBkZWxldGUgR2VvS2V5cyBmcm9tIG1ldGFkYXRhLCBiZWNhdXNlIHN0b3JlZCBpbiBHZW9LZXlEaXJlY3RvcnkgdGFnXG4gIGZvciAoY29uc3QgZ2VvS2V5IG9mIGdlb0tleXMpIHtcbiAgICBpZiAobWV0YWRhdGEuaGFzT3duUHJvcGVydHkoZ2VvS2V5KSkge1xuICAgICAgZGVsZXRlIG1ldGFkYXRhW2dlb0tleV07XG4gICAgfVxuICB9XG5cbiAgW1xuICAgICdDb21wcmVzc2lvbicsXG4gICAgJ0V4dHJhU2FtcGxlcycsXG4gICAgJ0dlb2dyYXBoaWNUeXBlR2VvS2V5JyxcbiAgICAnR1RNb2RlbFR5cGVHZW9LZXknLFxuICAgICdHVFJhc3RlclR5cGVHZW9LZXknLFxuICAgICdJbWFnZUxlbmd0aCcsIC8vIHN5bm9ueW0gb2YgSW1hZ2VIZWlnaHRcbiAgICAnSW1hZ2VXaWR0aCcsXG4gICAgJ09yaWVudGF0aW9uJyxcbiAgICAnUGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbicsXG4gICAgJ1Byb2plY3RlZENTVHlwZUdlb0tleScsXG4gICAgJ1BsYW5hckNvbmZpZ3VyYXRpb24nLFxuICAgICdSZXNvbHV0aW9uVW5pdCcsXG4gICAgJ1NhbXBsZXNQZXJQaXhlbCcsXG4gICAgJ1hQb3NpdGlvbicsXG4gICAgJ1lQb3NpdGlvbicsXG4gICAgJ1Jvd3NQZXJTdHJpcCcsXG4gIF0uZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgIGlmIChtZXRhZGF0YVtuYW1lXSkge1xuICAgICAgbWV0YWRhdGFbbmFtZV0gPSB0b0FycmF5KG1ldGFkYXRhW25hbWVdKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGVuY29kZWRNZXRhZGF0YSA9IGNvbnZlcnRUb1RpZHMobWV0YWRhdGEpO1xuXG4gIGNvbnN0IG91dHB1dEltYWdlID0gZW5jb2RlSW1hZ2UoZmxhdHRlbmVkVmFsdWVzLCB3aWR0aCwgaGVpZ2h0LCBlbmNvZGVkTWV0YWRhdGEpO1xuXG4gIHJldHVybiBvdXRwdXRJbWFnZTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/geotiffwriter.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/globals.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/dist-module/globals.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExtraSamplesValues: function() { return /* binding */ ExtraSamplesValues; },\n/* harmony export */   LercAddCompression: function() { return /* binding */ LercAddCompression; },\n/* harmony export */   LercParameters: function() { return /* binding */ LercParameters; },\n/* harmony export */   arrayFields: function() { return /* binding */ arrayFields; },\n/* harmony export */   fieldTagNames: function() { return /* binding */ fieldTagNames; },\n/* harmony export */   fieldTagTypes: function() { return /* binding */ fieldTagTypes; },\n/* harmony export */   fieldTags: function() { return /* binding */ fieldTags; },\n/* harmony export */   fieldTypeNames: function() { return /* binding */ fieldTypeNames; },\n/* harmony export */   fieldTypes: function() { return /* binding */ fieldTypes; },\n/* harmony export */   geoKeyNames: function() { return /* binding */ geoKeyNames; },\n/* harmony export */   geoKeys: function() { return /* binding */ geoKeys; },\n/* harmony export */   photometricInterpretations: function() { return /* binding */ photometricInterpretations; }\n/* harmony export */ });\nconst fieldTagNames = {\n  // TIFF Baseline\n  0x013B: 'Artist',\n  0x0102: 'BitsPerSample',\n  0x0109: 'CellLength',\n  0x0108: 'CellWidth',\n  0x0140: 'ColorMap',\n  0x0103: 'Compression',\n  0x8298: 'Copyright',\n  0x0132: 'DateTime',\n  0x0152: 'ExtraSamples',\n  0x010A: 'FillOrder',\n  0x0121: 'FreeByteCounts',\n  0x0120: 'FreeOffsets',\n  0x0123: 'GrayResponseCurve',\n  0x0122: 'GrayResponseUnit',\n  0x013C: 'HostComputer',\n  0x010E: 'ImageDescription',\n  0x0101: 'ImageLength',\n  0x0100: 'ImageWidth',\n  0x010F: 'Make',\n  0x0119: 'MaxSampleValue',\n  0x0118: 'MinSampleValue',\n  0x0110: 'Model',\n  0x00FE: 'NewSubfileType',\n  0x0112: 'Orientation',\n  0x0106: 'PhotometricInterpretation',\n  0x011C: 'PlanarConfiguration',\n  0x0128: 'ResolutionUnit',\n  0x0116: 'RowsPerStrip',\n  0x0115: 'SamplesPerPixel',\n  0x0131: 'Software',\n  0x0117: 'StripByteCounts',\n  0x0111: 'StripOffsets',\n  0x00FF: 'SubfileType',\n  0x0107: 'Threshholding',\n  0x011A: 'XResolution',\n  0x011B: 'YResolution',\n\n  // TIFF Extended\n  0x0146: 'BadFaxLines',\n  0x0147: 'CleanFaxData',\n  0x0157: 'ClipPath',\n  0x0148: 'ConsecutiveBadFaxLines',\n  0x01B1: 'Decode',\n  0x01B2: 'DefaultImageColor',\n  0x010D: 'DocumentName',\n  0x0150: 'DotRange',\n  0x0141: 'HalftoneHints',\n  0x015A: 'Indexed',\n  0x015B: 'JPEGTables',\n  0x011D: 'PageName',\n  0x0129: 'PageNumber',\n  0x013D: 'Predictor',\n  0x013F: 'PrimaryChromaticities',\n  0x0214: 'ReferenceBlackWhite',\n  0x0153: 'SampleFormat',\n  0x0154: 'SMinSampleValue',\n  0x0155: 'SMaxSampleValue',\n  0x022F: 'StripRowCounts',\n  0x014A: 'SubIFDs',\n  0x0124: 'T4Options',\n  0x0125: 'T6Options',\n  0x0145: 'TileByteCounts',\n  0x0143: 'TileLength',\n  0x0144: 'TileOffsets',\n  0x0142: 'TileWidth',\n  0x012D: 'TransferFunction',\n  0x013E: 'WhitePoint',\n  0x0158: 'XClipPathUnits',\n  0x011E: 'XPosition',\n  0x0211: 'YCbCrCoefficients',\n  0x0213: 'YCbCrPositioning',\n  0x0212: 'YCbCrSubSampling',\n  0x0159: 'YClipPathUnits',\n  0x011F: 'YPosition',\n\n  // EXIF\n  0x9202: 'ApertureValue',\n  0xA001: 'ColorSpace',\n  0x9004: 'DateTimeDigitized',\n  0x9003: 'DateTimeOriginal',\n  0x8769: 'Exif IFD',\n  0x9000: 'ExifVersion',\n  0x829A: 'ExposureTime',\n  0xA300: 'FileSource',\n  0x9209: 'Flash',\n  0xA000: 'FlashpixVersion',\n  0x829D: 'FNumber',\n  0xA420: 'ImageUniqueID',\n  0x9208: 'LightSource',\n  0x927C: 'MakerNote',\n  0x9201: 'ShutterSpeedValue',\n  0x9286: 'UserComment',\n\n  // IPTC\n  0x83BB: 'IPTC',\n\n  // ICC\n  0x8773: 'ICC Profile',\n\n  // XMP\n  0x02BC: 'XMP',\n\n  // GDAL\n  0xA480: 'GDAL_METADATA',\n  0xA481: 'GDAL_NODATA',\n\n  // Photoshop\n  0x8649: 'Photoshop',\n\n  // GeoTiff\n  0x830E: 'ModelPixelScale',\n  0x8482: 'ModelTiepoint',\n  0x85D8: 'ModelTransformation',\n  0x87AF: 'GeoKeyDirectory',\n  0x87B0: 'GeoDoubleParams',\n  0x87B1: 'GeoAsciiParams',\n\n  // LERC\n  0xC5F2: 'LercParameters',\n};\n\nconst fieldTags = {};\nfor (const key in fieldTagNames) {\n  if (fieldTagNames.hasOwnProperty(key)) {\n    fieldTags[fieldTagNames[key]] = parseInt(key, 10);\n  }\n}\n\nconst fieldTagTypes = {\n  256: 'SHORT',\n  257: 'SHORT',\n  258: 'SHORT',\n  259: 'SHORT',\n  262: 'SHORT',\n  273: 'LONG',\n  274: 'SHORT',\n  277: 'SHORT',\n  278: 'LONG',\n  279: 'LONG',\n  282: 'RATIONAL',\n  283: 'RATIONAL',\n  284: 'SHORT',\n  286: 'SHORT',\n  287: 'RATIONAL',\n  296: 'SHORT',\n  297: 'SHORT',\n  305: 'ASCII',\n  306: 'ASCII',\n  338: 'SHORT',\n  339: 'SHORT',\n  513: 'LONG',\n  514: 'LONG',\n  1024: 'SHORT',\n  1025: 'SHORT',\n  2048: 'SHORT',\n  2049: 'ASCII',\n  3072: 'SHORT',\n  3073: 'ASCII',\n  33550: 'DOUBLE',\n  33922: 'DOUBLE',\n  34264: 'DOUBLE',\n  34665: 'LONG',\n  34735: 'SHORT',\n  34736: 'DOUBLE',\n  34737: 'ASCII',\n  42113: 'ASCII',\n};\n\nconst arrayFields = [\n  fieldTags.BitsPerSample,\n  fieldTags.ExtraSamples,\n  fieldTags.SampleFormat,\n  fieldTags.StripByteCounts,\n  fieldTags.StripOffsets,\n  fieldTags.StripRowCounts,\n  fieldTags.TileByteCounts,\n  fieldTags.TileOffsets,\n  fieldTags.SubIFDs,\n];\n\nconst fieldTypeNames = {\n  0x0001: 'BYTE',\n  0x0002: 'ASCII',\n  0x0003: 'SHORT',\n  0x0004: 'LONG',\n  0x0005: 'RATIONAL',\n  0x0006: 'SBYTE',\n  0x0007: 'UNDEFINED',\n  0x0008: 'SSHORT',\n  0x0009: 'SLONG',\n  0x000A: 'SRATIONAL',\n  0x000B: 'FLOAT',\n  0x000C: 'DOUBLE',\n  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html\n  0x000D: 'IFD',\n  // introduced by BigTIFF\n  0x0010: 'LONG8',\n  0x0011: 'SLONG8',\n  0x0012: 'IFD8',\n};\n\nconst fieldTypes = {};\nfor (const key in fieldTypeNames) {\n  if (fieldTypeNames.hasOwnProperty(key)) {\n    fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);\n  }\n}\n\nconst photometricInterpretations = {\n  WhiteIsZero: 0,\n  BlackIsZero: 1,\n  RGB: 2,\n  Palette: 3,\n  TransparencyMask: 4,\n  CMYK: 5,\n  YCbCr: 6,\n\n  CIELab: 8,\n  ICCLab: 9,\n};\n\nconst ExtraSamplesValues = {\n  Unspecified: 0,\n  Assocalpha: 1,\n  Unassalpha: 2,\n};\n\nconst LercParameters = {\n  Version: 0,\n  AddCompression: 1,\n};\n\nconst LercAddCompression = {\n  None: 0,\n  Deflate: 1,\n  Zstandard: 2,\n};\n\nconst geoKeyNames = {\n  1024: 'GTModelTypeGeoKey',\n  1025: 'GTRasterTypeGeoKey',\n  1026: 'GTCitationGeoKey',\n  2048: 'GeographicTypeGeoKey',\n  2049: 'GeogCitationGeoKey',\n  2050: 'GeogGeodeticDatumGeoKey',\n  2051: 'GeogPrimeMeridianGeoKey',\n  2052: 'GeogLinearUnitsGeoKey',\n  2053: 'GeogLinearUnitSizeGeoKey',\n  2054: 'GeogAngularUnitsGeoKey',\n  2055: 'GeogAngularUnitSizeGeoKey',\n  2056: 'GeogEllipsoidGeoKey',\n  2057: 'GeogSemiMajorAxisGeoKey',\n  2058: 'GeogSemiMinorAxisGeoKey',\n  2059: 'GeogInvFlatteningGeoKey',\n  2060: 'GeogAzimuthUnitsGeoKey',\n  2061: 'GeogPrimeMeridianLongGeoKey',\n  2062: 'GeogTOWGS84GeoKey',\n  3072: 'ProjectedCSTypeGeoKey',\n  3073: 'PCSCitationGeoKey',\n  3074: 'ProjectionGeoKey',\n  3075: 'ProjCoordTransGeoKey',\n  3076: 'ProjLinearUnitsGeoKey',\n  3077: 'ProjLinearUnitSizeGeoKey',\n  3078: 'ProjStdParallel1GeoKey',\n  3079: 'ProjStdParallel2GeoKey',\n  3080: 'ProjNatOriginLongGeoKey',\n  3081: 'ProjNatOriginLatGeoKey',\n  3082: 'ProjFalseEastingGeoKey',\n  3083: 'ProjFalseNorthingGeoKey',\n  3084: 'ProjFalseOriginLongGeoKey',\n  3085: 'ProjFalseOriginLatGeoKey',\n  3086: 'ProjFalseOriginEastingGeoKey',\n  3087: 'ProjFalseOriginNorthingGeoKey',\n  3088: 'ProjCenterLongGeoKey',\n  3089: 'ProjCenterLatGeoKey',\n  3090: 'ProjCenterEastingGeoKey',\n  3091: 'ProjCenterNorthingGeoKey',\n  3092: 'ProjScaleAtNatOriginGeoKey',\n  3093: 'ProjScaleAtCenterGeoKey',\n  3094: 'ProjAzimuthAngleGeoKey',\n  3095: 'ProjStraightVertPoleLongGeoKey',\n  3096: 'ProjRectifiedGridAngleGeoKey',\n  4096: 'VerticalCSTypeGeoKey',\n  4097: 'VerticalCitationGeoKey',\n  4098: 'VerticalDatumGeoKey',\n  4099: 'VerticalUnitsGeoKey',\n};\n\nconst geoKeys = {};\nfor (const key in geoKeyNames) {\n  if (geoKeyNames.hasOwnProperty(key)) {\n    geoKeys[geoKeyNames[key]] = parseInt(key, 10);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2dsb2JhbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nbG9iYWxzLmpzPzcxMzQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGZpZWxkVGFnTmFtZXMgPSB7XG4gIC8vIFRJRkYgQmFzZWxpbmVcbiAgMHgwMTNCOiAnQXJ0aXN0JyxcbiAgMHgwMTAyOiAnQml0c1BlclNhbXBsZScsXG4gIDB4MDEwOTogJ0NlbGxMZW5ndGgnLFxuICAweDAxMDg6ICdDZWxsV2lkdGgnLFxuICAweDAxNDA6ICdDb2xvck1hcCcsXG4gIDB4MDEwMzogJ0NvbXByZXNzaW9uJyxcbiAgMHg4Mjk4OiAnQ29weXJpZ2h0JyxcbiAgMHgwMTMyOiAnRGF0ZVRpbWUnLFxuICAweDAxNTI6ICdFeHRyYVNhbXBsZXMnLFxuICAweDAxMEE6ICdGaWxsT3JkZXInLFxuICAweDAxMjE6ICdGcmVlQnl0ZUNvdW50cycsXG4gIDB4MDEyMDogJ0ZyZWVPZmZzZXRzJyxcbiAgMHgwMTIzOiAnR3JheVJlc3BvbnNlQ3VydmUnLFxuICAweDAxMjI6ICdHcmF5UmVzcG9uc2VVbml0JyxcbiAgMHgwMTNDOiAnSG9zdENvbXB1dGVyJyxcbiAgMHgwMTBFOiAnSW1hZ2VEZXNjcmlwdGlvbicsXG4gIDB4MDEwMTogJ0ltYWdlTGVuZ3RoJyxcbiAgMHgwMTAwOiAnSW1hZ2VXaWR0aCcsXG4gIDB4MDEwRjogJ01ha2UnLFxuICAweDAxMTk6ICdNYXhTYW1wbGVWYWx1ZScsXG4gIDB4MDExODogJ01pblNhbXBsZVZhbHVlJyxcbiAgMHgwMTEwOiAnTW9kZWwnLFxuICAweDAwRkU6ICdOZXdTdWJmaWxlVHlwZScsXG4gIDB4MDExMjogJ09yaWVudGF0aW9uJyxcbiAgMHgwMTA2OiAnUGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbicsXG4gIDB4MDExQzogJ1BsYW5hckNvbmZpZ3VyYXRpb24nLFxuICAweDAxMjg6ICdSZXNvbHV0aW9uVW5pdCcsXG4gIDB4MDExNjogJ1Jvd3NQZXJTdHJpcCcsXG4gIDB4MDExNTogJ1NhbXBsZXNQZXJQaXhlbCcsXG4gIDB4MDEzMTogJ1NvZnR3YXJlJyxcbiAgMHgwMTE3OiAnU3RyaXBCeXRlQ291bnRzJyxcbiAgMHgwMTExOiAnU3RyaXBPZmZzZXRzJyxcbiAgMHgwMEZGOiAnU3ViZmlsZVR5cGUnLFxuICAweDAxMDc6ICdUaHJlc2hob2xkaW5nJyxcbiAgMHgwMTFBOiAnWFJlc29sdXRpb24nLFxuICAweDAxMUI6ICdZUmVzb2x1dGlvbicsXG5cbiAgLy8gVElGRiBFeHRlbmRlZFxuICAweDAxNDY6ICdCYWRGYXhMaW5lcycsXG4gIDB4MDE0NzogJ0NsZWFuRmF4RGF0YScsXG4gIDB4MDE1NzogJ0NsaXBQYXRoJyxcbiAgMHgwMTQ4OiAnQ29uc2VjdXRpdmVCYWRGYXhMaW5lcycsXG4gIDB4MDFCMTogJ0RlY29kZScsXG4gIDB4MDFCMjogJ0RlZmF1bHRJbWFnZUNvbG9yJyxcbiAgMHgwMTBEOiAnRG9jdW1lbnROYW1lJyxcbiAgMHgwMTUwOiAnRG90UmFuZ2UnLFxuICAweDAxNDE6ICdIYWxmdG9uZUhpbnRzJyxcbiAgMHgwMTVBOiAnSW5kZXhlZCcsXG4gIDB4MDE1QjogJ0pQRUdUYWJsZXMnLFxuICAweDAxMUQ6ICdQYWdlTmFtZScsXG4gIDB4MDEyOTogJ1BhZ2VOdW1iZXInLFxuICAweDAxM0Q6ICdQcmVkaWN0b3InLFxuICAweDAxM0Y6ICdQcmltYXJ5Q2hyb21hdGljaXRpZXMnLFxuICAweDAyMTQ6ICdSZWZlcmVuY2VCbGFja1doaXRlJyxcbiAgMHgwMTUzOiAnU2FtcGxlRm9ybWF0JyxcbiAgMHgwMTU0OiAnU01pblNhbXBsZVZhbHVlJyxcbiAgMHgwMTU1OiAnU01heFNhbXBsZVZhbHVlJyxcbiAgMHgwMjJGOiAnU3RyaXBSb3dDb3VudHMnLFxuICAweDAxNEE6ICdTdWJJRkRzJyxcbiAgMHgwMTI0OiAnVDRPcHRpb25zJyxcbiAgMHgwMTI1OiAnVDZPcHRpb25zJyxcbiAgMHgwMTQ1OiAnVGlsZUJ5dGVDb3VudHMnLFxuICAweDAxNDM6ICdUaWxlTGVuZ3RoJyxcbiAgMHgwMTQ0OiAnVGlsZU9mZnNldHMnLFxuICAweDAxNDI6ICdUaWxlV2lkdGgnLFxuICAweDAxMkQ6ICdUcmFuc2ZlckZ1bmN0aW9uJyxcbiAgMHgwMTNFOiAnV2hpdGVQb2ludCcsXG4gIDB4MDE1ODogJ1hDbGlwUGF0aFVuaXRzJyxcbiAgMHgwMTFFOiAnWFBvc2l0aW9uJyxcbiAgMHgwMjExOiAnWUNiQ3JDb2VmZmljaWVudHMnLFxuICAweDAyMTM6ICdZQ2JDclBvc2l0aW9uaW5nJyxcbiAgMHgwMjEyOiAnWUNiQ3JTdWJTYW1wbGluZycsXG4gIDB4MDE1OTogJ1lDbGlwUGF0aFVuaXRzJyxcbiAgMHgwMTFGOiAnWVBvc2l0aW9uJyxcblxuICAvLyBFWElGXG4gIDB4OTIwMjogJ0FwZXJ0dXJlVmFsdWUnLFxuICAweEEwMDE6ICdDb2xvclNwYWNlJyxcbiAgMHg5MDA0OiAnRGF0ZVRpbWVEaWdpdGl6ZWQnLFxuICAweDkwMDM6ICdEYXRlVGltZU9yaWdpbmFsJyxcbiAgMHg4NzY5OiAnRXhpZiBJRkQnLFxuICAweDkwMDA6ICdFeGlmVmVyc2lvbicsXG4gIDB4ODI5QTogJ0V4cG9zdXJlVGltZScsXG4gIDB4QTMwMDogJ0ZpbGVTb3VyY2UnLFxuICAweDkyMDk6ICdGbGFzaCcsXG4gIDB4QTAwMDogJ0ZsYXNocGl4VmVyc2lvbicsXG4gIDB4ODI5RDogJ0ZOdW1iZXInLFxuICAweEE0MjA6ICdJbWFnZVVuaXF1ZUlEJyxcbiAgMHg5MjA4OiAnTGlnaHRTb3VyY2UnLFxuICAweDkyN0M6ICdNYWtlck5vdGUnLFxuICAweDkyMDE6ICdTaHV0dGVyU3BlZWRWYWx1ZScsXG4gIDB4OTI4NjogJ1VzZXJDb21tZW50JyxcblxuICAvLyBJUFRDXG4gIDB4ODNCQjogJ0lQVEMnLFxuXG4gIC8vIElDQ1xuICAweDg3NzM6ICdJQ0MgUHJvZmlsZScsXG5cbiAgLy8gWE1QXG4gIDB4MDJCQzogJ1hNUCcsXG5cbiAgLy8gR0RBTFxuICAweEE0ODA6ICdHREFMX01FVEFEQVRBJyxcbiAgMHhBNDgxOiAnR0RBTF9OT0RBVEEnLFxuXG4gIC8vIFBob3Rvc2hvcFxuICAweDg2NDk6ICdQaG90b3Nob3AnLFxuXG4gIC8vIEdlb1RpZmZcbiAgMHg4MzBFOiAnTW9kZWxQaXhlbFNjYWxlJyxcbiAgMHg4NDgyOiAnTW9kZWxUaWVwb2ludCcsXG4gIDB4ODVEODogJ01vZGVsVHJhbnNmb3JtYXRpb24nLFxuICAweDg3QUY6ICdHZW9LZXlEaXJlY3RvcnknLFxuICAweDg3QjA6ICdHZW9Eb3VibGVQYXJhbXMnLFxuICAweDg3QjE6ICdHZW9Bc2NpaVBhcmFtcycsXG5cbiAgLy8gTEVSQ1xuICAweEM1RjI6ICdMZXJjUGFyYW1ldGVycycsXG59O1xuXG5leHBvcnQgY29uc3QgZmllbGRUYWdzID0ge307XG5mb3IgKGNvbnN0IGtleSBpbiBmaWVsZFRhZ05hbWVzKSB7XG4gIGlmIChmaWVsZFRhZ05hbWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICBmaWVsZFRhZ3NbZmllbGRUYWdOYW1lc1trZXldXSA9IHBhcnNlSW50KGtleSwgMTApO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBmaWVsZFRhZ1R5cGVzID0ge1xuICAyNTY6ICdTSE9SVCcsXG4gIDI1NzogJ1NIT1JUJyxcbiAgMjU4OiAnU0hPUlQnLFxuICAyNTk6ICdTSE9SVCcsXG4gIDI2MjogJ1NIT1JUJyxcbiAgMjczOiAnTE9ORycsXG4gIDI3NDogJ1NIT1JUJyxcbiAgMjc3OiAnU0hPUlQnLFxuICAyNzg6ICdMT05HJyxcbiAgMjc5OiAnTE9ORycsXG4gIDI4MjogJ1JBVElPTkFMJyxcbiAgMjgzOiAnUkFUSU9OQUwnLFxuICAyODQ6ICdTSE9SVCcsXG4gIDI4NjogJ1NIT1JUJyxcbiAgMjg3OiAnUkFUSU9OQUwnLFxuICAyOTY6ICdTSE9SVCcsXG4gIDI5NzogJ1NIT1JUJyxcbiAgMzA1OiAnQVNDSUknLFxuICAzMDY6ICdBU0NJSScsXG4gIDMzODogJ1NIT1JUJyxcbiAgMzM5OiAnU0hPUlQnLFxuICA1MTM6ICdMT05HJyxcbiAgNTE0OiAnTE9ORycsXG4gIDEwMjQ6ICdTSE9SVCcsXG4gIDEwMjU6ICdTSE9SVCcsXG4gIDIwNDg6ICdTSE9SVCcsXG4gIDIwNDk6ICdBU0NJSScsXG4gIDMwNzI6ICdTSE9SVCcsXG4gIDMwNzM6ICdBU0NJSScsXG4gIDMzNTUwOiAnRE9VQkxFJyxcbiAgMzM5MjI6ICdET1VCTEUnLFxuICAzNDI2NDogJ0RPVUJMRScsXG4gIDM0NjY1OiAnTE9ORycsXG4gIDM0NzM1OiAnU0hPUlQnLFxuICAzNDczNjogJ0RPVUJMRScsXG4gIDM0NzM3OiAnQVNDSUknLFxuICA0MjExMzogJ0FTQ0lJJyxcbn07XG5cbmV4cG9ydCBjb25zdCBhcnJheUZpZWxkcyA9IFtcbiAgZmllbGRUYWdzLkJpdHNQZXJTYW1wbGUsXG4gIGZpZWxkVGFncy5FeHRyYVNhbXBsZXMsXG4gIGZpZWxkVGFncy5TYW1wbGVGb3JtYXQsXG4gIGZpZWxkVGFncy5TdHJpcEJ5dGVDb3VudHMsXG4gIGZpZWxkVGFncy5TdHJpcE9mZnNldHMsXG4gIGZpZWxkVGFncy5TdHJpcFJvd0NvdW50cyxcbiAgZmllbGRUYWdzLlRpbGVCeXRlQ291bnRzLFxuICBmaWVsZFRhZ3MuVGlsZU9mZnNldHMsXG4gIGZpZWxkVGFncy5TdWJJRkRzLFxuXTtcblxuZXhwb3J0IGNvbnN0IGZpZWxkVHlwZU5hbWVzID0ge1xuICAweDAwMDE6ICdCWVRFJyxcbiAgMHgwMDAyOiAnQVNDSUknLFxuICAweDAwMDM6ICdTSE9SVCcsXG4gIDB4MDAwNDogJ0xPTkcnLFxuICAweDAwMDU6ICdSQVRJT05BTCcsXG4gIDB4MDAwNjogJ1NCWVRFJyxcbiAgMHgwMDA3OiAnVU5ERUZJTkVEJyxcbiAgMHgwMDA4OiAnU1NIT1JUJyxcbiAgMHgwMDA5OiAnU0xPTkcnLFxuICAweDAwMEE6ICdTUkFUSU9OQUwnLFxuICAweDAwMEI6ICdGTE9BVCcsXG4gIDB4MDAwQzogJ0RPVUJMRScsXG4gIC8vIElGRCBvZmZzZXQsIHN1Z2dlc3RlZCBieSBodHRwczovL293bC5waHkucXVlZW5zdS5jYS9+cGhpbC9leGlmdG9vbC9zdGFuZGFyZHMuaHRtbFxuICAweDAwMEQ6ICdJRkQnLFxuICAvLyBpbnRyb2R1Y2VkIGJ5IEJpZ1RJRkZcbiAgMHgwMDEwOiAnTE9ORzgnLFxuICAweDAwMTE6ICdTTE9ORzgnLFxuICAweDAwMTI6ICdJRkQ4Jyxcbn07XG5cbmV4cG9ydCBjb25zdCBmaWVsZFR5cGVzID0ge307XG5mb3IgKGNvbnN0IGtleSBpbiBmaWVsZFR5cGVOYW1lcykge1xuICBpZiAoZmllbGRUeXBlTmFtZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgIGZpZWxkVHlwZXNbZmllbGRUeXBlTmFtZXNba2V5XV0gPSBwYXJzZUludChrZXksIDEwKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMgPSB7XG4gIFdoaXRlSXNaZXJvOiAwLFxuICBCbGFja0lzWmVybzogMSxcbiAgUkdCOiAyLFxuICBQYWxldHRlOiAzLFxuICBUcmFuc3BhcmVuY3lNYXNrOiA0LFxuICBDTVlLOiA1LFxuICBZQ2JDcjogNixcblxuICBDSUVMYWI6IDgsXG4gIElDQ0xhYjogOSxcbn07XG5cbmV4cG9ydCBjb25zdCBFeHRyYVNhbXBsZXNWYWx1ZXMgPSB7XG4gIFVuc3BlY2lmaWVkOiAwLFxuICBBc3NvY2FscGhhOiAxLFxuICBVbmFzc2FscGhhOiAyLFxufTtcblxuZXhwb3J0IGNvbnN0IExlcmNQYXJhbWV0ZXJzID0ge1xuICBWZXJzaW9uOiAwLFxuICBBZGRDb21wcmVzc2lvbjogMSxcbn07XG5cbmV4cG9ydCBjb25zdCBMZXJjQWRkQ29tcHJlc3Npb24gPSB7XG4gIE5vbmU6IDAsXG4gIERlZmxhdGU6IDEsXG4gIFpzdGFuZGFyZDogMixcbn07XG5cbmV4cG9ydCBjb25zdCBnZW9LZXlOYW1lcyA9IHtcbiAgMTAyNDogJ0dUTW9kZWxUeXBlR2VvS2V5JyxcbiAgMTAyNTogJ0dUUmFzdGVyVHlwZUdlb0tleScsXG4gIDEwMjY6ICdHVENpdGF0aW9uR2VvS2V5JyxcbiAgMjA0ODogJ0dlb2dyYXBoaWNUeXBlR2VvS2V5JyxcbiAgMjA0OTogJ0dlb2dDaXRhdGlvbkdlb0tleScsXG4gIDIwNTA6ICdHZW9nR2VvZGV0aWNEYXR1bUdlb0tleScsXG4gIDIwNTE6ICdHZW9nUHJpbWVNZXJpZGlhbkdlb0tleScsXG4gIDIwNTI6ICdHZW9nTGluZWFyVW5pdHNHZW9LZXknLFxuICAyMDUzOiAnR2VvZ0xpbmVhclVuaXRTaXplR2VvS2V5JyxcbiAgMjA1NDogJ0dlb2dBbmd1bGFyVW5pdHNHZW9LZXknLFxuICAyMDU1OiAnR2VvZ0FuZ3VsYXJVbml0U2l6ZUdlb0tleScsXG4gIDIwNTY6ICdHZW9nRWxsaXBzb2lkR2VvS2V5JyxcbiAgMjA1NzogJ0dlb2dTZW1pTWFqb3JBeGlzR2VvS2V5JyxcbiAgMjA1ODogJ0dlb2dTZW1pTWlub3JBeGlzR2VvS2V5JyxcbiAgMjA1OTogJ0dlb2dJbnZGbGF0dGVuaW5nR2VvS2V5JyxcbiAgMjA2MDogJ0dlb2dBemltdXRoVW5pdHNHZW9LZXknLFxuICAyMDYxOiAnR2VvZ1ByaW1lTWVyaWRpYW5Mb25nR2VvS2V5JyxcbiAgMjA2MjogJ0dlb2dUT1dHUzg0R2VvS2V5JyxcbiAgMzA3MjogJ1Byb2plY3RlZENTVHlwZUdlb0tleScsXG4gIDMwNzM6ICdQQ1NDaXRhdGlvbkdlb0tleScsXG4gIDMwNzQ6ICdQcm9qZWN0aW9uR2VvS2V5JyxcbiAgMzA3NTogJ1Byb2pDb29yZFRyYW5zR2VvS2V5JyxcbiAgMzA3NjogJ1Byb2pMaW5lYXJVbml0c0dlb0tleScsXG4gIDMwNzc6ICdQcm9qTGluZWFyVW5pdFNpemVHZW9LZXknLFxuICAzMDc4OiAnUHJvalN0ZFBhcmFsbGVsMUdlb0tleScsXG4gIDMwNzk6ICdQcm9qU3RkUGFyYWxsZWwyR2VvS2V5JyxcbiAgMzA4MDogJ1Byb2pOYXRPcmlnaW5Mb25nR2VvS2V5JyxcbiAgMzA4MTogJ1Byb2pOYXRPcmlnaW5MYXRHZW9LZXknLFxuICAzMDgyOiAnUHJvakZhbHNlRWFzdGluZ0dlb0tleScsXG4gIDMwODM6ICdQcm9qRmFsc2VOb3J0aGluZ0dlb0tleScsXG4gIDMwODQ6ICdQcm9qRmFsc2VPcmlnaW5Mb25nR2VvS2V5JyxcbiAgMzA4NTogJ1Byb2pGYWxzZU9yaWdpbkxhdEdlb0tleScsXG4gIDMwODY6ICdQcm9qRmFsc2VPcmlnaW5FYXN0aW5nR2VvS2V5JyxcbiAgMzA4NzogJ1Byb2pGYWxzZU9yaWdpbk5vcnRoaW5nR2VvS2V5JyxcbiAgMzA4ODogJ1Byb2pDZW50ZXJMb25nR2VvS2V5JyxcbiAgMzA4OTogJ1Byb2pDZW50ZXJMYXRHZW9LZXknLFxuICAzMDkwOiAnUHJvakNlbnRlckVhc3RpbmdHZW9LZXknLFxuICAzMDkxOiAnUHJvakNlbnRlck5vcnRoaW5nR2VvS2V5JyxcbiAgMzA5MjogJ1Byb2pTY2FsZUF0TmF0T3JpZ2luR2VvS2V5JyxcbiAgMzA5MzogJ1Byb2pTY2FsZUF0Q2VudGVyR2VvS2V5JyxcbiAgMzA5NDogJ1Byb2pBemltdXRoQW5nbGVHZW9LZXknLFxuICAzMDk1OiAnUHJvalN0cmFpZ2h0VmVydFBvbGVMb25nR2VvS2V5JyxcbiAgMzA5NjogJ1Byb2pSZWN0aWZpZWRHcmlkQW5nbGVHZW9LZXknLFxuICA0MDk2OiAnVmVydGljYWxDU1R5cGVHZW9LZXknLFxuICA0MDk3OiAnVmVydGljYWxDaXRhdGlvbkdlb0tleScsXG4gIDQwOTg6ICdWZXJ0aWNhbERhdHVtR2VvS2V5JyxcbiAgNDA5OTogJ1ZlcnRpY2FsVW5pdHNHZW9LZXknLFxufTtcblxuZXhwb3J0IGNvbnN0IGdlb0tleXMgPSB7fTtcbmZvciAoY29uc3Qga2V5IGluIGdlb0tleU5hbWVzKSB7XG4gIGlmIChnZW9LZXlOYW1lcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgZ2VvS2V5c1tnZW9LZXlOYW1lc1trZXldXSA9IHBhcnNlSW50KGtleSwgMTApO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/globals.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/logging.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/dist-module/logging.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   debug: function() { return /* binding */ debug; },\n/* harmony export */   error: function() { return /* binding */ error; },\n/* harmony export */   info: function() { return /* binding */ info; },\n/* harmony export */   log: function() { return /* binding */ log; },\n/* harmony export */   setLogger: function() { return /* binding */ setLogger; },\n/* harmony export */   time: function() { return /* binding */ time; },\n/* harmony export */   timeEnd: function() { return /* binding */ timeEnd; },\n/* harmony export */   warn: function() { return /* binding */ warn; }\n/* harmony export */ });\n/**\n * A no-op logger\n */\nclass DummyLogger {\n  log() {}\n\n  debug() {}\n\n  info() {}\n\n  warn() {}\n\n  error() {}\n\n  time() {}\n\n  timeEnd() {}\n}\n\nlet LOGGER = new DummyLogger();\n\n/**\n *\n * @param {object} logger the new logger. e.g `console`\n */\nfunction setLogger(logger = new DummyLogger()) {\n  LOGGER = logger;\n}\n\nfunction debug(...args) {\n  return LOGGER.debug(...args);\n}\n\nfunction log(...args) {\n  return LOGGER.log(...args);\n}\n\nfunction info(...args) {\n  return LOGGER.info(...args);\n}\n\nfunction warn(...args) {\n  return LOGGER.warn(...args);\n}\n\nfunction error(...args) {\n  return LOGGER.error(...args);\n}\n\nfunction time(...args) {\n  return LOGGER.time(...args);\n}\n\nfunction timeEnd(...args) {\n  return LOGGER.timeEnd(...args);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2xvZ2dpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvbG9nZ2luZy5qcz83YWQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBuby1vcCBsb2dnZXJcbiAqL1xuY2xhc3MgRHVtbXlMb2dnZXIge1xuICBsb2coKSB7fVxuXG4gIGRlYnVnKCkge31cblxuICBpbmZvKCkge31cblxuICB3YXJuKCkge31cblxuICBlcnJvcigpIHt9XG5cbiAgdGltZSgpIHt9XG5cbiAgdGltZUVuZCgpIHt9XG59XG5cbmxldCBMT0dHRVIgPSBuZXcgRHVtbXlMb2dnZXIoKTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGxvZ2dlciB0aGUgbmV3IGxvZ2dlci4gZS5nIGBjb25zb2xlYFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0TG9nZ2VyKGxvZ2dlciA9IG5ldyBEdW1teUxvZ2dlcigpKSB7XG4gIExPR0dFUiA9IGxvZ2dlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIExPR0dFUi5kZWJ1ZyguLi5hcmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZyguLi5hcmdzKSB7XG4gIHJldHVybiBMT0dHRVIubG9nKC4uLmFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5mbyguLi5hcmdzKSB7XG4gIHJldHVybiBMT0dHRVIuaW5mbyguLi5hcmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdhcm4oLi4uYXJncykge1xuICByZXR1cm4gTE9HR0VSLndhcm4oLi4uYXJncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcnJvciguLi5hcmdzKSB7XG4gIHJldHVybiBMT0dHRVIuZXJyb3IoLi4uYXJncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIExPR0dFUi50aW1lKC4uLmFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZUVuZCguLi5hcmdzKSB7XG4gIHJldHVybiBMT0dHRVIudGltZUVuZCguLi5hcmdzKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/logging.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/pool.js":
/*!**************************************************!*\
  !*** ./node_modules/geotiff/dist-module/pool.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _compression_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compression/index.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/compression/index.js\");\n\n\nconst defaultPoolSize = typeof navigator !== 'undefined' ? (navigator.hardwareConcurrency || 2) : 2;\n\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\nclass Pool {\n  /**\n   * @constructor\n   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.\n   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`\n   * function is expected to return a `Worker` compatible with Web Workers. For code that\n   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.\n   *\n   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:\n   * ```js\n   * import { addDecoder, getDecoder } from 'geotiff';\n   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));\n   * self.addEventListener('message', async (e) => {\n   *   const { id, fileDirectory, buffer } = e.data;\n   *   const decoder = await getDecoder(fileDirectory);\n   *   const decoded = await decoder.decode(fileDirectory, buffer);\n   *   self.postMessage({ decoded, id }, [decoded]);\n   * });\n   * ```\n   * The way the above code is built into a worker by the `createWorker()` function\n   * depends on the used bundler. For most bundlers, something like this will work:\n   * ```js\n   * function createWorker() {\n   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));\n   * }\n   * ```\n   */\n  constructor(size = defaultPoolSize, createWorker) {\n    this.workers = null;\n    this._awaitingDecoder = null;\n    this.size = size;\n    this.messageId = 0;\n    if (size) {\n      this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise((resolve) => {\n        __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_geotiff_dist-module_worker_decoder_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./worker/decoder.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/worker/decoder.js\")).then((module) => {\n          resolve(module.create);\n        });\n      });\n      this._awaitingDecoder.then((create) => {\n        this._awaitingDecoder = null;\n        this.workers = [];\n        for (let i = 0; i < size; i++) {\n          this.workers.push({ worker: create(), idle: true });\n        }\n      });\n    }\n  }\n\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`\n   */\n  async decode(fileDirectory, buffer) {\n    if (this._awaitingDecoder) {\n      await this._awaitingDecoder;\n    }\n    return this.size === 0\n      ? (0,_compression_index_js__WEBPACK_IMPORTED_MODULE_0__.getDecoder)(fileDirectory).then((decoder) => decoder.decode(fileDirectory, buffer))\n      : new Promise((resolve) => {\n        const worker = this.workers.find((candidate) => candidate.idle)\n          || this.workers[Math.floor(Math.random() * this.size)];\n        worker.idle = false;\n        const id = this.messageId++;\n        const onMessage = (e) => {\n          if (e.data.id === id) {\n            worker.idle = true;\n            resolve(e.data.decoded);\n            worker.worker.removeEventListener('message', onMessage);\n          }\n        };\n        worker.worker.addEventListener('message', onMessage);\n        worker.worker.postMessage({ fileDirectory, buffer, id }, [buffer]);\n      });\n  }\n\n  destroy() {\n    if (this.workers) {\n      this.workers.forEach((worker) => {\n        worker.worker.terminate();\n      });\n      this.workers = null;\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Pool);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3Bvb2wuanMiLCJtYXBwaW5ncyI6Ijs7QUFBb0Q7O0FBRXBEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5UUFBNkI7QUFDckM7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDLDhCQUE4Qiw4QkFBOEI7QUFDNUQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMkJBQTJCO0FBQy9ELE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrREFBZSxJQUFJLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvcG9vbC5qcz9kNzllIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldERlY29kZXIgfSBmcm9tICcuL2NvbXByZXNzaW9uL2luZGV4LmpzJztcblxuY29uc3QgZGVmYXVsdFBvb2xTaXplID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyAobmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kgfHwgMikgOiAyO1xuXG4vKipcbiAqIEBtb2R1bGUgcG9vbFxuICovXG5cbi8qKlxuICogUG9vbCBmb3Igd29ya2VycyB0byBkZWNvZGUgY2h1bmtzIG9mIHRoZSBpbWFnZXMuXG4gKi9cbmNsYXNzIFBvb2wge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbc2l6ZV0gVGhlIHNpemUgb2YgdGhlIHBvb2wuIERlZmF1bHRzIHRvIHRoZSBudW1iZXIgb2YgQ1BVc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGUuIFdoZW4gdGhpcyBwYXJhbWV0ZXIgaXMgYG51bGxgIG9yIDAsIHRoZW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGRlY29kaW5nIHdpbGwgYmUgZG9uZSBpbiB0aGUgbWFpbiB0aHJlYWQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogV29ya2VyfSBbY3JlYXRlV29ya2VyXSBBIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGUgZGVjb2RlciB3b3JrZXIuXG4gICAqIERlZmF1bHRzIHRvIGEgd29ya2VyIHdpdGggYWxsIGRlY29kZXJzIHRoYXQgc2hpcCB3aXRoIGdlb3RpZmYuanMuIFRoZSBgY3JlYXRlV29ya2VyKClgXG4gICAqIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhIGBXb3JrZXJgIGNvbXBhdGlibGUgd2l0aCBXZWIgV29ya2Vycy4gRm9yIGNvZGUgdGhhdFxuICAgKiBydW5zIGluIE5vZGUsIFt3ZWItd29ya2VyXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS93ZWItd29ya2VyKSBpcyBhIGdvb2QgY2hvaWNlLlxuICAgKlxuICAgKiBBIHdvcmtlciB0aGF0IHVzZXMgYSBjdXN0b20gbHp3IGRlY29kZXIgd291bGQgbG9vayBsaWtlIHRoaXMgYG15LWN1c3RvbS13b3JrZXIuanNgIGZpbGU6XG4gICAqIGBgYGpzXG4gICAqIGltcG9ydCB7IGFkZERlY29kZXIsIGdldERlY29kZXIgfSBmcm9tICdnZW90aWZmJztcbiAgICogYWRkRGVjb2Rlcig1LCAoKSA9PiBpbXBvcnQgKCcuL215LWN1c3RvbS1sencnKS50aGVuKChtKSA9PiBtLmRlZmF1bHQpKTtcbiAgICogc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgYXN5bmMgKGUpID0+IHtcbiAgICogICBjb25zdCB7IGlkLCBmaWxlRGlyZWN0b3J5LCBidWZmZXIgfSA9IGUuZGF0YTtcbiAgICogICBjb25zdCBkZWNvZGVyID0gYXdhaXQgZ2V0RGVjb2RlcihmaWxlRGlyZWN0b3J5KTtcbiAgICogICBjb25zdCBkZWNvZGVkID0gYXdhaXQgZGVjb2Rlci5kZWNvZGUoZmlsZURpcmVjdG9yeSwgYnVmZmVyKTtcbiAgICogICBzZWxmLnBvc3RNZXNzYWdlKHsgZGVjb2RlZCwgaWQgfSwgW2RlY29kZWRdKTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBUaGUgd2F5IHRoZSBhYm92ZSBjb2RlIGlzIGJ1aWx0IGludG8gYSB3b3JrZXIgYnkgdGhlIGBjcmVhdGVXb3JrZXIoKWAgZnVuY3Rpb25cbiAgICogZGVwZW5kcyBvbiB0aGUgdXNlZCBidW5kbGVyLiBGb3IgbW9zdCBidW5kbGVycywgc29tZXRoaW5nIGxpa2UgdGhpcyB3aWxsIHdvcms6XG4gICAqIGBgYGpzXG4gICAqIGZ1bmN0aW9uIGNyZWF0ZVdvcmtlcigpIHtcbiAgICogICByZXR1cm4gbmV3IFdvcmtlcihuZXcgVVJMKCcuL215LWN1c3RvbS13b3JrZXIuanMnLCBpbXBvcnQubWV0YS51cmwpKTtcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNpemUgPSBkZWZhdWx0UG9vbFNpemUsIGNyZWF0ZVdvcmtlcikge1xuICAgIHRoaXMud29ya2VycyA9IG51bGw7XG4gICAgdGhpcy5fYXdhaXRpbmdEZWNvZGVyID0gbnVsbDtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMubWVzc2FnZUlkID0gMDtcbiAgICBpZiAoc2l6ZSkge1xuICAgICAgdGhpcy5fYXdhaXRpbmdEZWNvZGVyID0gY3JlYXRlV29ya2VyID8gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZVdvcmtlcikgOiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBpbXBvcnQoJy4vd29ya2VyL2RlY29kZXIuanMnKS50aGVuKChtb2R1bGUpID0+IHtcbiAgICAgICAgICByZXNvbHZlKG1vZHVsZS5jcmVhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fYXdhaXRpbmdEZWNvZGVyLnRoZW4oKGNyZWF0ZSkgPT4ge1xuICAgICAgICB0aGlzLl9hd2FpdGluZ0RlY29kZXIgPSBudWxsO1xuICAgICAgICB0aGlzLndvcmtlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICB0aGlzLndvcmtlcnMucHVzaCh7IHdvcmtlcjogY3JlYXRlKCksIGlkbGU6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgdGhlIGdpdmVuIGJsb2NrIG9mIGJ5dGVzIHdpdGggdGhlIHNldCBjb21wcmVzc2lvbiBtZXRob2QuXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciB0aGUgYXJyYXkgYnVmZmVyIG9mIGJ5dGVzIHRvIGRlY29kZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXlCdWZmZXI+fSB0aGUgZGVjb2RlZCByZXN1bHQgYXMgYSBgUHJvbWlzZWBcbiAgICovXG4gIGFzeW5jIGRlY29kZShmaWxlRGlyZWN0b3J5LCBidWZmZXIpIHtcbiAgICBpZiAodGhpcy5fYXdhaXRpbmdEZWNvZGVyKSB7XG4gICAgICBhd2FpdCB0aGlzLl9hd2FpdGluZ0RlY29kZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNpemUgPT09IDBcbiAgICAgID8gZ2V0RGVjb2RlcihmaWxlRGlyZWN0b3J5KS50aGVuKChkZWNvZGVyKSA9PiBkZWNvZGVyLmRlY29kZShmaWxlRGlyZWN0b3J5LCBidWZmZXIpKVxuICAgICAgOiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBjb25zdCB3b3JrZXIgPSB0aGlzLndvcmtlcnMuZmluZCgoY2FuZGlkYXRlKSA9PiBjYW5kaWRhdGUuaWRsZSlcbiAgICAgICAgICB8fCB0aGlzLndvcmtlcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5zaXplKV07XG4gICAgICAgIHdvcmtlci5pZGxlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5tZXNzYWdlSWQrKztcbiAgICAgICAgY29uc3Qgb25NZXNzYWdlID0gKGUpID0+IHtcbiAgICAgICAgICBpZiAoZS5kYXRhLmlkID09PSBpZCkge1xuICAgICAgICAgICAgd29ya2VyLmlkbGUgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZShlLmRhdGEuZGVjb2RlZCk7XG4gICAgICAgICAgICB3b3JrZXIud29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd29ya2VyLndvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25NZXNzYWdlKTtcbiAgICAgICAgd29ya2VyLndvcmtlci5wb3N0TWVzc2FnZSh7IGZpbGVEaXJlY3RvcnksIGJ1ZmZlciwgaWQgfSwgW2J1ZmZlcl0pO1xuICAgICAgfSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLndvcmtlcnMpIHtcbiAgICAgIHRoaXMud29ya2Vycy5mb3JFYWNoKCh3b3JrZXIpID0+IHtcbiAgICAgICAgd29ya2VyLndvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy53b3JrZXJzID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9vbDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/pool.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/predictor.js":
/*!*******************************************************!*\
  !*** ./node_modules/geotiff/dist-module/predictor.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyPredictor: function() { return /* binding */ applyPredictor; }\n/* harmony export */ });\nfunction decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n    }\n  }\n}\n\nfunction applyPredictor(block, predictor, width, height, bitsPerSample,\n  planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) { // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n          );\n          break;\n        case 16:\n          row = new Uint16Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\n          );\n          break;\n        case 32:\n          row = new Uint32Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\n          );\n          break;\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) { // horizontal floating point\n      row = new Uint8Array(\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n      );\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3ByZWRpY3Rvci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsa0JBQWtCO0FBQzVFO0FBQ0E7QUFDQSxNQUFNLDRCQUE0QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3ByZWRpY3Rvci5qcz9iNTdlIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGRlY29kZVJvd0FjYyhyb3csIHN0cmlkZSkge1xuICBsZXQgbGVuZ3RoID0gcm93Lmxlbmd0aCAtIHN0cmlkZTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGRvIHtcbiAgICBmb3IgKGxldCBpID0gc3RyaWRlOyBpID4gMDsgaS0tKSB7XG4gICAgICByb3dbb2Zmc2V0ICsgc3RyaWRlXSArPSByb3dbb2Zmc2V0XTtcbiAgICAgIG9mZnNldCsrO1xuICAgIH1cblxuICAgIGxlbmd0aCAtPSBzdHJpZGU7XG4gIH0gd2hpbGUgKGxlbmd0aCA+IDApO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVSb3dGbG9hdGluZ1BvaW50KHJvdywgc3RyaWRlLCBieXRlc1BlclNhbXBsZSkge1xuICBsZXQgaW5kZXggPSAwO1xuICBsZXQgY291bnQgPSByb3cubGVuZ3RoO1xuICBjb25zdCB3YyA9IGNvdW50IC8gYnl0ZXNQZXJTYW1wbGU7XG5cbiAgd2hpbGUgKGNvdW50ID4gc3RyaWRlKSB7XG4gICAgZm9yIChsZXQgaSA9IHN0cmlkZTsgaSA+IDA7IC0taSkge1xuICAgICAgcm93W2luZGV4ICsgc3RyaWRlXSArPSByb3dbaW5kZXhdO1xuICAgICAgKytpbmRleDtcbiAgICB9XG4gICAgY291bnQgLT0gc3RyaWRlO1xuICB9XG5cbiAgY29uc3QgY29weSA9IHJvdy5zbGljZSgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHdjOyArK2kpIHtcbiAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJ5dGVzUGVyU2FtcGxlOyArK2IpIHtcbiAgICAgIHJvd1soYnl0ZXNQZXJTYW1wbGUgKiBpKSArIGJdID0gY29weVsoKGJ5dGVzUGVyU2FtcGxlIC0gYiAtIDEpICogd2MpICsgaV07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVByZWRpY3RvcihibG9jaywgcHJlZGljdG9yLCB3aWR0aCwgaGVpZ2h0LCBiaXRzUGVyU2FtcGxlLFxuICBwbGFuYXJDb25maWd1cmF0aW9uKSB7XG4gIGlmICghcHJlZGljdG9yIHx8IHByZWRpY3RvciA9PT0gMSkge1xuICAgIHJldHVybiBibG9jaztcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYml0c1BlclNhbXBsZS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChiaXRzUGVyU2FtcGxlW2ldICUgOCAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaGVuIGRlY29kaW5nIHdpdGggcHJlZGljdG9yLCBvbmx5IG11bHRpcGxlIG9mIDggYml0cyBhcmUgc3VwcG9ydGVkLicpO1xuICAgIH1cbiAgICBpZiAoYml0c1BlclNhbXBsZVtpXSAhPT0gYml0c1BlclNhbXBsZVswXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaGVuIGRlY29kaW5nIHdpdGggcHJlZGljdG9yLCBhbGwgc2FtcGxlcyBtdXN0IGhhdmUgdGhlIHNhbWUgc2l6ZS4nKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBieXRlc1BlclNhbXBsZSA9IGJpdHNQZXJTYW1wbGVbMF0gLyA4O1xuICBjb25zdCBzdHJpZGUgPSBwbGFuYXJDb25maWd1cmF0aW9uID09PSAyID8gMSA6IGJpdHNQZXJTYW1wbGUubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyArK2kpIHtcbiAgICAvLyBMYXN0IHN0cmlwIHdpbGwgYmUgdHJ1bmNhdGVkIGlmIGhlaWdodCAlIHN0cmlwSGVpZ2h0ICE9IDBcbiAgICBpZiAoaSAqIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUgPj0gYmxvY2suYnl0ZUxlbmd0aCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCByb3c7XG4gICAgaWYgKHByZWRpY3RvciA9PT0gMikgeyAvLyBob3Jpem9udGFsIHByZWRpY3Rpb25cbiAgICAgIHN3aXRjaCAoYml0c1BlclNhbXBsZVswXSkge1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgcm93ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICBibG9jaywgaSAqIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUsIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICByb3cgPSBuZXcgVWludDE2QXJyYXkoXG4gICAgICAgICAgICBibG9jaywgaSAqIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUsIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUgLyAyLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgcm93ID0gbmV3IFVpbnQzMkFycmF5KFxuICAgICAgICAgICAgYmxvY2ssIGkgKiBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlLCBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlIC8gNCxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJlZGljdG9yIDIgbm90IGFsbG93ZWQgd2l0aCAke2JpdHNQZXJTYW1wbGVbMF19IGJpdHMgcGVyIHNhbXBsZS5gKTtcbiAgICAgIH1cbiAgICAgIGRlY29kZVJvd0FjYyhyb3csIHN0cmlkZSwgYnl0ZXNQZXJTYW1wbGUpO1xuICAgIH0gZWxzZSBpZiAocHJlZGljdG9yID09PSAzKSB7IC8vIGhvcml6b250YWwgZmxvYXRpbmcgcG9pbnRcbiAgICAgIHJvdyA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgICBibG9jaywgaSAqIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUsIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUsXG4gICAgICApO1xuICAgICAgZGVjb2RlUm93RmxvYXRpbmdQb2ludChyb3csIHN0cmlkZSwgYnl0ZXNQZXJTYW1wbGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmxvY2s7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/predictor.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/resample.js":
/*!******************************************************!*\
  !*** ./node_modules/geotiff/dist-module/resample.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   resample: function() { return /* binding */ resample; },\n/* harmony export */   resampleBilinear: function() { return /* binding */ resampleBilinear; },\n/* harmony export */   resampleBilinearInterleaved: function() { return /* binding */ resampleBilinearInterleaved; },\n/* harmony export */   resampleInterleaved: function() { return /* binding */ resampleInterleaved; },\n/* harmony export */   resampleNearest: function() { return /* binding */ resampleNearest; },\n/* harmony export */   resampleNearestInterleaved: function() { return /* binding */ resampleNearestInterleaved; }\n/* harmony export */ });\n/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nfunction resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nfunction resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nfunction resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nfunction resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nfunction resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nfunction resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3Jlc2FtcGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxjQUFjO0FBQzNCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxjQUFjO0FBQzNCO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQzs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsY0FBYztBQUMzQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsT0FBTztBQUNoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQzs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFlBQVk7QUFDekI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsT0FBTztBQUNoRTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3Jlc2FtcGxlLmpzP2YzNTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIHJlc2FtcGxlXG4gKi9cblxuZnVuY3Rpb24gY29weU5ld1NpemUoYXJyYXksIHdpZHRoLCBoZWlnaHQsIHNhbXBsZXNQZXJQaXhlbCA9IDEpIHtcbiAgcmV0dXJuIG5ldyAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGFycmF5KS5jb25zdHJ1Y3Rvcikod2lkdGggKiBoZWlnaHQgKiBzYW1wbGVzUGVyUGl4ZWwpO1xufVxuXG4vKipcbiAqIFJlc2FtcGxlIHRoZSBpbnB1dCBhcnJheXMgdXNpbmcgbmVhcmVzdCBuZWlnaGJvciB2YWx1ZSBzZWxlY3Rpb24uXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXlbXX0gdmFsdWVBcnJheXMgVGhlIGlucHV0IGFycmF5cyB0byByZXNhbXBsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluV2lkdGggVGhlIHdpZHRoIG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5IZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dFdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dEhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcmV0dXJucyB7VHlwZWRBcnJheVtdfSBUaGUgcmVzYW1wbGVkIHJhc3RlcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2FtcGxlTmVhcmVzdCh2YWx1ZUFycmF5cywgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQpIHtcbiAgY29uc3QgcmVsWCA9IGluV2lkdGggLyBvdXRXaWR0aDtcbiAgY29uc3QgcmVsWSA9IGluSGVpZ2h0IC8gb3V0SGVpZ2h0O1xuICByZXR1cm4gdmFsdWVBcnJheXMubWFwKChhcnJheSkgPT4ge1xuICAgIGNvbnN0IG5ld0FycmF5ID0gY29weU5ld1NpemUoYXJyYXksIG91dFdpZHRoLCBvdXRIZWlnaHQpO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0SGVpZ2h0OyArK3kpIHtcbiAgICAgIGNvbnN0IGN5ID0gTWF0aC5taW4oTWF0aC5yb3VuZChyZWxZICogeSksIGluSGVpZ2h0IC0gMSk7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dFdpZHRoOyArK3gpIHtcbiAgICAgICAgY29uc3QgY3ggPSBNYXRoLm1pbihNYXRoLnJvdW5kKHJlbFggKiB4KSwgaW5XaWR0aCAtIDEpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFycmF5WyhjeSAqIGluV2lkdGgpICsgY3hdO1xuICAgICAgICBuZXdBcnJheVsoeSAqIG91dFdpZHRoKSArIHhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfSk7XG59XG5cbi8vIHNpbXBsZSBsaW5lYXIgaW50ZXJwb2xhdGlvbiwgY29kZSBmcm9tOlxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2ludGVycG9sYXRpb24jUHJvZ3JhbW1pbmdfbGFuZ3VhZ2Vfc3VwcG9ydFxuZnVuY3Rpb24gbGVycCh2MCwgdjEsIHQpIHtcbiAgcmV0dXJuICgoMSAtIHQpICogdjApICsgKHQgKiB2MSk7XG59XG5cbi8qKlxuICogUmVzYW1wbGUgdGhlIGlucHV0IGFycmF5cyB1c2luZyBiaWxpbmVhciBpbnRlcnBvbGF0aW9uLlxuICogQHBhcmFtIHtUeXBlZEFycmF5W119IHZhbHVlQXJyYXlzIFRoZSBpbnB1dCBhcnJheXMgdG8gcmVzYW1wbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbldpZHRoIFRoZSB3aWR0aCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IGluSGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGlucHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRXaWR0aCBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgb3V0cHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRIZWlnaHQgVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHJldHVybnMge1R5cGVkQXJyYXlbXX0gVGhlIHJlc2FtcGxlZCByYXN0ZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNhbXBsZUJpbGluZWFyKHZhbHVlQXJyYXlzLCBpbldpZHRoLCBpbkhlaWdodCwgb3V0V2lkdGgsIG91dEhlaWdodCkge1xuICBjb25zdCByZWxYID0gaW5XaWR0aCAvIG91dFdpZHRoO1xuICBjb25zdCByZWxZID0gaW5IZWlnaHQgLyBvdXRIZWlnaHQ7XG5cbiAgcmV0dXJuIHZhbHVlQXJyYXlzLm1hcCgoYXJyYXkpID0+IHtcbiAgICBjb25zdCBuZXdBcnJheSA9IGNvcHlOZXdTaXplKGFycmF5LCBvdXRXaWR0aCwgb3V0SGVpZ2h0KTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IG91dEhlaWdodDsgKyt5KSB7XG4gICAgICBjb25zdCByYXdZID0gcmVsWSAqIHk7XG5cbiAgICAgIGNvbnN0IHlsID0gTWF0aC5mbG9vcihyYXdZKTtcbiAgICAgIGNvbnN0IHloID0gTWF0aC5taW4oTWF0aC5jZWlsKHJhd1kpLCAoaW5IZWlnaHQgLSAxKSk7XG5cbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0V2lkdGg7ICsreCkge1xuICAgICAgICBjb25zdCByYXdYID0gcmVsWCAqIHg7XG4gICAgICAgIGNvbnN0IHR4ID0gcmF3WCAlIDE7XG5cbiAgICAgICAgY29uc3QgeGwgPSBNYXRoLmZsb29yKHJhd1gpO1xuICAgICAgICBjb25zdCB4aCA9IE1hdGgubWluKE1hdGguY2VpbChyYXdYKSwgKGluV2lkdGggLSAxKSk7XG5cbiAgICAgICAgY29uc3QgbGwgPSBhcnJheVsoeWwgKiBpbldpZHRoKSArIHhsXTtcbiAgICAgICAgY29uc3QgaGwgPSBhcnJheVsoeWwgKiBpbldpZHRoKSArIHhoXTtcbiAgICAgICAgY29uc3QgbGggPSBhcnJheVsoeWggKiBpbldpZHRoKSArIHhsXTtcbiAgICAgICAgY29uc3QgaGggPSBhcnJheVsoeWggKiBpbldpZHRoKSArIHhoXTtcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IGxlcnAoXG4gICAgICAgICAgbGVycChsbCwgaGwsIHR4KSxcbiAgICAgICAgICBsZXJwKGxoLCBoaCwgdHgpLFxuICAgICAgICAgIHJhd1kgJSAxLFxuICAgICAgICApO1xuICAgICAgICBuZXdBcnJheVsoeSAqIG91dFdpZHRoKSArIHhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfSk7XG59XG5cbi8qKlxuICogUmVzYW1wbGUgdGhlIGlucHV0IGFycmF5cyB1c2luZyB0aGUgc2VsZWN0ZWQgcmVzYW1wbGluZyBtZXRob2QuXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXlbXX0gdmFsdWVBcnJheXMgVGhlIGlucHV0IGFycmF5cyB0byByZXNhbXBsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluV2lkdGggVGhlIHdpZHRoIG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5IZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dFdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dEhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gW21ldGhvZCA9ICduZWFyZXN0J10gVGhlIGRlc2lyZWQgcmVzYW1wbGluZyBtZXRob2RcbiAqIEByZXR1cm5zIHtUeXBlZEFycmF5W119IFRoZSByZXNhbXBsZWQgcmFzdGVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzYW1wbGUodmFsdWVBcnJheXMsIGluV2lkdGgsIGluSGVpZ2h0LCBvdXRXaWR0aCwgb3V0SGVpZ2h0LCBtZXRob2QgPSAnbmVhcmVzdCcpIHtcbiAgc3dpdGNoIChtZXRob2QudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ25lYXJlc3QnOlxuICAgICAgcmV0dXJuIHJlc2FtcGxlTmVhcmVzdCh2YWx1ZUFycmF5cywgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQpO1xuICAgIGNhc2UgJ2JpbGluZWFyJzpcbiAgICBjYXNlICdsaW5lYXInOlxuICAgICAgcmV0dXJuIHJlc2FtcGxlQmlsaW5lYXIodmFsdWVBcnJheXMsIGluV2lkdGgsIGluSGVpZ2h0LCBvdXRXaWR0aCwgb3V0SGVpZ2h0KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCByZXNhbXBsaW5nIG1ldGhvZDogJyR7bWV0aG9kfSdgKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlc2FtcGxlIHRoZSBwaXhlbCBpbnRlcmxlYXZlZCBpbnB1dCBhcnJheSB1c2luZyBuZWFyZXN0IG5laWdoYm9yIHZhbHVlIHNlbGVjdGlvbi5cbiAqIEBwYXJhbSB7VHlwZWRBcnJheX0gdmFsdWVBcnJheXMgVGhlIGlucHV0IGFycmF5cyB0byByZXNhbXBsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluV2lkdGggVGhlIHdpZHRoIG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5IZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dFdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dEhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gc2FtcGxlcyBUaGUgbnVtYmVyIG9mIHNhbXBsZXMgcGVyIHBpeGVsIGZvciBwaXhlbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJsZWF2ZWQgZGF0YVxuICogQHJldHVybnMge1R5cGVkQXJyYXl9IFRoZSByZXNhbXBsZWQgcmFzdGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNhbXBsZU5lYXJlc3RJbnRlcmxlYXZlZChcbiAgdmFsdWVBcnJheSwgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQsIHNhbXBsZXMpIHtcbiAgY29uc3QgcmVsWCA9IGluV2lkdGggLyBvdXRXaWR0aDtcbiAgY29uc3QgcmVsWSA9IGluSGVpZ2h0IC8gb3V0SGVpZ2h0O1xuXG4gIGNvbnN0IG5ld0FycmF5ID0gY29weU5ld1NpemUodmFsdWVBcnJheSwgb3V0V2lkdGgsIG91dEhlaWdodCwgc2FtcGxlcyk7XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0SGVpZ2h0OyArK3kpIHtcbiAgICBjb25zdCBjeSA9IE1hdGgubWluKE1hdGgucm91bmQocmVsWSAqIHkpLCBpbkhlaWdodCAtIDEpO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0V2lkdGg7ICsreCkge1xuICAgICAgY29uc3QgY3ggPSBNYXRoLm1pbihNYXRoLnJvdW5kKHJlbFggKiB4KSwgaW5XaWR0aCAtIDEpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzOyArK2kpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZUFycmF5WyhjeSAqIGluV2lkdGggKiBzYW1wbGVzKSArIChjeCAqIHNhbXBsZXMpICsgaV07XG4gICAgICAgIG5ld0FycmF5Wyh5ICogb3V0V2lkdGggKiBzYW1wbGVzKSArICh4ICogc2FtcGxlcykgKyBpXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3QXJyYXk7XG59XG5cbi8qKlxuICogUmVzYW1wbGUgdGhlIHBpeGVsIGludGVybGVhdmVkIGlucHV0IGFycmF5IHVzaW5nIGJpbGluZWFyIGludGVycG9sYXRpb24uXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXl9IHZhbHVlQXJyYXlzIFRoZSBpbnB1dCBhcnJheXMgdG8gcmVzYW1wbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbldpZHRoIFRoZSB3aWR0aCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IGluSGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGlucHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRXaWR0aCBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgb3V0cHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRIZWlnaHQgVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IHNhbXBsZXMgVGhlIG51bWJlciBvZiBzYW1wbGVzIHBlciBwaXhlbCBmb3IgcGl4ZWxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybGVhdmVkIGRhdGFcbiAqIEByZXR1cm5zIHtUeXBlZEFycmF5fSBUaGUgcmVzYW1wbGVkIHJhc3RlclxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzYW1wbGVCaWxpbmVhckludGVybGVhdmVkKFxuICB2YWx1ZUFycmF5LCBpbldpZHRoLCBpbkhlaWdodCwgb3V0V2lkdGgsIG91dEhlaWdodCwgc2FtcGxlcykge1xuICBjb25zdCByZWxYID0gaW5XaWR0aCAvIG91dFdpZHRoO1xuICBjb25zdCByZWxZID0gaW5IZWlnaHQgLyBvdXRIZWlnaHQ7XG4gIGNvbnN0IG5ld0FycmF5ID0gY29weU5ld1NpemUodmFsdWVBcnJheSwgb3V0V2lkdGgsIG91dEhlaWdodCwgc2FtcGxlcyk7XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0SGVpZ2h0OyArK3kpIHtcbiAgICBjb25zdCByYXdZID0gcmVsWSAqIHk7XG5cbiAgICBjb25zdCB5bCA9IE1hdGguZmxvb3IocmF3WSk7XG4gICAgY29uc3QgeWggPSBNYXRoLm1pbihNYXRoLmNlaWwocmF3WSksIChpbkhlaWdodCAtIDEpKTtcblxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0V2lkdGg7ICsreCkge1xuICAgICAgY29uc3QgcmF3WCA9IHJlbFggKiB4O1xuICAgICAgY29uc3QgdHggPSByYXdYICUgMTtcblxuICAgICAgY29uc3QgeGwgPSBNYXRoLmZsb29yKHJhd1gpO1xuICAgICAgY29uc3QgeGggPSBNYXRoLm1pbihNYXRoLmNlaWwocmF3WCksIChpbldpZHRoIC0gMSkpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXM7ICsraSkge1xuICAgICAgICBjb25zdCBsbCA9IHZhbHVlQXJyYXlbKHlsICogaW5XaWR0aCAqIHNhbXBsZXMpICsgKHhsICogc2FtcGxlcykgKyBpXTtcbiAgICAgICAgY29uc3QgaGwgPSB2YWx1ZUFycmF5Wyh5bCAqIGluV2lkdGggKiBzYW1wbGVzKSArICh4aCAqIHNhbXBsZXMpICsgaV07XG4gICAgICAgIGNvbnN0IGxoID0gdmFsdWVBcnJheVsoeWggKiBpbldpZHRoICogc2FtcGxlcykgKyAoeGwgKiBzYW1wbGVzKSArIGldO1xuICAgICAgICBjb25zdCBoaCA9IHZhbHVlQXJyYXlbKHloICogaW5XaWR0aCAqIHNhbXBsZXMpICsgKHhoICogc2FtcGxlcykgKyBpXTtcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IGxlcnAoXG4gICAgICAgICAgbGVycChsbCwgaGwsIHR4KSxcbiAgICAgICAgICBsZXJwKGxoLCBoaCwgdHgpLFxuICAgICAgICAgIHJhd1kgJSAxLFxuICAgICAgICApO1xuICAgICAgICBuZXdBcnJheVsoeSAqIG91dFdpZHRoICogc2FtcGxlcykgKyAoeCAqIHNhbXBsZXMpICsgaV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld0FycmF5O1xufVxuXG4vKipcbiAqIFJlc2FtcGxlIHRoZSBwaXhlbCBpbnRlcmxlYXZlZCBpbnB1dCBhcnJheSB1c2luZyB0aGUgc2VsZWN0ZWQgcmVzYW1wbGluZyBtZXRob2QuXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXl9IHZhbHVlQXJyYXkgVGhlIGlucHV0IGFycmF5IHRvIHJlc2FtcGxlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5XaWR0aCBUaGUgd2lkdGggb2YgdGhlIGlucHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbkhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0V2lkdGggVGhlIGRlc2lyZWQgd2lkdGggb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0SGVpZ2h0IFRoZSBkZXNpcmVkIGhlaWdodCBvZiB0aGUgb3V0cHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzYW1wbGVzIFRoZSBudW1iZXIgb2Ygc2FtcGxlcyBwZXIgcGl4ZWwgZm9yIHBpeGVsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybGVhdmVkIGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0aG9kID0gJ25lYXJlc3QnXSBUaGUgZGVzaXJlZCByZXNhbXBsaW5nIG1ldGhvZFxuICogQHJldHVybnMge1R5cGVkQXJyYXl9IFRoZSByZXNhbXBsZWQgcmFzdGVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzYW1wbGVJbnRlcmxlYXZlZCh2YWx1ZUFycmF5LCBpbldpZHRoLCBpbkhlaWdodCwgb3V0V2lkdGgsIG91dEhlaWdodCwgc2FtcGxlcywgbWV0aG9kID0gJ25lYXJlc3QnKSB7XG4gIHN3aXRjaCAobWV0aG9kLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICduZWFyZXN0JzpcbiAgICAgIHJldHVybiByZXNhbXBsZU5lYXJlc3RJbnRlcmxlYXZlZChcbiAgICAgICAgdmFsdWVBcnJheSwgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQsIHNhbXBsZXMsXG4gICAgICApO1xuICAgIGNhc2UgJ2JpbGluZWFyJzpcbiAgICBjYXNlICdsaW5lYXInOlxuICAgICAgcmV0dXJuIHJlc2FtcGxlQmlsaW5lYXJJbnRlcmxlYXZlZChcbiAgICAgICAgdmFsdWVBcnJheSwgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQsIHNhbXBsZXMsXG4gICAgICApO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHJlc2FtcGxpbmcgbWV0aG9kOiAnJHttZXRob2R9J2ApO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/resample.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/rgb.js":
/*!*************************************************!*\
  !*** ./node_modules/geotiff/dist-module/rgb.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromBlackIsZero: function() { return /* binding */ fromBlackIsZero; },\n/* harmony export */   fromCIELab: function() { return /* binding */ fromCIELab; },\n/* harmony export */   fromCMYK: function() { return /* binding */ fromCMYK; },\n/* harmony export */   fromPalette: function() { return /* binding */ fromPalette; },\n/* harmony export */   fromWhiteIsZero: function() { return /* binding */ fromWhiteIsZero; },\n/* harmony export */   fromYCbCr: function() { return /* binding */ fromYCbCr; }\n/* harmony export */ });\nfunction fromWhiteIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = 256 - (raster[i] / max * 256);\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nfunction fromBlackIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = raster[i] / max * 256;\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nfunction fromPalette(raster, colorMap) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  const greenOffset = colorMap.length / 3;\n  const blueOffset = colorMap.length / 3 * 2;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    const mapIndex = raster[i];\n    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;\n    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;\n    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;\n  }\n  return rgbRaster;\n}\n\nfunction fromCMYK(cmykRaster) {\n  const { width, height } = cmykRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {\n    const c = cmykRaster[i];\n    const m = cmykRaster[i + 1];\n    const y = cmykRaster[i + 2];\n    const k = cmykRaster[i + 3];\n\n    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);\n  }\n  return rgbRaster;\n}\n\nfunction fromYCbCr(yCbCrRaster) {\n  const { width, height } = yCbCrRaster;\n  const rgbRaster = new Uint8ClampedArray(width * height * 3);\n  for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {\n    const y = yCbCrRaster[i];\n    const cb = yCbCrRaster[i + 1];\n    const cr = yCbCrRaster[i + 2];\n\n    rgbRaster[j] = (y + (1.40200 * (cr - 0x80)));\n    rgbRaster[j + 1] = (y - (0.34414 * (cb - 0x80)) - (0.71414 * (cr - 0x80)));\n    rgbRaster[j + 2] = (y + (1.77200 * (cb - 0x80)));\n  }\n  return rgbRaster;\n}\n\nconst Xn = 0.95047;\nconst Yn = 1.00000;\nconst Zn = 1.08883;\n\n// from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n\nfunction fromCIELab(cieLabRaster) {\n  const { width, height } = cieLabRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n\n  for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {\n    const L = cieLabRaster[i + 0];\n    const a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8\n    const b_ = cieLabRaster[i + 2] << 24 >> 24; // same\n\n    let y = (L + 16) / 116;\n    let x = (a_ / 500) + y;\n    let z = y - (b_ / 200);\n    let r;\n    let g;\n    let b;\n\n    x = Xn * ((x * x * x > 0.008856) ? x * x * x : (x - (16 / 116)) / 7.787);\n    y = Yn * ((y * y * y > 0.008856) ? y * y * y : (y - (16 / 116)) / 7.787);\n    z = Zn * ((z * z * z > 0.008856) ? z * z * z : (z - (16 / 116)) / 7.787);\n\n    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n    r = (r > 0.0031308) ? ((1.055 * (r ** (1 / 2.4))) - 0.055) : 12.92 * r;\n    g = (g > 0.0031308) ? ((1.055 * (g ** (1 / 2.4))) - 0.055) : 12.92 * g;\n    b = (b > 0.0031308) ? ((1.055 * (b ** (1 / 2.4))) - 0.055) : 12.92 * b;\n\n    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;\n    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;\n    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;\n  }\n  return rgbRaster;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3JnYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBTztBQUNQLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0EseUJBQXlCLHdCQUF3QjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTztBQUNQLFVBQVUsZ0JBQWdCO0FBQzFCOztBQUVBLHlCQUF5Qix5QkFBeUI7QUFDbEQ7QUFDQSxnREFBZ0Q7QUFDaEQsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3JnYi5qcz9jNDg0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBmcm9tV2hpdGVJc1plcm8ocmFzdGVyLCBtYXgpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSByYXN0ZXI7XG4gIGNvbnN0IHJnYlJhc3RlciA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogMyk7XG4gIGxldCB2YWx1ZTtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgcmFzdGVyLmxlbmd0aDsgKytpLCBqICs9IDMpIHtcbiAgICB2YWx1ZSA9IDI1NiAtIChyYXN0ZXJbaV0gLyBtYXggKiAyNTYpO1xuICAgIHJnYlJhc3RlcltqXSA9IHZhbHVlO1xuICAgIHJnYlJhc3RlcltqICsgMV0gPSB2YWx1ZTtcbiAgICByZ2JSYXN0ZXJbaiArIDJdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJnYlJhc3Rlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21CbGFja0lzWmVybyhyYXN0ZXIsIG1heCkge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHJhc3RlcjtcbiAgY29uc3QgcmdiUmFzdGVyID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiAzKTtcbiAgbGV0IHZhbHVlO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCByYXN0ZXIubGVuZ3RoOyArK2ksIGogKz0gMykge1xuICAgIHZhbHVlID0gcmFzdGVyW2ldIC8gbWF4ICogMjU2O1xuICAgIHJnYlJhc3RlcltqXSA9IHZhbHVlO1xuICAgIHJnYlJhc3RlcltqICsgMV0gPSB2YWx1ZTtcbiAgICByZ2JSYXN0ZXJbaiArIDJdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJnYlJhc3Rlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21QYWxldHRlKHJhc3RlciwgY29sb3JNYXApIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSByYXN0ZXI7XG4gIGNvbnN0IHJnYlJhc3RlciA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogMyk7XG4gIGNvbnN0IGdyZWVuT2Zmc2V0ID0gY29sb3JNYXAubGVuZ3RoIC8gMztcbiAgY29uc3QgYmx1ZU9mZnNldCA9IGNvbG9yTWFwLmxlbmd0aCAvIDMgKiAyO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCByYXN0ZXIubGVuZ3RoOyArK2ksIGogKz0gMykge1xuICAgIGNvbnN0IG1hcEluZGV4ID0gcmFzdGVyW2ldO1xuICAgIHJnYlJhc3RlcltqXSA9IGNvbG9yTWFwW21hcEluZGV4XSAvIDY1NTM2ICogMjU2O1xuICAgIHJnYlJhc3RlcltqICsgMV0gPSBjb2xvck1hcFttYXBJbmRleCArIGdyZWVuT2Zmc2V0XSAvIDY1NTM2ICogMjU2O1xuICAgIHJnYlJhc3RlcltqICsgMl0gPSBjb2xvck1hcFttYXBJbmRleCArIGJsdWVPZmZzZXRdIC8gNjU1MzYgKiAyNTY7XG4gIH1cbiAgcmV0dXJuIHJnYlJhc3Rlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21DTVlLKGNteWtSYXN0ZXIpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjbXlrUmFzdGVyO1xuICBjb25zdCByZ2JSYXN0ZXIgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDMpO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBjbXlrUmFzdGVyLmxlbmd0aDsgaSArPSA0LCBqICs9IDMpIHtcbiAgICBjb25zdCBjID0gY215a1Jhc3RlcltpXTtcbiAgICBjb25zdCBtID0gY215a1Jhc3RlcltpICsgMV07XG4gICAgY29uc3QgeSA9IGNteWtSYXN0ZXJbaSArIDJdO1xuICAgIGNvbnN0IGsgPSBjbXlrUmFzdGVyW2kgKyAzXTtcblxuICAgIHJnYlJhc3RlcltqXSA9IDI1NSAqICgoMjU1IC0gYykgLyAyNTYpICogKCgyNTUgLSBrKSAvIDI1Nik7XG4gICAgcmdiUmFzdGVyW2ogKyAxXSA9IDI1NSAqICgoMjU1IC0gbSkgLyAyNTYpICogKCgyNTUgLSBrKSAvIDI1Nik7XG4gICAgcmdiUmFzdGVyW2ogKyAyXSA9IDI1NSAqICgoMjU1IC0geSkgLyAyNTYpICogKCgyNTUgLSBrKSAvIDI1Nik7XG4gIH1cbiAgcmV0dXJuIHJnYlJhc3Rlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21ZQ2JDcih5Q2JDclJhc3Rlcikge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHlDYkNyUmFzdGVyO1xuICBjb25zdCByZ2JSYXN0ZXIgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiBoZWlnaHQgKiAzKTtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgeUNiQ3JSYXN0ZXIubGVuZ3RoOyBpICs9IDMsIGogKz0gMykge1xuICAgIGNvbnN0IHkgPSB5Q2JDclJhc3RlcltpXTtcbiAgICBjb25zdCBjYiA9IHlDYkNyUmFzdGVyW2kgKyAxXTtcbiAgICBjb25zdCBjciA9IHlDYkNyUmFzdGVyW2kgKyAyXTtcblxuICAgIHJnYlJhc3RlcltqXSA9ICh5ICsgKDEuNDAyMDAgKiAoY3IgLSAweDgwKSkpO1xuICAgIHJnYlJhc3RlcltqICsgMV0gPSAoeSAtICgwLjM0NDE0ICogKGNiIC0gMHg4MCkpIC0gKDAuNzE0MTQgKiAoY3IgLSAweDgwKSkpO1xuICAgIHJnYlJhc3RlcltqICsgMl0gPSAoeSArICgxLjc3MjAwICogKGNiIC0gMHg4MCkpKTtcbiAgfVxuICByZXR1cm4gcmdiUmFzdGVyO1xufVxuXG5jb25zdCBYbiA9IDAuOTUwNDc7XG5jb25zdCBZbiA9IDEuMDAwMDA7XG5jb25zdCBabiA9IDEuMDg4ODM7XG5cbi8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FudGltYXR0ZXIxNS9yZ2ItbGFiL2Jsb2IvbWFzdGVyL2NvbG9yLmpzXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQ0lFTGFiKGNpZUxhYlJhc3Rlcikge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGNpZUxhYlJhc3RlcjtcbiAgY29uc3QgcmdiUmFzdGVyID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiAzKTtcblxuICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBjaWVMYWJSYXN0ZXIubGVuZ3RoOyBpICs9IDMsIGogKz0gMykge1xuICAgIGNvbnN0IEwgPSBjaWVMYWJSYXN0ZXJbaSArIDBdO1xuICAgIGNvbnN0IGFfID0gY2llTGFiUmFzdGVyW2kgKyAxXSA8PCAyNCA+PiAyNDsgLy8gY29udmVyc2lvbiBmcm9tIHVpbnQ4IHRvIGludDhcbiAgICBjb25zdCBiXyA9IGNpZUxhYlJhc3RlcltpICsgMl0gPDwgMjQgPj4gMjQ7IC8vIHNhbWVcblxuICAgIGxldCB5ID0gKEwgKyAxNikgLyAxMTY7XG4gICAgbGV0IHggPSAoYV8gLyA1MDApICsgeTtcbiAgICBsZXQgeiA9IHkgLSAoYl8gLyAyMDApO1xuICAgIGxldCByO1xuICAgIGxldCBnO1xuICAgIGxldCBiO1xuXG4gICAgeCA9IFhuICogKCh4ICogeCAqIHggPiAwLjAwODg1NikgPyB4ICogeCAqIHggOiAoeCAtICgxNiAvIDExNikpIC8gNy43ODcpO1xuICAgIHkgPSBZbiAqICgoeSAqIHkgKiB5ID4gMC4wMDg4NTYpID8geSAqIHkgKiB5IDogKHkgLSAoMTYgLyAxMTYpKSAvIDcuNzg3KTtcbiAgICB6ID0gWm4gKiAoKHogKiB6ICogeiA+IDAuMDA4ODU2KSA/IHogKiB6ICogeiA6ICh6IC0gKDE2IC8gMTE2KSkgLyA3Ljc4Nyk7XG5cbiAgICByID0gKHggKiAzLjI0MDYpICsgKHkgKiAtMS41MzcyKSArICh6ICogLTAuNDk4Nik7XG4gICAgZyA9ICh4ICogLTAuOTY4OSkgKyAoeSAqIDEuODc1OCkgKyAoeiAqIDAuMDQxNSk7XG4gICAgYiA9ICh4ICogMC4wNTU3KSArICh5ICogLTAuMjA0MCkgKyAoeiAqIDEuMDU3MCk7XG5cbiAgICByID0gKHIgPiAwLjAwMzEzMDgpID8gKCgxLjA1NSAqIChyICoqICgxIC8gMi40KSkpIC0gMC4wNTUpIDogMTIuOTIgKiByO1xuICAgIGcgPSAoZyA+IDAuMDAzMTMwOCkgPyAoKDEuMDU1ICogKGcgKiogKDEgLyAyLjQpKSkgLSAwLjA1NSkgOiAxMi45MiAqIGc7XG4gICAgYiA9IChiID4gMC4wMDMxMzA4KSA/ICgoMS4wNTUgKiAoYiAqKiAoMSAvIDIuNCkpKSAtIDAuMDU1KSA6IDEyLjkyICogYjtcblxuICAgIHJnYlJhc3RlcltqXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHIpKSAqIDI1NTtcbiAgICByZ2JSYXN0ZXJbaiArIDFdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgZykpICogMjU1O1xuICAgIHJnYlJhc3RlcltqICsgMl0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBiKSkgKiAyNTU7XG4gIH1cbiAgcmV0dXJuIHJnYlJhc3Rlcjtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/rgb.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/source/arraybuffer.js":
/*!****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/arraybuffer.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeBufferSource: function() { return /* binding */ makeBufferSource; }\n/* harmony export */ });\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basesource.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/basesource.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/utils.js\");\n\n\n\nclass ArrayBufferSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_0__.BaseSource {\n  constructor(arrayBuffer) {\n    super();\n    this.arrayBuffer = arrayBuffer;\n  }\n\n  fetchSlice(slice, signal) {\n    if (signal && signal.aborted) {\n      throw new _utils_js__WEBPACK_IMPORTED_MODULE_1__.AbortError('Request aborted');\n    }\n    return this.arrayBuffer.slice(slice.offset, slice.offset + slice.length);\n  }\n}\n\nfunction makeBufferSource(arrayBuffer) {\n  return new ArrayBufferSource(arrayBuffer);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9hcnJheWJ1ZmZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNkM7QUFDSjs7QUFFekMsZ0NBQWdDLHNEQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9hcnJheWJ1ZmZlci5qcz83YzM2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VTb3VyY2UgfSBmcm9tICcuL2Jhc2Vzb3VyY2UuanMnO1xuaW1wb3J0IHsgQWJvcnRFcnJvciB9IGZyb20gJy4uL3V0aWxzLmpzJztcblxuY2xhc3MgQXJyYXlCdWZmZXJTb3VyY2UgZXh0ZW5kcyBCYXNlU291cmNlIHtcbiAgY29uc3RydWN0b3IoYXJyYXlCdWZmZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBhcnJheUJ1ZmZlcjtcbiAgfVxuXG4gIGZldGNoU2xpY2Uoc2xpY2UsIHNpZ25hbCkge1xuICAgIGlmIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYXJyYXlCdWZmZXIuc2xpY2Uoc2xpY2Uub2Zmc2V0LCBzbGljZS5vZmZzZXQgKyBzbGljZS5sZW5ndGgpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQnVmZmVyU291cmNlKGFycmF5QnVmZmVyKSB7XG4gIHJldHVybiBuZXcgQXJyYXlCdWZmZXJTb3VyY2UoYXJyYXlCdWZmZXIpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/source/arraybuffer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/source/basesource.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/basesource.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseSource: function() { return /* binding */ BaseSource; }\n/* harmony export */ });\n/**\n * @typedef Slice\n * @property {number} offset\n * @property {number} length\n */\n\nclass BaseSource {\n  /**\n   *\n   * @param {Slice[]} slices\n   * @returns {ArrayBuffer[]}\n   */\n  async fetch(slices, signal = undefined) {\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  /**\n   *\n   * @param {Slice} slice\n   * @returns {ArrayBuffer}\n   */\n  async fetchSlice(slice) {\n    throw new Error(`fetching of slice ${slice} not possible, not implemented`);\n  }\n\n  /**\n   * Returns the filesize if already determined and null otherwise\n   */\n  get fileSize() {\n    return null;\n  }\n\n  async close() {\n    // no-op by default\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9iYXNlc291cmNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0Qjs7QUFFTztBQUNQO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9iYXNlc291cmNlLmpzP2Q5MjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiBTbGljZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IG9mZnNldFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxlbmd0aFxuICovXG5cbmV4cG9ydCBjbGFzcyBCYXNlU291cmNlIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7U2xpY2VbXX0gc2xpY2VzXG4gICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcltdfVxuICAgKi9cbiAgYXN5bmMgZmV0Y2goc2xpY2VzLCBzaWduYWwgPSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICBzbGljZXMubWFwKChzbGljZSkgPT4gdGhpcy5mZXRjaFNsaWNlKHNsaWNlLCBzaWduYWwpKSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7U2xpY2V9IHNsaWNlXG4gICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn1cbiAgICovXG4gIGFzeW5jIGZldGNoU2xpY2Uoc2xpY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGZldGNoaW5nIG9mIHNsaWNlICR7c2xpY2V9IG5vdCBwb3NzaWJsZSwgbm90IGltcGxlbWVudGVkYCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlsZXNpemUgaWYgYWxyZWFkeSBkZXRlcm1pbmVkIGFuZCBudWxsIG90aGVyd2lzZVxuICAgKi9cbiAgZ2V0IGZpbGVTaXplKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgYXN5bmMgY2xvc2UoKSB7XG4gICAgLy8gbm8tb3AgYnkgZGVmYXVsdFxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/source/basesource.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/source/blockedsource.js":
/*!******************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/blockedsource.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlockedSource: function() { return /* binding */ BlockedSource; }\n/* harmony export */ });\n/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! quick-lru */ \"(app-pages-browser)/./node_modules/quick-lru/index.js\");\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basesource.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/basesource.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/utils.js\");\n\n\n\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nclass BlockedSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_1__.BaseSource {\n  /**\n   *\n   * @param {BaseSource} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   * @param {number} [options.blockSize]\n   * @param {number} [options.cacheSize]\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new quick_lru__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n      maxSize: cacheSize,\n      onEviction: (blockId, block) => {\n        this.evictedBlocks.set(blockId, block);\n      },\n    });\n\n    /** @type {Map<number, Block>} */\n    this.evictedBlocks = new Map();\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n\n    this.abortedBlockIds = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const blockRequests = [];\n    const missingBlockIds = [];\n    const allBlockIds = [];\n    this.evictedBlocks.clear();\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        const blockId = Math.floor(current / this.blockSize);\n        if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.push(blockId);\n        }\n        if (this.blockRequests.has(blockId)) {\n          blockRequests.push(this.blockRequests.get(blockId));\n        }\n        allBlockIds.push(blockId);\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wait)();\n    this.fetchBlocks(signal);\n\n    // Gather all of the new requests that this fetch call is contributing to `fetch`.\n    const missingRequests = [];\n    for (const blockId of missingBlockIds) {\n      // The requested missing block could already be in the cache\n      // instead of having its request still be outstanding.\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    }\n\n    // Actually await all pending requests that are needed for this `fetch`.\n    await Promise.allSettled(blockRequests);\n    await Promise.allSettled(missingRequests);\n\n    // Perform retries if a block was interrupted by a previous signal\n    const abortedBlockRequests = [];\n    const abortedBlockIds = allBlockIds\n      .filter((id) => this.abortedBlockIds.has(id) || !this.blockCache.has(id));\n    abortedBlockIds.forEach((id) => this.blockIdsToFetch.add(id));\n    // start the retry of some blocks if required\n    if (abortedBlockIds.length > 0 && signal && !signal.aborted) {\n      this.fetchBlocks(null);\n      for (const blockId of abortedBlockIds) {\n        const block = this.blockRequests.get(blockId);\n        if (!block) {\n          throw new Error(`Block ${blockId} is not in the block requests`);\n        }\n        abortedBlockRequests.push(block);\n      }\n      await Promise.allSettled(abortedBlockRequests);\n    }\n\n    // throw an  abort error\n    if (signal && signal.aborted) {\n      throw new _utils_js__WEBPACK_IMPORTED_MODULE_2__.AbortError('Request was aborted');\n    }\n\n    const blocks = allBlockIds.map((id) => this.blockCache.get(id) || this.evictedBlocks.get(id));\n    const failedBlocks = blocks.filter((i) => !i);\n    if (failedBlocks.length) {\n      throw new _utils_js__WEBPACK_IMPORTED_MODULE_2__.AggregateError(failedBlocks, 'Request failed');\n    }\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.zip)(allBlockIds, blocks));\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          this.blockRequests.set(blockId, (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n                blockId,\n              );\n              this.blockCache.set(blockId, block);\n              this.abortedBlockIds.delete(blockId);\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n                this.blockCache.delete(blockId);\n                this.abortedBlockIds.add(blockId);\n              } else {\n                throw err;\n              }\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })());\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      let top = slice.offset + slice.length;\n      if (this.fileSize !== null) {\n        top = Math.min(this.fileSize, top);\n      }\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor(top / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9ibG9ja2Vkc291cmNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUM7QUFDWTtBQUN1Qjs7QUFFcEU7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sNEJBQTRCLHNEQUFVO0FBQzdDO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSx3QkFBd0IscUNBQXFDLElBQUk7QUFDakU7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixpREFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTCxlQUFlLG9CQUFvQjtBQUNuQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsaUJBQWlCO0FBQ2xDOztBQUVBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkNBQTJDLGVBQWU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsK0NBQUk7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQVU7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFjO0FBQzlCOztBQUVBO0FBQ0EsbUNBQW1DLDhDQUFHOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0JBQStCLDRCQUE0QjtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxnQ0FBZ0M7QUFDN0MsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLHdCQUF3QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvYmxvY2tlZHNvdXJjZS5qcz8yOGUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBRdWlja0xSVSBmcm9tICdxdWljay1scnUnO1xuaW1wb3J0IHsgQmFzZVNvdXJjZSB9IGZyb20gJy4vYmFzZXNvdXJjZS5qcyc7XG5pbXBvcnQgeyBBYm9ydEVycm9yLCBBZ2dyZWdhdGVFcnJvciwgd2FpdCwgemlwIH0gZnJvbSAnLi4vdXRpbHMuanMnO1xuXG5jbGFzcyBCbG9jayB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gW2RhdGFdXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvZmZzZXQsIGxlbmd0aCwgZGF0YSA9IG51bGwpIHtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSB0b3AgYnl0ZSBib3JkZXJcbiAgICovXG4gIGdldCB0b3AoKSB7XG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0ICsgdGhpcy5sZW5ndGg7XG4gIH1cbn1cblxuY2xhc3MgQmxvY2tHcm91cCB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAgICogQHBhcmFtIHtudW1iZXJbXX0gYmxvY2tJZHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9mZnNldCwgbGVuZ3RoLCBibG9ja0lkcykge1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuYmxvY2tJZHMgPSBibG9ja0lkcztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQmxvY2tlZFNvdXJjZSBleHRlbmRzIEJhc2VTb3VyY2Uge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtCYXNlU291cmNlfSBzb3VyY2UgVGhlIHVuZGVybHlpbmcgc291cmNlIHRoYXQgc2hhbGwgYmUgYmxvY2tlZCBhbmQgY2FjaGVkXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5ibG9ja1NpemVdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jYWNoZVNpemVdXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHsgYmxvY2tTaXplID0gNjU1MzYsIGNhY2hlU2l6ZSA9IDEwMCB9ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuYmxvY2tTaXplID0gYmxvY2tTaXplO1xuXG4gICAgdGhpcy5ibG9ja0NhY2hlID0gbmV3IFF1aWNrTFJVKHtcbiAgICAgIG1heFNpemU6IGNhY2hlU2l6ZSxcbiAgICAgIG9uRXZpY3Rpb246IChibG9ja0lkLCBibG9jaykgPT4ge1xuICAgICAgICB0aGlzLmV2aWN0ZWRCbG9ja3Muc2V0KGJsb2NrSWQsIGJsb2NrKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvKiogQHR5cGUge01hcDxudW1iZXIsIEJsb2NrPn0gKi9cbiAgICB0aGlzLmV2aWN0ZWRCbG9ja3MgPSBuZXcgTWFwKCk7XG5cbiAgICAvLyBtYXBwaW5nIGJsb2NrSWQgLT4gQmxvY2sgaW5zdGFuY2VcbiAgICB0aGlzLmJsb2NrUmVxdWVzdHMgPSBuZXcgTWFwKCk7XG5cbiAgICAvLyBzZXQgb2YgYmxvY2tJZHMgbWlzc2luZyBmb3IgdGhlIGN1cnJlbnQgcmVxdWVzdHNcbiAgICB0aGlzLmJsb2NrSWRzVG9GZXRjaCA9IG5ldyBTZXQoKTtcblxuICAgIHRoaXMuYWJvcnRlZEJsb2NrSWRzID0gbmV3IFNldCgpO1xuICB9XG5cbiAgZ2V0IGZpbGVTaXplKCkge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZS5maWxlU2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vYmFzZXNvdXJjZVwiKS5TbGljZVtdfSBzbGljZXNcbiAgICovXG4gIGFzeW5jIGZldGNoKHNsaWNlcywgc2lnbmFsKSB7XG4gICAgY29uc3QgYmxvY2tSZXF1ZXN0cyA9IFtdO1xuICAgIGNvbnN0IG1pc3NpbmdCbG9ja0lkcyA9IFtdO1xuICAgIGNvbnN0IGFsbEJsb2NrSWRzID0gW107XG4gICAgdGhpcy5ldmljdGVkQmxvY2tzLmNsZWFyKCk7XG5cbiAgICBmb3IgKGNvbnN0IHsgb2Zmc2V0LCBsZW5ndGggfSBvZiBzbGljZXMpIHtcbiAgICAgIGxldCB0b3AgPSBvZmZzZXQgKyBsZW5ndGg7XG5cbiAgICAgIGNvbnN0IHsgZmlsZVNpemUgfSA9IHRoaXM7XG4gICAgICBpZiAoZmlsZVNpemUgIT09IG51bGwpIHtcbiAgICAgICAgdG9wID0gTWF0aC5taW4odG9wLCBmaWxlU2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZpcnN0QmxvY2tPZmZzZXQgPSBNYXRoLmZsb29yKG9mZnNldCAvIHRoaXMuYmxvY2tTaXplKSAqIHRoaXMuYmxvY2tTaXplO1xuXG4gICAgICBmb3IgKGxldCBjdXJyZW50ID0gZmlyc3RCbG9ja09mZnNldDsgY3VycmVudCA8IHRvcDsgY3VycmVudCArPSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgICAgICBjb25zdCBibG9ja0lkID0gTWF0aC5mbG9vcihjdXJyZW50IC8gdGhpcy5ibG9ja1NpemUpO1xuICAgICAgICBpZiAoIXRoaXMuYmxvY2tDYWNoZS5oYXMoYmxvY2tJZCkgJiYgIXRoaXMuYmxvY2tSZXF1ZXN0cy5oYXMoYmxvY2tJZCkpIHtcbiAgICAgICAgICB0aGlzLmJsb2NrSWRzVG9GZXRjaC5hZGQoYmxvY2tJZCk7XG4gICAgICAgICAgbWlzc2luZ0Jsb2NrSWRzLnB1c2goYmxvY2tJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYmxvY2tSZXF1ZXN0cy5oYXMoYmxvY2tJZCkpIHtcbiAgICAgICAgICBibG9ja1JlcXVlc3RzLnB1c2godGhpcy5ibG9ja1JlcXVlc3RzLmdldChibG9ja0lkKSk7XG4gICAgICAgIH1cbiAgICAgICAgYWxsQmxvY2tJZHMucHVzaChibG9ja0lkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbGxvdyBhZGRpdGlvbmFsIGJsb2NrIHJlcXVlc3RzIHRvIGFjY3VtdWxhdGVcbiAgICBhd2FpdCB3YWl0KCk7XG4gICAgdGhpcy5mZXRjaEJsb2NrcyhzaWduYWwpO1xuXG4gICAgLy8gR2F0aGVyIGFsbCBvZiB0aGUgbmV3IHJlcXVlc3RzIHRoYXQgdGhpcyBmZXRjaCBjYWxsIGlzIGNvbnRyaWJ1dGluZyB0byBgZmV0Y2hgLlxuICAgIGNvbnN0IG1pc3NpbmdSZXF1ZXN0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgYmxvY2tJZCBvZiBtaXNzaW5nQmxvY2tJZHMpIHtcbiAgICAgIC8vIFRoZSByZXF1ZXN0ZWQgbWlzc2luZyBibG9jayBjb3VsZCBhbHJlYWR5IGJlIGluIHRoZSBjYWNoZVxuICAgICAgLy8gaW5zdGVhZCBvZiBoYXZpbmcgaXRzIHJlcXVlc3Qgc3RpbGwgYmUgb3V0c3RhbmRpbmcuXG4gICAgICBpZiAodGhpcy5ibG9ja1JlcXVlc3RzLmhhcyhibG9ja0lkKSkge1xuICAgICAgICBtaXNzaW5nUmVxdWVzdHMucHVzaCh0aGlzLmJsb2NrUmVxdWVzdHMuZ2V0KGJsb2NrSWQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBY3R1YWxseSBhd2FpdCBhbGwgcGVuZGluZyByZXF1ZXN0cyB0aGF0IGFyZSBuZWVkZWQgZm9yIHRoaXMgYGZldGNoYC5cbiAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoYmxvY2tSZXF1ZXN0cyk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKG1pc3NpbmdSZXF1ZXN0cyk7XG5cbiAgICAvLyBQZXJmb3JtIHJldHJpZXMgaWYgYSBibG9jayB3YXMgaW50ZXJydXB0ZWQgYnkgYSBwcmV2aW91cyBzaWduYWxcbiAgICBjb25zdCBhYm9ydGVkQmxvY2tSZXF1ZXN0cyA9IFtdO1xuICAgIGNvbnN0IGFib3J0ZWRCbG9ja0lkcyA9IGFsbEJsb2NrSWRzXG4gICAgICAuZmlsdGVyKChpZCkgPT4gdGhpcy5hYm9ydGVkQmxvY2tJZHMuaGFzKGlkKSB8fCAhdGhpcy5ibG9ja0NhY2hlLmhhcyhpZCkpO1xuICAgIGFib3J0ZWRCbG9ja0lkcy5mb3JFYWNoKChpZCkgPT4gdGhpcy5ibG9ja0lkc1RvRmV0Y2guYWRkKGlkKSk7XG4gICAgLy8gc3RhcnQgdGhlIHJldHJ5IG9mIHNvbWUgYmxvY2tzIGlmIHJlcXVpcmVkXG4gICAgaWYgKGFib3J0ZWRCbG9ja0lkcy5sZW5ndGggPiAwICYmIHNpZ25hbCAmJiAhc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHRoaXMuZmV0Y2hCbG9ja3MobnVsbCk7XG4gICAgICBmb3IgKGNvbnN0IGJsb2NrSWQgb2YgYWJvcnRlZEJsb2NrSWRzKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5ibG9ja1JlcXVlc3RzLmdldChibG9ja0lkKTtcbiAgICAgICAgaWYgKCFibG9jaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmxvY2sgJHtibG9ja0lkfSBpcyBub3QgaW4gdGhlIGJsb2NrIHJlcXVlc3RzYCk7XG4gICAgICAgIH1cbiAgICAgICAgYWJvcnRlZEJsb2NrUmVxdWVzdHMucHVzaChibG9jayk7XG4gICAgICB9XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoYWJvcnRlZEJsb2NrUmVxdWVzdHMpO1xuICAgIH1cblxuICAgIC8vIHRocm93IGFuICBhYm9ydCBlcnJvclxuICAgIGlmIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKCdSZXF1ZXN0IHdhcyBhYm9ydGVkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYmxvY2tzID0gYWxsQmxvY2tJZHMubWFwKChpZCkgPT4gdGhpcy5ibG9ja0NhY2hlLmdldChpZCkgfHwgdGhpcy5ldmljdGVkQmxvY2tzLmdldChpZCkpO1xuICAgIGNvbnN0IGZhaWxlZEJsb2NrcyA9IGJsb2Nrcy5maWx0ZXIoKGkpID0+ICFpKTtcbiAgICBpZiAoZmFpbGVkQmxvY2tzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEFnZ3JlZ2F0ZUVycm9yKGZhaWxlZEJsb2NrcywgJ1JlcXVlc3QgZmFpbGVkJyk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGEgZmluYWwgTWFwLCB3aXRoIGFsbCByZXF1aXJlZCBibG9ja3MgZm9yIHRoaXMgcmVxdWVzdCB0byBzYXRpc2Z5XG4gICAgY29uc3QgcmVxdWlyZWRCbG9ja3MgPSBuZXcgTWFwKHppcChhbGxCbG9ja0lkcywgYmxvY2tzKSk7XG5cbiAgICAvLyBUT0RPOiBzYXRpc2Z5IGVhY2ggc2xpY2VcbiAgICByZXR1cm4gdGhpcy5yZWFkU2xpY2VEYXRhKHNsaWNlcywgcmVxdWlyZWRCbG9ja3MpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IHNpZ25hbFxuICAgKi9cbiAgZmV0Y2hCbG9ja3Moc2lnbmFsKSB7XG4gICAgLy8gY2hlY2sgaWYgd2Ugc3RpbGwgbmVlZCB0b1xuICAgIGlmICh0aGlzLmJsb2NrSWRzVG9GZXRjaC5zaXplID4gMCkge1xuICAgICAgY29uc3QgZ3JvdXBzID0gdGhpcy5ncm91cEJsb2Nrcyh0aGlzLmJsb2NrSWRzVG9GZXRjaCk7XG5cbiAgICAgIC8vIHN0YXJ0IHJlcXVlc3Rpbmcgc2xpY2VzIG9mIGRhdGFcbiAgICAgIGNvbnN0IGdyb3VwUmVxdWVzdHMgPSB0aGlzLnNvdXJjZS5mZXRjaChncm91cHMsIHNpZ25hbCk7XG5cbiAgICAgIGZvciAobGV0IGdyb3VwSW5kZXggPSAwOyBncm91cEluZGV4IDwgZ3JvdXBzLmxlbmd0aDsgKytncm91cEluZGV4KSB7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gZ3JvdXBzW2dyb3VwSW5kZXhdO1xuXG4gICAgICAgIGZvciAoY29uc3QgYmxvY2tJZCBvZiBncm91cC5ibG9ja0lkcykge1xuICAgICAgICAgIC8vIG1ha2UgYW4gYXN5bmMgSUlGRSBmb3IgZWFjaCBibG9ja1xuICAgICAgICAgIHRoaXMuYmxvY2tSZXF1ZXN0cy5zZXQoYmxvY2tJZCwgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gKGF3YWl0IGdyb3VwUmVxdWVzdHMpW2dyb3VwSW5kZXhdO1xuICAgICAgICAgICAgICBjb25zdCBibG9ja09mZnNldCA9IGJsb2NrSWQgKiB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgICAgICAgICAgY29uc3QgbyA9IGJsb2NrT2Zmc2V0IC0gcmVzcG9uc2Uub2Zmc2V0O1xuICAgICAgICAgICAgICBjb25zdCB0ID0gTWF0aC5taW4obyArIHRoaXMuYmxvY2tTaXplLCByZXNwb25zZS5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuZGF0YS5zbGljZShvLCB0KTtcbiAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBuZXcgQmxvY2soXG4gICAgICAgICAgICAgICAgYmxvY2tPZmZzZXQsXG4gICAgICAgICAgICAgICAgZGF0YS5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgYmxvY2tJZCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdGhpcy5ibG9ja0NhY2hlLnNldChibG9ja0lkLCBibG9jayk7XG4gICAgICAgICAgICAgIHRoaXMuYWJvcnRlZEJsb2NrSWRzLmRlbGV0ZShibG9ja0lkKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBpZiAoZXJyLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBzaWduYWwgaGVyZSwgd2UgbmVlZCBpdCB0byBkZXRlcm1pbmUgbGF0ZXIgaWYgYW5cbiAgICAgICAgICAgICAgICAvLyBlcnJvciB3YXMgY2F1c2VkIGJ5IHRoaXMgc2lnbmFsXG4gICAgICAgICAgICAgICAgZXJyLnNpZ25hbCA9IHNpZ25hbDtcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2NrQ2FjaGUuZGVsZXRlKGJsb2NrSWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnRlZEJsb2NrSWRzLmFkZChibG9ja0lkKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHRoaXMuYmxvY2tSZXF1ZXN0cy5kZWxldGUoYmxvY2tJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYmxvY2tJZHNUb0ZldGNoLmNsZWFyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7U2V0fSBibG9ja0lkc1xuICAgKiBAcmV0dXJucyB7QmxvY2tHcm91cFtdfVxuICAgKi9cbiAgZ3JvdXBCbG9ja3MoYmxvY2tJZHMpIHtcbiAgICBjb25zdCBzb3J0ZWRCbG9ja0lkcyA9IEFycmF5LmZyb20oYmxvY2tJZHMpLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICBpZiAoc29ydGVkQmxvY2tJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGxldCBjdXJyZW50ID0gW107XG4gICAgbGV0IGxhc3RCbG9ja0lkID0gbnVsbDtcbiAgICBjb25zdCBncm91cHMgPSBbXTtcblxuICAgIGZvciAoY29uc3QgYmxvY2tJZCBvZiBzb3J0ZWRCbG9ja0lkcykge1xuICAgICAgaWYgKGxhc3RCbG9ja0lkID09PSBudWxsIHx8IGxhc3RCbG9ja0lkICsgMSA9PT0gYmxvY2tJZCkge1xuICAgICAgICBjdXJyZW50LnB1c2goYmxvY2tJZCk7XG4gICAgICAgIGxhc3RCbG9ja0lkID0gYmxvY2tJZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyb3Vwcy5wdXNoKG5ldyBCbG9ja0dyb3VwKFxuICAgICAgICAgIGN1cnJlbnRbMF0gKiB0aGlzLmJsb2NrU2l6ZSxcbiAgICAgICAgICBjdXJyZW50Lmxlbmd0aCAqIHRoaXMuYmxvY2tTaXplLFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICkpO1xuICAgICAgICBjdXJyZW50ID0gW2Jsb2NrSWRdO1xuICAgICAgICBsYXN0QmxvY2tJZCA9IGJsb2NrSWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ3JvdXBzLnB1c2gobmV3IEJsb2NrR3JvdXAoXG4gICAgICBjdXJyZW50WzBdICogdGhpcy5ibG9ja1NpemUsXG4gICAgICBjdXJyZW50Lmxlbmd0aCAqIHRoaXMuYmxvY2tTaXplLFxuICAgICAgY3VycmVudCxcbiAgICApKTtcblxuICAgIHJldHVybiBncm91cHM7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Jhc2Vzb3VyY2VcIikuU2xpY2VbXX0gc2xpY2VzXG4gICAqIEBwYXJhbSB7TWFwfSBibG9ja3NcbiAgICovXG4gIHJlYWRTbGljZURhdGEoc2xpY2VzLCBibG9ja3MpIHtcbiAgICByZXR1cm4gc2xpY2VzLm1hcCgoc2xpY2UpID0+IHtcbiAgICAgIGxldCB0b3AgPSBzbGljZS5vZmZzZXQgKyBzbGljZS5sZW5ndGg7XG4gICAgICBpZiAodGhpcy5maWxlU2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICB0b3AgPSBNYXRoLm1pbih0aGlzLmZpbGVTaXplLCB0b3ApO1xuICAgICAgfVxuICAgICAgY29uc3QgYmxvY2tJZExvdyA9IE1hdGguZmxvb3Ioc2xpY2Uub2Zmc2V0IC8gdGhpcy5ibG9ja1NpemUpO1xuICAgICAgY29uc3QgYmxvY2tJZEhpZ2ggPSBNYXRoLmZsb29yKHRvcCAvIHRoaXMuYmxvY2tTaXplKTtcbiAgICAgIGNvbnN0IHNsaWNlRGF0YSA9IG5ldyBBcnJheUJ1ZmZlcihzbGljZS5sZW5ndGgpO1xuICAgICAgY29uc3Qgc2xpY2VWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoc2xpY2VEYXRhKTtcblxuICAgICAgZm9yIChsZXQgYmxvY2tJZCA9IGJsb2NrSWRMb3c7IGJsb2NrSWQgPD0gYmxvY2tJZEhpZ2g7ICsrYmxvY2tJZCkge1xuICAgICAgICBjb25zdCBibG9jayA9IGJsb2Nrcy5nZXQoYmxvY2tJZCk7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gYmxvY2sub2Zmc2V0IC0gc2xpY2Uub2Zmc2V0O1xuICAgICAgICBjb25zdCB0b3BEZWx0YSA9IGJsb2NrLnRvcCAtIHRvcDtcbiAgICAgICAgbGV0IGJsb2NrSW5uZXJPZmZzZXQgPSAwO1xuICAgICAgICBsZXQgcmFuZ2VJbm5lck9mZnNldCA9IDA7XG4gICAgICAgIGxldCB1c2VkQmxvY2tMZW5ndGg7XG5cbiAgICAgICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICAgIGJsb2NrSW5uZXJPZmZzZXQgPSAtZGVsdGE7XG4gICAgICAgIH0gZWxzZSBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgICAgcmFuZ2VJbm5lck9mZnNldCA9IGRlbHRhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvcERlbHRhIDwgMCkge1xuICAgICAgICAgIHVzZWRCbG9ja0xlbmd0aCA9IGJsb2NrLmxlbmd0aCAtIGJsb2NrSW5uZXJPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXNlZEJsb2NrTGVuZ3RoID0gdG9wIC0gYmxvY2sub2Zmc2V0IC0gYmxvY2tJbm5lck9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJsb2NrVmlldyA9IG5ldyBVaW50OEFycmF5KGJsb2NrLmRhdGEsIGJsb2NrSW5uZXJPZmZzZXQsIHVzZWRCbG9ja0xlbmd0aCk7XG4gICAgICAgIHNsaWNlVmlldy5zZXQoYmxvY2tWaWV3LCByYW5nZUlubmVyT2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNsaWNlRGF0YTtcbiAgICB9KTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/source/blockedsource.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/base.js":
/*!****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/base.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseClient: function() { return /* binding */ BaseClient; },\n/* harmony export */   BaseResponse: function() { return /* binding */ BaseResponse; }\n/* harmony export */ });\nclass BaseResponse {\n  /**\n   * Returns whether the response has an ok'ish status code\n   */\n  get ok() {\n    return this.status >= 200 && this.status <= 299;\n  }\n\n  /**\n   * Returns the status code of the response\n   */\n  get status() {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * Returns the value of the specified header\n   * @param {string} headerName the header name\n   * @returns {string} the header value\n   */\n  getHeader(headerName) { // eslint-disable-line no-unused-vars\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @returns {ArrayBuffer} the response data of the request\n   */\n  async getData() {\n    throw new Error('not implemented');\n  }\n}\n\nclass BaseClient {\n  constructor(url) {\n    this.url = url;\n  }\n\n  /**\n   * Send a request with the options\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<BaseResponse>}\n   */\n  async request({ headers, signal } = {}) { // eslint-disable-line no-unused-vars\n    throw new Error('request is not implemented');\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9jbGllbnQvYmFzZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsNENBQTRDLFdBQVc7QUFDckUsZUFBZTtBQUNmO0FBQ0Esa0JBQWtCLGtCQUFrQixJQUFJLElBQUk7QUFDNUM7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9jbGllbnQvYmFzZS5qcz8yY2EwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBCYXNlUmVzcG9uc2Uge1xuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSByZXNwb25zZSBoYXMgYW4gb2snaXNoIHN0YXR1cyBjb2RlXG4gICAqL1xuICBnZXQgb2soKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8PSAyOTk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RhdHVzIGNvZGUgb2YgdGhlIHJlc3BvbnNlXG4gICAqL1xuICBnZXQgc3RhdHVzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBoZWFkZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhlYWRlck5hbWUgdGhlIGhlYWRlciBuYW1lXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBoZWFkZXIgdmFsdWVcbiAgICovXG4gIGdldEhlYWRlcihoZWFkZXJOYW1lKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gdGhlIHJlc3BvbnNlIGRhdGEgb2YgdGhlIHJlcXVlc3RcbiAgICovXG4gIGFzeW5jIGdldERhdGEoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQmFzZUNsaWVudCB7XG4gIGNvbnN0cnVjdG9yKHVybCkge1xuICAgIHRoaXMudXJsID0gdXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSByZXF1ZXN0IHdpdGggdGhlIG9wdGlvbnNcbiAgICogQHBhcmFtIHt7aGVhZGVyczogSGVhZGVyc0luaXQsIHNpZ25hbDogQWJvcnRTaWduYWx9fSBbb3B0aW9ucz17fV1cbiAgICogQHJldHVybnMge1Byb21pc2U8QmFzZVJlc3BvbnNlPn1cbiAgICovXG4gIGFzeW5jIHJlcXVlc3QoeyBoZWFkZXJzLCBzaWduYWwgfSA9IHt9KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVlc3QgaXMgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/base.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/fetch.js":
/*!*****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/fetch.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FetchClient: function() { return /* binding */ FetchClient; }\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/base.js\");\n\n\nclass FetchResponse extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseResponse {\n  /**\n   * BaseResponse facade for fetch API Response\n   * @param {Response} response\n   */\n  constructor(response) {\n    super();\n    this.response = response;\n  }\n\n  get status() {\n    return this.response.status;\n  }\n\n  getHeader(name) {\n    return this.response.headers.get(name);\n  }\n\n  async getData() {\n    const data = this.response.arrayBuffer\n      ? await this.response.arrayBuffer()\n      : (await this.response.buffer()).buffer;\n    return data;\n  }\n}\n\nclass FetchClient extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseClient {\n  constructor(url, credentials) {\n    super(url);\n    this.credentials = credentials;\n  }\n\n  /**\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<FetchResponse>}\n   */\n  async request({ headers, signal } = {}) {\n    const response = await fetch(this.url, {\n      headers, credentials: this.credentials, signal,\n    });\n    return new FetchResponse(response);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9jbGllbnQvZmV0Y2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUQ7O0FBRXJELDRCQUE0QixrREFBWTtBQUN4QztBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTywwQkFBMEIsZ0RBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLDRDQUE0QyxXQUFXO0FBQ3JFLGVBQWU7QUFDZjtBQUNBLGtCQUFrQixrQkFBa0IsSUFBSTtBQUN4QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L2ZldGNoLmpzPzhiMWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUNsaWVudCwgQmFzZVJlc3BvbnNlIH0gZnJvbSAnLi9iYXNlLmpzJztcblxuY2xhc3MgRmV0Y2hSZXNwb25zZSBleHRlbmRzIEJhc2VSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBCYXNlUmVzcG9uc2UgZmFjYWRlIGZvciBmZXRjaCBBUEkgUmVzcG9uc2VcbiAgICogQHBhcmFtIHtSZXNwb25zZX0gcmVzcG9uc2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlc3BvbnNlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIH1cblxuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLnN0YXR1cztcbiAgfVxuXG4gIGdldEhlYWRlcihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2UuaGVhZGVycy5nZXQobmFtZSk7XG4gIH1cblxuICBhc3luYyBnZXREYXRhKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3BvbnNlLmFycmF5QnVmZmVyXG4gICAgICA/IGF3YWl0IHRoaXMucmVzcG9uc2UuYXJyYXlCdWZmZXIoKVxuICAgICAgOiAoYXdhaXQgdGhpcy5yZXNwb25zZS5idWZmZXIoKSkuYnVmZmVyO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBGZXRjaENsaWVudCBleHRlbmRzIEJhc2VDbGllbnQge1xuICBjb25zdHJ1Y3Rvcih1cmwsIGNyZWRlbnRpYWxzKSB7XG4gICAgc3VwZXIodXJsKTtcbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHt7aGVhZGVyczogSGVhZGVyc0luaXQsIHNpZ25hbDogQWJvcnRTaWduYWx9fSBbb3B0aW9ucz17fV1cbiAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hSZXNwb25zZT59XG4gICAqL1xuICBhc3luYyByZXF1ZXN0KHsgaGVhZGVycywgc2lnbmFsIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy51cmwsIHtcbiAgICAgIGhlYWRlcnMsIGNyZWRlbnRpYWxzOiB0aGlzLmNyZWRlbnRpYWxzLCBzaWduYWwsXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBGZXRjaFJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/fetch.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/http.js":
/*!****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/http.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HttpClient: function() { return /* binding */ HttpClient; }\n/* harmony export */ });\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! http */ \"?b5cf\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! https */ \"?69f2\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! url */ \"(app-pages-browser)/./node_modules/next/dist/compiled/native-url/index.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/base.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/utils.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\n\n\n\n\n\n\nclass HttpResponse extends _base_js__WEBPACK_IMPORTED_MODULE_3__.BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nclass HttpClient extends _base_js__WEBPACK_IMPORTED_MODULE_3__.BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = url__WEBPACK_IMPORTED_MODULE_2__.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http__WEBPACK_IMPORTED_MODULE_0__ : https__WEBPACK_IMPORTED_MODULE_1__);\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolveData) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolveData(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new _utils_js__WEBPACK_IMPORTED_MODULE_4__.AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new _utils_js__WEBPACK_IMPORTED_MODULE_4__.AbortError('Request aborted')));\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9jbGllbnQvaHR0cC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXdCO0FBQ0U7QUFDRDs7QUFFNEI7QUFDVDs7QUFFNUMsMkJBQTJCLGtEQUFZO0FBQ3ZDO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLHlCQUF5QixnREFBVTtBQUMxQztBQUNBO0FBQ0EscUJBQXFCLHNDQUFZO0FBQ2pDLDBEQUEwRCxpQ0FBSSxHQUFHLGtDQUFLO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsMkJBQTJCLE1BQU07QUFDakM7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLGlEQUFVO0FBQ3hDO0FBQ0EsbUVBQW1FLGlEQUFVO0FBQzdFO0FBQ0EsS0FBSztBQUNMOztBQUVBLGtCQUFrQixrQkFBa0IsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L2h0dHAuanM/ZjRjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaHR0cCBmcm9tICdodHRwJztcbmltcG9ydCBodHRwcyBmcm9tICdodHRwcyc7XG5pbXBvcnQgdXJsTW9kIGZyb20gJ3VybCc7XG5cbmltcG9ydCB7IEJhc2VDbGllbnQsIEJhc2VSZXNwb25zZSB9IGZyb20gJy4vYmFzZS5qcyc7XG5pbXBvcnQgeyBBYm9ydEVycm9yIH0gZnJvbSAnLi4vLi4vdXRpbHMuanMnO1xuXG5jbGFzcyBIdHRwUmVzcG9uc2UgZXh0ZW5kcyBCYXNlUmVzcG9uc2Uge1xuICAvKipcbiAgICogQmFzZVJlc3BvbnNlIGZhY2FkZSBmb3Igbm9kZSBIVFRQL0hUVFBTIEFQSSBSZXNwb25zZVxuICAgKiBAcGFyYW0ge2h0dHAuU2VydmVyUmVzcG9uc2V9IHJlc3BvbnNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZXNwb25zZSwgZGF0YVByb21pc2UpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB0aGlzLmRhdGFQcm9taXNlID0gZGF0YVByb21pc2U7XG4gIH1cblxuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gIH1cblxuICBnZXRIZWFkZXIobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLmhlYWRlcnNbbmFtZV07XG4gIH1cblxuICBhc3luYyBnZXREYXRhKCkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmRhdGFQcm9taXNlO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBIdHRwQ2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XG4gIGNvbnN0cnVjdG9yKHVybCkge1xuICAgIHN1cGVyKHVybCk7XG4gICAgdGhpcy5wYXJzZWRVcmwgPSB1cmxNb2QucGFyc2UodGhpcy51cmwpO1xuICAgIHRoaXMuaHR0cEFwaSA9ICh0aGlzLnBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHA6JyA/IGh0dHAgOiBodHRwcyk7XG4gIH1cblxuICBjb25zdHJ1Y3RSZXF1ZXN0KGhlYWRlcnMsIHNpZ25hbCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5odHRwQXBpLmdldChcbiAgICAgICAge1xuICAgICAgICAgIC4uLnRoaXMucGFyc2VkVXJsLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgIH0sXG4gICAgICAgIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRhdGFQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmVEYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaHVua3MgPSBbXTtcblxuICAgICAgICAgICAgLy8gY29sbGVjdCBjaHVua3NcbiAgICAgICAgICAgIHJlc3BvbnNlLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBjb25jYXRlbmF0ZSBhbGwgY2h1bmtzIGFuZCByZXNvbHZlIHRoZSBwcm9taXNlIHdpdGggdGhlIHJlc3VsdGluZyBidWZmZXJcbiAgICAgICAgICAgIHJlc3BvbnNlLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBCdWZmZXIuY29uY2F0KGNodW5rcykuYnVmZmVyO1xuICAgICAgICAgICAgICByZXNvbHZlRGF0YShkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzcG9uc2Uub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXNvbHZlKG5ldyBIdHRwUmVzcG9uc2UocmVzcG9uc2UsIGRhdGFQcm9taXNlKSk7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAgcmVxdWVzdC5vbignZXJyb3InLCByZWplY3QpO1xuXG4gICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIHJlcXVlc3QuZGVzdHJveShuZXcgQWJvcnRFcnJvcignUmVxdWVzdCBhYm9ydGVkJykpO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHJlcXVlc3QuZGVzdHJveShuZXcgQWJvcnRFcnJvcignUmVxdWVzdCBhYm9ydGVkJykpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHJlcXVlc3QoeyBoZWFkZXJzLCBzaWduYWwgfSA9IHt9KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNvbnN0cnVjdFJlcXVlc3QoaGVhZGVycywgc2lnbmFsKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/http.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/xhr.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/xhr.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   XHRClient: function() { return /* binding */ XHRClient; }\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/base.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/utils.js\");\n\n\n\nclass XHRResponse extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseResponse {\n  /**\n   * BaseResponse facade for XMLHttpRequest\n   * @param {XMLHttpRequest} xhr\n   * @param {ArrayBuffer} data\n   */\n  constructor(xhr, data) {\n    super();\n    this.xhr = xhr;\n    this.data = data;\n  }\n\n  get status() {\n    return this.xhr.status;\n  }\n\n  getHeader(name) {\n    return this.xhr.getResponseHeader(name);\n  }\n\n  async getData() {\n    return this.data;\n  }\n}\n\nclass XHRClient extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseClient {\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', this.url);\n      xhr.responseType = 'arraybuffer';\n      for (const [key, value] of Object.entries(headers)) {\n        xhr.setRequestHeader(key, value);\n      }\n\n      // hook signals\n      xhr.onload = () => {\n        const data = xhr.response;\n        resolve(new XHRResponse(xhr, data));\n      };\n      xhr.onerror = reject;\n      xhr.onabort = () => reject(new _utils_js__WEBPACK_IMPORTED_MODULE_1__.AbortError('Request aborted'));\n      xhr.send();\n\n      if (signal) {\n        if (signal.aborted) {\n          xhr.abort();\n        }\n        signal.addEventListener('abort', () => xhr.abort());\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9jbGllbnQveGhyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxRDtBQUNUOztBQUU1QywwQkFBMEIsa0RBQVk7QUFDdEM7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyx3QkFBd0IsZ0RBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaURBQVU7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLGtCQUFrQixrQkFBa0IsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L3hoci5qcz9jMTJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VDbGllbnQsIEJhc2VSZXNwb25zZSB9IGZyb20gJy4vYmFzZS5qcyc7XG5pbXBvcnQgeyBBYm9ydEVycm9yIH0gZnJvbSAnLi4vLi4vdXRpbHMuanMnO1xuXG5jbGFzcyBYSFJSZXNwb25zZSBleHRlbmRzIEJhc2VSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBCYXNlUmVzcG9uc2UgZmFjYWRlIGZvciBYTUxIdHRwUmVxdWVzdFxuICAgKiBAcGFyYW0ge1hNTEh0dHBSZXF1ZXN0fSB4aHJcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YVxuICAgKi9cbiAgY29uc3RydWN0b3IoeGhyLCBkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnhociA9IHhocjtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG5cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy54aHIuc3RhdHVzO1xuICB9XG5cbiAgZ2V0SGVhZGVyKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIobmFtZSk7XG4gIH1cblxuICBhc3luYyBnZXREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFhIUkNsaWVudCBleHRlbmRzIEJhc2VDbGllbnQge1xuICBjb25zdHJ1Y3RSZXF1ZXN0KGhlYWRlcnMsIHNpZ25hbCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHhoci5vcGVuKCdHRVQnLCB0aGlzLnVybCk7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBob29rIHNpZ25hbHNcbiAgICAgIHhoci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB4aHIucmVzcG9uc2U7XG4gICAgICAgIHJlc29sdmUobmV3IFhIUlJlc3BvbnNlKHhociwgZGF0YSkpO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgeGhyLm9uYWJvcnQgPSAoKSA9PiByZWplY3QobmV3IEFib3J0RXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCcpKTtcbiAgICAgIHhoci5zZW5kKCk7XG5cbiAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4geGhyLmFib3J0KCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgcmVxdWVzdCh7IGhlYWRlcnMsIHNpZ25hbCB9ID0ge30pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY29uc3RydWN0UmVxdWVzdChoZWFkZXJzLCBzaWduYWwpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/xhr.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/source/file.js":
/*!*********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/file.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeFileSource: function() { return /* binding */ makeFileSource; }\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"?5a99\");\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basesource.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/basesource.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\n\n\nfunction closeAsync(fd) {\n  return new Promise((resolve, reject) => {\n    fs__WEBPACK_IMPORTED_MODULE_0__.close(fd, (err) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nfunction openAsync(path, flags, mode = undefined) {\n  return new Promise((resolve, reject) => {\n    fs__WEBPACK_IMPORTED_MODULE_0__.open(path, flags, mode, (err, fd) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(fd);\n      }\n    });\n  });\n}\n\nfunction readAsync(...args) {\n  return new Promise((resolve, reject) => {\n    fs__WEBPACK_IMPORTED_MODULE_0__.read(...args, (err, bytesRead, buffer) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve({ bytesRead, buffer });\n      }\n    });\n  });\n}\n\nclass FileSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_1__.BaseSource {\n  constructor(path) {\n    super();\n    this.path = path;\n    this.openRequest = openAsync(path, 'r');\n  }\n\n  async fetchSlice(slice) {\n    // TODO: use `signal`\n    const fd = await this.openRequest;\n    const { buffer } = await readAsync(\n      fd,\n      Buffer.alloc(slice.length),\n      0,\n      slice.length,\n      slice.offset,\n    );\n    return buffer.buffer;\n  }\n\n  async close() {\n    const fd = await this.openRequest;\n    await closeAsync(fd);\n  }\n}\n\nfunction makeFileSource(path) {\n  return new FileSource(path);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9maWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBb0I7QUFDeUI7O0FBRTdDO0FBQ0E7QUFDQSxJQUFJLHFDQUFRO0FBQ1o7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxvQ0FBTztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLElBQUksb0NBQU87QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBLHlCQUF5QixzREFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBLE1BQU0sTUFBTTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvZmlsZS5qcz80Mzg3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgeyBCYXNlU291cmNlIH0gZnJvbSAnLi9iYXNlc291cmNlLmpzJztcblxuZnVuY3Rpb24gY2xvc2VBc3luYyhmZCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZzLmNsb3NlKGZkLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb3BlbkFzeW5jKHBhdGgsIGZsYWdzLCBtb2RlID0gdW5kZWZpbmVkKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMub3BlbihwYXRoLCBmbGFncywgbW9kZSwgKGVyciwgZmQpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKGZkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRBc3luYyguLi5hcmdzKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMucmVhZCguLi5hcmdzLCAoZXJyLCBieXRlc1JlYWQsIGJ1ZmZlcikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoeyBieXRlc1JlYWQsIGJ1ZmZlciB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmNsYXNzIEZpbGVTb3VyY2UgZXh0ZW5kcyBCYXNlU291cmNlIHtcbiAgY29uc3RydWN0b3IocGF0aCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLm9wZW5SZXF1ZXN0ID0gb3BlbkFzeW5jKHBhdGgsICdyJyk7XG4gIH1cblxuICBhc3luYyBmZXRjaFNsaWNlKHNsaWNlKSB7XG4gICAgLy8gVE9ETzogdXNlIGBzaWduYWxgXG4gICAgY29uc3QgZmQgPSBhd2FpdCB0aGlzLm9wZW5SZXF1ZXN0O1xuICAgIGNvbnN0IHsgYnVmZmVyIH0gPSBhd2FpdCByZWFkQXN5bmMoXG4gICAgICBmZCxcbiAgICAgIEJ1ZmZlci5hbGxvYyhzbGljZS5sZW5ndGgpLFxuICAgICAgMCxcbiAgICAgIHNsaWNlLmxlbmd0aCxcbiAgICAgIHNsaWNlLm9mZnNldCxcbiAgICApO1xuICAgIHJldHVybiBidWZmZXIuYnVmZmVyO1xuICB9XG5cbiAgYXN5bmMgY2xvc2UoKSB7XG4gICAgY29uc3QgZmQgPSBhd2FpdCB0aGlzLm9wZW5SZXF1ZXN0O1xuICAgIGF3YWl0IGNsb3NlQXN5bmMoZmQpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRmlsZVNvdXJjZShwYXRoKSB7XG4gIHJldHVybiBuZXcgRmlsZVNvdXJjZShwYXRoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/source/file.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/source/filereader.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/filereader.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeFileReaderSource: function() { return /* binding */ makeFileReaderSource; }\n/* harmony export */ });\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basesource.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/basesource.js\");\n\n\nclass FileReaderSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_0__.BaseSource {\n  constructor(file) {\n    super();\n    this.file = file;\n  }\n\n  async fetchSlice(slice, signal) {\n    return new Promise((resolve, reject) => {\n      const blob = this.file.slice(slice.offset, slice.offset + slice.length);\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event.target.result);\n      reader.onerror = reject;\n      reader.onabort = reject;\n      reader.readAsArrayBuffer(blob);\n\n      if (signal) {\n        signal.addEventListener('abort', () => reader.abort());\n      }\n    });\n  }\n}\n\n/**\n * Create a new source from a given file/blob.\n * @param {Blob} file The file or blob to read from.\n * @returns The constructed source\n */\nfunction makeFileReaderSource(file) {\n  return new FileReaderSource(file);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9maWxlcmVhZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTZDOztBQUU3QywrQkFBK0Isc0RBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvc291cmNlL2ZpbGVyZWFkZXIuanM/YTY4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlU291cmNlIH0gZnJvbSAnLi9iYXNlc291cmNlLmpzJztcblxuY2xhc3MgRmlsZVJlYWRlclNvdXJjZSBleHRlbmRzIEJhc2VTb3VyY2Uge1xuICBjb25zdHJ1Y3RvcihmaWxlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICB9XG5cbiAgYXN5bmMgZmV0Y2hTbGljZShzbGljZSwgc2lnbmFsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGJsb2IgPSB0aGlzLmZpbGUuc2xpY2Uoc2xpY2Uub2Zmc2V0LCBzbGljZS5vZmZzZXQgKyBzbGljZS5sZW5ndGgpO1xuICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSAoZXZlbnQpID0+IHJlc29sdmUoZXZlbnQudGFyZ2V0LnJlc3VsdCk7XG4gICAgICByZWFkZXIub25lcnJvciA9IHJlamVjdDtcbiAgICAgIHJlYWRlci5vbmFib3J0ID0gcmVqZWN0O1xuICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xuXG4gICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHJlYWRlci5hYm9ydCgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzb3VyY2UgZnJvbSBhIGdpdmVuIGZpbGUvYmxvYi5cbiAqIEBwYXJhbSB7QmxvYn0gZmlsZSBUaGUgZmlsZSBvciBibG9iIHRvIHJlYWQgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBjb25zdHJ1Y3RlZCBzb3VyY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VGaWxlUmVhZGVyU291cmNlKGZpbGUpIHtcbiAgcmV0dXJuIG5ldyBGaWxlUmVhZGVyU291cmNlKGZpbGUpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/source/filereader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/source/httputils.js":
/*!**************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/httputils.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseByteRanges: function() { return /* binding */ parseByteRanges; },\n/* harmony export */   parseContentRange: function() { return /* binding */ parseContentRange; },\n/* harmony export */   parseContentType: function() { return /* binding */ parseContentType; }\n/* harmony export */ });\nconst CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nfunction parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nfunction parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nfunction parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9odHRwdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNPO0FBQ1Asc0RBQXNEO0FBQ3REO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLFNBQVM7QUFDdEMseUJBQXlCLGNBQWM7O0FBRXZDO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksb0JBQW9COztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvaHR0cHV0aWxzLmpzP2NiMTciXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQ1JMRkNSTEYgPSAnXFxyXFxuXFxyXFxuJztcblxuLypcbiAqIFNoaW0gZm9yICdPYmplY3QuZnJvbUVudHJpZXMnXG4gKi9cbmZ1bmN0aW9uIGl0ZW1zVG9PYmplY3QoaXRlbXMpIHtcbiAgaWYgKHR5cGVvZiBPYmplY3QuZnJvbUVudHJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhpdGVtcyk7XG4gIH1cbiAgY29uc3Qgb2JqID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGl0ZW1zKSB7XG4gICAgb2JqW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogUGFyc2UgSFRUUCBoZWFkZXJzIGZyb20gYSBnaXZlbiBzdHJpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0aGUgdGV4dCB0byBwYXJzZSB0aGUgaGVhZGVycyBmcm9tXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgcGFyc2VkIGhlYWRlcnMgd2l0aCBsb3dlcmNhc2Uga2V5c1xuICovXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnModGV4dCkge1xuICBjb25zdCBpdGVtcyA9IHRleHRcbiAgICAuc3BsaXQoJ1xcclxcbicpXG4gICAgLm1hcCgobGluZSkgPT4ge1xuICAgICAgY29uc3Qga3YgPSBsaW5lLnNwbGl0KCc6JykubWFwKChzdHIpID0+IHN0ci50cmltKCkpO1xuICAgICAga3ZbMF0gPSBrdlswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIGt2O1xuICAgIH0pO1xuXG4gIHJldHVybiBpdGVtc1RvT2JqZWN0KGl0ZW1zKTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhICdDb250ZW50LVR5cGUnIGhlYWRlciB2YWx1ZSB0byB0aGUgY29udGVudC10eXBlIGFuZCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3Q29udGVudFR5cGUgdGhlIHJhdyBzdHJpbmcgdG8gcGFyc2UgZnJvbVxuICogQHJldHVybnMge09iamVjdH0gdGhlIHBhcnNlZCBjb250ZW50IHR5cGUgd2l0aCB0aGUgZmllbGRzOiB0eXBlIGFuZCBwYXJhbXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29udGVudFR5cGUocmF3Q29udGVudFR5cGUpIHtcbiAgY29uc3QgW3R5cGUsIC4uLnJhd1BhcmFtc10gPSByYXdDb250ZW50VHlwZS5zcGxpdCgnOycpLm1hcCgocykgPT4gcy50cmltKCkpO1xuICBjb25zdCBwYXJhbXNJdGVtcyA9IHJhd1BhcmFtcy5tYXAoKHBhcmFtKSA9PiBwYXJhbS5zcGxpdCgnPScpKTtcbiAgcmV0dXJuIHsgdHlwZSwgcGFyYW1zOiBpdGVtc1RvT2JqZWN0KHBhcmFtc0l0ZW1zKSB9O1xufVxuXG4vKipcbiAqIFBhcnNlIGEgJ0NvbnRlbnQtUmFuZ2UnIGhlYWRlciB2YWx1ZSB0byBpdHMgc3RhcnQsIGVuZCwgYW5kIHRvdGFsIHBhcnRzXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3Q29udGVudFJhbmdlIHRoZSByYXcgc3RyaW5nIHRvIHBhcnNlIGZyb21cbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBwYXJzZWQgcGFydHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29udGVudFJhbmdlKHJhd0NvbnRlbnRSYW5nZSkge1xuICBsZXQgc3RhcnQ7XG4gIGxldCBlbmQ7XG4gIGxldCB0b3RhbDtcblxuICBpZiAocmF3Q29udGVudFJhbmdlKSB7XG4gICAgWywgc3RhcnQsIGVuZCwgdG90YWxdID0gcmF3Q29udGVudFJhbmdlLm1hdGNoKC9ieXRlcyAoXFxkKyktKFxcZCspXFwvKFxcZCspLyk7XG4gICAgc3RhcnQgPSBwYXJzZUludChzdGFydCwgMTApO1xuICAgIGVuZCA9IHBhcnNlSW50KGVuZCwgMTApO1xuICAgIHRvdGFsID0gcGFyc2VJbnQodG90YWwsIDEwKTtcbiAgfVxuXG4gIHJldHVybiB7IHN0YXJ0LCBlbmQsIHRvdGFsIH07XG59XG5cbi8qKlxuICogUGFyc2VzIGEgbGlzdCBvZiBieXRlcmFuZ2VzIGZyb20gdGhlIGdpdmVuICdtdWx0aXBhcnQvYnl0ZXJhbmdlcycgSFRUUCByZXNwb25zZS5cbiAqIEVhY2ggaXRlbSBpbiB0aGUgbGlzdCBoYXMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogLSBoZWFkZXJzOiB0aGUgSFRUUCBoZWFkZXJzXG4gKiAtIGRhdGE6IHRoZSBzbGljZWQgQXJyYXlCdWZmZXIgZm9yIHRoYXQgc3BlY2lmaWMgcGFydFxuICogLSBvZmZzZXQ6IHRoZSBvZmZzZXQgb2YgdGhlIGJ5dGVyYW5nZSB3aXRoaW4gaXRzIG9yaWdpbmF0aW5nIGZpbGVcbiAqIC0gbGVuZ3RoOiB0aGUgbGVuZ3RoIG9mIHRoZSBieXRlcmFuZ2VcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IHJlc3BvbnNlQXJyYXlCdWZmZXIgdGhlIHJlc3BvbnNlIHRvIGJlIHBhcnNlZCBhbmQgc3BsaXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBib3VuZGFyeSB0aGUgYm91bmRhcnkgc3RyaW5nIHVzZWQgdG8gc3BsaXQgdGhlIHNlY3Rpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0W119IHRoZSBwYXJzZWQgYnl0ZXJhbmdlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VCeXRlUmFuZ2VzKHJlc3BvbnNlQXJyYXlCdWZmZXIsIGJvdW5kYXJ5KSB7XG4gIGxldCBvZmZzZXQgPSBudWxsO1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCdhc2NpaScpO1xuICBjb25zdCBvdXQgPSBbXTtcblxuICBjb25zdCBzdGFydEJvdW5kYXJ5ID0gYC0tJHtib3VuZGFyeX1gO1xuICBjb25zdCBlbmRCb3VuZGFyeSA9IGAke3N0YXJ0Qm91bmRhcnl9LS1gO1xuXG4gIC8vIHNlYXJjaCBmb3IgdGhlIGluaXRpYWwgYm91bmRhcnksIG1heSBiZSBvZmZzZXQgYnkgc29tZSBieXRlc1xuICAvLyBUT0RPOiBtb3JlIGVmZmljaWVudCB0byBjaGVjayBmb3IgYC0tYCBpbiBieXRlcyBkaXJlY3RseVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyArK2kpIHtcbiAgICBjb25zdCB0ZXh0ID0gZGVjb2Rlci5kZWNvZGUoXG4gICAgICBuZXcgVWludDhBcnJheShyZXNwb25zZUFycmF5QnVmZmVyLCBpLCBzdGFydEJvdW5kYXJ5Lmxlbmd0aCksXG4gICAgKTtcbiAgICBpZiAodGV4dCA9PT0gc3RhcnRCb3VuZGFyeSkge1xuICAgICAgb2Zmc2V0ID0gaTtcbiAgICB9XG4gIH1cblxuICBpZiAob2Zmc2V0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBpbml0aWFsIGJvdW5kYXJ5Jyk7XG4gIH1cblxuICB3aGlsZSAob2Zmc2V0IDwgcmVzcG9uc2VBcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgY29uc3QgdGV4dCA9IGRlY29kZXIuZGVjb2RlKFxuICAgICAgbmV3IFVpbnQ4QXJyYXkocmVzcG9uc2VBcnJheUJ1ZmZlciwgb2Zmc2V0LFxuICAgICAgICBNYXRoLm1pbihzdGFydEJvdW5kYXJ5Lmxlbmd0aCArIDEwMjQsIHJlc3BvbnNlQXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCAtIG9mZnNldCksXG4gICAgICApLFxuICAgICk7XG5cbiAgICAvLyBicmVhayBpZiB3ZSBhcnJpdmVkIGF0IHRoZSBlbmRcbiAgICBpZiAodGV4dC5sZW5ndGggPT09IDAgfHwgdGV4dC5zdGFydHNXaXRoKGVuZEJvdW5kYXJ5KSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gYXNzZXJ0IHRoYXQgd2UgYXJlIGFjdHVhbGx5IGRlYWxpbmcgd2l0aCBhIGJ5dGVyYW5nZSBhbmQgYXJlIGF0IHRoZSBjb3JyZWN0IG9mZnNldFxuICAgIGlmICghdGV4dC5zdGFydHNXaXRoKHN0YXJ0Qm91bmRhcnkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnQgZG9lcyBub3Qgc3RhcnQgd2l0aCBib3VuZGFyeScpO1xuICAgIH1cblxuICAgIC8vIGdldCBhIHN1YnN0cmluZyBmcm9tIHdoZXJlIHdlIHJlYWQgdGhlIGhlYWRlcnNcbiAgICBjb25zdCBpbm5lclRleHQgPSB0ZXh0LnN1YnN0cihzdGFydEJvdW5kYXJ5Lmxlbmd0aCArIDIpO1xuXG4gICAgaWYgKGlubmVyVGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIGZpbmQgdGhlIGRvdWJsZSBsaW5lYnJlYWsgdGhhdCBkZW5vdGVzIHRoZSBlbmQgb2YgdGhlIGhlYWRlcnNcbiAgICBjb25zdCBlbmRPZkhlYWRlcnMgPSBpbm5lclRleHQuaW5kZXhPZihDUkxGQ1JMRik7XG5cbiAgICAvLyBwYXJzZSB0aGUgaGVhZGVycyB0byBnZXQgdGhlIGNvbnRlbnQgcmFuZ2Ugc2l6ZVxuICAgIGNvbnN0IGhlYWRlcnMgPSBwYXJzZUhlYWRlcnMoaW5uZXJUZXh0LnN1YnN0cigwLCBlbmRPZkhlYWRlcnMpKTtcbiAgICBjb25zdCB7IHN0YXJ0LCBlbmQsIHRvdGFsIH0gPSBwYXJzZUNvbnRlbnRSYW5nZShoZWFkZXJzWydjb250ZW50LXJhbmdlJ10pO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBsZW5ndGggb2YgdGhlIHNsaWNlIGFuZCB0aGUgbmV4dCBvZmZzZXRcbiAgICBjb25zdCBzdGFydE9mRGF0YSA9IG9mZnNldCArIHN0YXJ0Qm91bmRhcnkubGVuZ3RoICsgZW5kT2ZIZWFkZXJzICsgQ1JMRkNSTEYubGVuZ3RoO1xuICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KGVuZCwgMTApICsgMSAtIHBhcnNlSW50KHN0YXJ0LCAxMCk7XG4gICAgb3V0LnB1c2goe1xuICAgICAgaGVhZGVycyxcbiAgICAgIGRhdGE6IHJlc3BvbnNlQXJyYXlCdWZmZXIuc2xpY2Uoc3RhcnRPZkRhdGEsIHN0YXJ0T2ZEYXRhICsgbGVuZ3RoKSxcbiAgICAgIG9mZnNldDogc3RhcnQsXG4gICAgICBsZW5ndGgsXG4gICAgICBmaWxlU2l6ZTogdG90YWwsXG4gICAgfSk7XG5cbiAgICBvZmZzZXQgPSBzdGFydE9mRGF0YSArIGxlbmd0aCArIDQ7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/source/httputils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/source/remote.js":
/*!***********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/remote.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeCustomSource: function() { return /* binding */ makeCustomSource; },\n/* harmony export */   makeFetchSource: function() { return /* binding */ makeFetchSource; },\n/* harmony export */   makeHttpSource: function() { return /* binding */ makeHttpSource; },\n/* harmony export */   makeRemoteSource: function() { return /* binding */ makeRemoteSource; },\n/* harmony export */   makeXHRSource: function() { return /* binding */ makeXHRSource; }\n/* harmony export */ });\n/* harmony import */ var _httputils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./httputils.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/httputils.js\");\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basesource.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/basesource.js\");\n/* harmony import */ var _blockedsource_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./blockedsource.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/blockedsource.js\");\n/* harmony import */ var _client_fetch_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./client/fetch.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/fetch.js\");\n/* harmony import */ var _client_xhr_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./client/xhr.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/xhr.js\");\n/* harmony import */ var _client_http_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./client/http.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/http.js\");\n\n\n\n\n\n\n\n\nclass RemoteSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_0__.BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_1__.parseContentType)(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_1__.parseByteRanges)(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_1__.parseContentRange)(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return only the first\n\n        // get the rest of the slices and fetch them iteratively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_1__.parseContentRange)(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new _blockedsource_js__WEBPACK_IMPORTED_MODULE_2__.BlockedSource(source, { blockSize, cacheSize });\n}\n\nfunction makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new _client_fetch_js__WEBPACK_IMPORTED_MODULE_3__.FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nfunction makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new _client_xhr_js__WEBPACK_IMPORTED_MODULE_4__.XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nfunction makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new _client_http_js__WEBPACK_IMPORTED_MODULE_5__.HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nfunction makeCustomSource(client, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nfunction makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9yZW1vdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBc0Y7QUFDekM7QUFDTTs7QUFFSDtBQUNKO0FBQ0U7O0FBRTlDLDJCQUEyQixzREFBVTtBQUNyQztBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsa0JBQWtCLGdCQUFnQixRQUFRLE9BQU8sR0FBRyxnQkFBZ0I7QUFDcEU7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBTTtBQUNOLGNBQWMsZUFBZSxFQUFFLCtEQUFnQjtBQUMvQztBQUNBLDJCQUEyQiw4REFBZTtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYyxvQkFBb0IsRUFBRSxnRUFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPLEdBQUcsZ0JBQWdCO0FBQ2xELE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBLGNBQWMsUUFBUSxFQUFFLGdFQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLHNCQUFzQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDREQUFhLFdBQVcsc0JBQXNCO0FBQzNEOztBQUVPLGdDQUFnQyxZQUFZLHVFQUF1RSxJQUFJO0FBQzlILHFCQUFxQix5REFBVztBQUNoQztBQUNBO0FBQ0E7O0FBRU8sOEJBQThCLFlBQVksMERBQTBELElBQUk7QUFDL0cscUJBQXFCLHFEQUFTO0FBQzlCO0FBQ0E7QUFDQTs7QUFFTywrQkFBK0IsWUFBWSwwREFBMEQsSUFBSTtBQUNoSCxxQkFBcUIsdURBQVU7QUFDL0I7QUFDQTtBQUNBOztBQUVPLG9DQUFvQyxZQUFZLDBEQUEwRCxJQUFJO0FBQ3JIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNPLGlDQUFpQyxxQ0FBcUMsSUFBSTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9yZW1vdGUuanM/ZWQ0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZUJ5dGVSYW5nZXMsIHBhcnNlQ29udGVudFJhbmdlLCBwYXJzZUNvbnRlbnRUeXBlIH0gZnJvbSAnLi9odHRwdXRpbHMuanMnO1xuaW1wb3J0IHsgQmFzZVNvdXJjZSB9IGZyb20gJy4vYmFzZXNvdXJjZS5qcyc7XG5pbXBvcnQgeyBCbG9ja2VkU291cmNlIH0gZnJvbSAnLi9ibG9ja2Vkc291cmNlLmpzJztcblxuaW1wb3J0IHsgRmV0Y2hDbGllbnQgfSBmcm9tICcuL2NsaWVudC9mZXRjaC5qcyc7XG5pbXBvcnQgeyBYSFJDbGllbnQgfSBmcm9tICcuL2NsaWVudC94aHIuanMnO1xuaW1wb3J0IHsgSHR0cENsaWVudCB9IGZyb20gJy4vY2xpZW50L2h0dHAuanMnO1xuXG5jbGFzcyBSZW1vdGVTb3VyY2UgZXh0ZW5kcyBCYXNlU291cmNlIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7QmFzZUNsaWVudH0gY2xpZW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBoZWFkZXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyc30gbWF4UmFuZ2VzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWxsb3dGdWxsRmlsZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY2xpZW50LCBoZWFkZXJzLCBtYXhSYW5nZXMsIGFsbG93RnVsbEZpbGUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgdGhpcy5tYXhSYW5nZXMgPSBtYXhSYW5nZXM7XG4gICAgdGhpcy5hbGxvd0Z1bGxGaWxlID0gYWxsb3dGdWxsRmlsZTtcbiAgICB0aGlzLl9maWxlU2l6ZSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtTbGljZVtdfSBzbGljZXNcbiAgICovXG4gIGFzeW5jIGZldGNoKHNsaWNlcywgc2lnbmFsKSB7XG4gICAgLy8gaWYgd2UgYWxsb3cgbXVsdGktcmFuZ2VzLCBzcGxpdCB0aGUgaW5jb21pbmcgcmVxdWVzdCBpbnRvIHRoYXQgbWFueSBzdWItcmVxdWVzdHNcbiAgICAvLyBhbmQgam9pbiB0aGVtIGFmdGVyd2FyZHNcbiAgICBpZiAodGhpcy5tYXhSYW5nZXMgPj0gc2xpY2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hTbGljZXMoc2xpY2VzLCBzaWduYWwpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXhSYW5nZXMgPiAwICYmIHNsaWNlcy5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBUT0RPOiBzcGxpdCBpbnRvIG11bHRpcGxlIG11bHRpLXJhbmdlIHJlcXVlc3RzXG5cbiAgICAgIC8vIGNvbnN0IHN1YlNsaWNlc1JlcXVlc3RzID0gW107XG4gICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWNlcy5sZW5ndGg7IGkgKz0gdGhpcy5tYXhSYW5nZXMpIHtcbiAgICAgIC8vICAgc3ViU2xpY2VzUmVxdWVzdHMucHVzaChcbiAgICAgIC8vICAgICB0aGlzLmZldGNoU2xpY2VzKHNsaWNlcy5zbGljZShpLCBpICsgdGhpcy5tYXhSYW5nZXMpLCBzaWduYWwpLFxuICAgICAgLy8gICApO1xuICAgICAgLy8gfVxuICAgICAgLy8gcmV0dXJuIChhd2FpdCBQcm9taXNlLmFsbChzdWJTbGljZXNSZXF1ZXN0cykpLmZsYXQoKTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UgbWFrZSBhIHNpbmdsZSByZXF1ZXN0IGZvciBlYWNoIHNsaWNlXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgc2xpY2VzLm1hcCgoc2xpY2UpID0+IHRoaXMuZmV0Y2hTbGljZShzbGljZSwgc2lnbmFsKSksXG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIGZldGNoU2xpY2VzKHNsaWNlcywgc2lnbmFsKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4udGhpcy5oZWFkZXJzLFxuICAgICAgICBSYW5nZTogYGJ5dGVzPSR7c2xpY2VzXG4gICAgICAgICAgLm1hcCgoeyBvZmZzZXQsIGxlbmd0aCB9KSA9PiBgJHtvZmZzZXR9LSR7b2Zmc2V0ICsgbGVuZ3RofWApXG4gICAgICAgICAgLmpvaW4oJywnKVxuICAgICAgICB9YCxcbiAgICAgIH0sXG4gICAgICBzaWduYWwsXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGZldGNoaW5nIGRhdGEuJyk7XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwNikge1xuICAgICAgY29uc3QgeyB0eXBlLCBwYXJhbXMgfSA9IHBhcnNlQ29udGVudFR5cGUocmVzcG9uc2UuZ2V0SGVhZGVyKCdjb250ZW50LXR5cGUnKSk7XG4gICAgICBpZiAodHlwZSA9PT0gJ211bHRpcGFydC9ieXRlcmFuZ2VzJykge1xuICAgICAgICBjb25zdCBieXRlUmFuZ2VzID0gcGFyc2VCeXRlUmFuZ2VzKGF3YWl0IHJlc3BvbnNlLmdldERhdGEoKSwgcGFyYW1zLmJvdW5kYXJ5KTtcbiAgICAgICAgdGhpcy5fZmlsZVNpemUgPSBieXRlUmFuZ2VzWzBdLmZpbGVTaXplIHx8IG51bGw7XG4gICAgICAgIHJldHVybiBieXRlUmFuZ2VzO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuZ2V0RGF0YSgpO1xuXG4gICAgICBjb25zdCB7IHN0YXJ0LCBlbmQsIHRvdGFsIH0gPSBwYXJzZUNvbnRlbnRSYW5nZShyZXNwb25zZS5nZXRIZWFkZXIoJ2NvbnRlbnQtcmFuZ2UnKSk7XG4gICAgICB0aGlzLl9maWxlU2l6ZSA9IHRvdGFsIHx8IG51bGw7XG4gICAgICBjb25zdCBmaXJzdCA9IFt7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIG9mZnNldDogc3RhcnQsXG4gICAgICAgIGxlbmd0aDogZW5kIC0gc3RhcnQsXG4gICAgICB9XTtcblxuICAgICAgaWYgKHNsaWNlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIHdlIHJlcXVlc3RlZCBtb3JlIHRoYW4gb25lIHNsaWNlLCBidXQgZ290IG9ubHkgdGhlIGZpcnN0XG4gICAgICAgIC8vIHVuZm9ydHVuYXRlbHksIHNvbWUgSFRUUCBTZXJ2ZXJzIGRvbid0IHN1cHBvcnQgbXVsdGktcmFuZ2VzXG4gICAgICAgIC8vIGFuZCByZXR1cm4gb25seSB0aGUgZmlyc3RcblxuICAgICAgICAvLyBnZXQgdGhlIHJlc3Qgb2YgdGhlIHNsaWNlcyBhbmQgZmV0Y2ggdGhlbSBpdGVyYXRpdmVseVxuICAgICAgICBjb25zdCBvdGhlcnMgPSBhd2FpdCBQcm9taXNlLmFsbChzbGljZXMuc2xpY2UoMSkubWFwKChzbGljZSkgPT4gdGhpcy5mZXRjaFNsaWNlKHNsaWNlLCBzaWduYWwpKSk7XG4gICAgICAgIHJldHVybiBmaXJzdC5jb25jYXQob3RoZXJzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaXJzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLmFsbG93RnVsbEZpbGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggZnVsbCBmaWxlJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuZ2V0RGF0YSgpO1xuICAgICAgdGhpcy5fZmlsZVNpemUgPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgZGF0YSxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBsZW5ndGg6IGRhdGEuYnl0ZUxlbmd0aCxcbiAgICAgIH1dO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZldGNoU2xpY2Uoc2xpY2UsIHNpZ25hbCkge1xuICAgIGNvbnN0IHsgb2Zmc2V0LCBsZW5ndGggfSA9IHNsaWNlO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLnRoaXMuaGVhZGVycyxcbiAgICAgICAgUmFuZ2U6IGBieXRlcz0ke29mZnNldH0tJHtvZmZzZXQgKyBsZW5ndGh9YCxcbiAgICAgIH0sXG4gICAgICBzaWduYWwsXG4gICAgfSk7XG5cbiAgICAvLyBjaGVjayB0aGUgcmVzcG9uc2Ugd2FzIG9rYXkgYW5kIGlmIHRoZSBzZXJ2ZXIgYWN0dWFsbHkgdW5kZXJzdGFuZHMgcmFuZ2UgcmVxdWVzdHNcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGZldGNoaW5nIGRhdGEuJyk7XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwNikge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmdldERhdGEoKTtcblxuICAgICAgY29uc3QgeyB0b3RhbCB9ID0gcGFyc2VDb250ZW50UmFuZ2UocmVzcG9uc2UuZ2V0SGVhZGVyKCdjb250ZW50LXJhbmdlJykpO1xuICAgICAgdGhpcy5fZmlsZVNpemUgPSB0b3RhbCB8fCBudWxsO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBsZW5ndGgsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuYWxsb3dGdWxsRmlsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlciByZXNwb25kZWQgd2l0aCBmdWxsIGZpbGUnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmdldERhdGEoKTtcblxuICAgICAgdGhpcy5fZmlsZVNpemUgPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhLFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIGxlbmd0aDogZGF0YS5ieXRlTGVuZ3RoLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBnZXQgZmlsZVNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVTaXplO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlV3JhcEluQmxvY2tlZFNvdXJjZShzb3VyY2UsIHsgYmxvY2tTaXplLCBjYWNoZVNpemUgfSkge1xuICBpZiAoYmxvY2tTaXplID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuICByZXR1cm4gbmV3IEJsb2NrZWRTb3VyY2Uoc291cmNlLCB7IGJsb2NrU2l6ZSwgY2FjaGVTaXplIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZUZldGNoU291cmNlKHVybCwgeyBoZWFkZXJzID0ge30sIGNyZWRlbnRpYWxzLCBtYXhSYW5nZXMgPSAwLCBhbGxvd0Z1bGxGaWxlID0gZmFsc2UsIC4uLmJsb2NrT3B0aW9ucyB9ID0ge30pIHtcbiAgY29uc3QgY2xpZW50ID0gbmV3IEZldGNoQ2xpZW50KHVybCwgY3JlZGVudGlhbHMpO1xuICBjb25zdCBzb3VyY2UgPSBuZXcgUmVtb3RlU291cmNlKGNsaWVudCwgaGVhZGVycywgbWF4UmFuZ2VzLCBhbGxvd0Z1bGxGaWxlKTtcbiAgcmV0dXJuIG1heWJlV3JhcEluQmxvY2tlZFNvdXJjZShzb3VyY2UsIGJsb2NrT3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlWEhSU291cmNlKHVybCwgeyBoZWFkZXJzID0ge30sIG1heFJhbmdlcyA9IDAsIGFsbG93RnVsbEZpbGUgPSBmYWxzZSwgLi4uYmxvY2tPcHRpb25zIH0gPSB7fSkge1xuICBjb25zdCBjbGllbnQgPSBuZXcgWEhSQ2xpZW50KHVybCk7XG4gIGNvbnN0IHNvdXJjZSA9IG5ldyBSZW1vdGVTb3VyY2UoY2xpZW50LCBoZWFkZXJzLCBtYXhSYW5nZXMsIGFsbG93RnVsbEZpbGUpO1xuICByZXR1cm4gbWF5YmVXcmFwSW5CbG9ja2VkU291cmNlKHNvdXJjZSwgYmxvY2tPcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VIdHRwU291cmNlKHVybCwgeyBoZWFkZXJzID0ge30sIG1heFJhbmdlcyA9IDAsIGFsbG93RnVsbEZpbGUgPSBmYWxzZSwgLi4uYmxvY2tPcHRpb25zIH0gPSB7fSkge1xuICBjb25zdCBjbGllbnQgPSBuZXcgSHR0cENsaWVudCh1cmwpO1xuICBjb25zdCBzb3VyY2UgPSBuZXcgUmVtb3RlU291cmNlKGNsaWVudCwgaGVhZGVycywgbWF4UmFuZ2VzLCBhbGxvd0Z1bGxGaWxlKTtcbiAgcmV0dXJuIG1heWJlV3JhcEluQmxvY2tlZFNvdXJjZShzb3VyY2UsIGJsb2NrT3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQ3VzdG9tU291cmNlKGNsaWVudCwgeyBoZWFkZXJzID0ge30sIG1heFJhbmdlcyA9IDAsIGFsbG93RnVsbEZpbGUgPSBmYWxzZSwgLi4uYmxvY2tPcHRpb25zIH0gPSB7fSkge1xuICBjb25zdCBzb3VyY2UgPSBuZXcgUmVtb3RlU291cmNlKGNsaWVudCwgaGVhZGVycywgbWF4UmFuZ2VzLCBhbGxvd0Z1bGxGaWxlKTtcbiAgcmV0dXJuIG1heWJlV3JhcEluQmxvY2tlZFNvdXJjZShzb3VyY2UsIGJsb2NrT3B0aW9ucyk7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUmVtb3RlU291cmNlKHVybCwgeyBmb3JjZVhIUiA9IGZhbHNlLCAuLi5jbGllbnRPcHRpb25zIH0gPSB7fSkge1xuICBpZiAodHlwZW9mIGZldGNoID09PSAnZnVuY3Rpb24nICYmICFmb3JjZVhIUikge1xuICAgIHJldHVybiBtYWtlRmV0Y2hTb3VyY2UodXJsLCBjbGllbnRPcHRpb25zKTtcbiAgfVxuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBtYWtlWEhSU291cmNlKHVybCwgY2xpZW50T3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIG1ha2VIdHRwU291cmNlKHVybCwgY2xpZW50T3B0aW9ucyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/source/remote.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/utils.js":
/*!***************************************************!*\
  !*** ./node_modules/geotiff/dist-module/utils.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortError: function() { return /* binding */ AbortError; },\n/* harmony export */   AggregateError: function() { return /* binding */ AggregateError; },\n/* harmony export */   CustomAggregateError: function() { return /* binding */ CustomAggregateError; },\n/* harmony export */   assign: function() { return /* binding */ assign; },\n/* harmony export */   chunk: function() { return /* binding */ chunk; },\n/* harmony export */   endsWith: function() { return /* binding */ endsWith; },\n/* harmony export */   forEach: function() { return /* binding */ forEach; },\n/* harmony export */   invert: function() { return /* binding */ invert; },\n/* harmony export */   parseContentRange: function() { return /* binding */ parseContentRange; },\n/* harmony export */   range: function() { return /* binding */ range; },\n/* harmony export */   times: function() { return /* binding */ times; },\n/* harmony export */   toArray: function() { return /* binding */ toArray; },\n/* harmony export */   toArrayRecursively: function() { return /* binding */ toArrayRecursively; },\n/* harmony export */   wait: function() { return /* binding */ wait; },\n/* harmony export */   zip: function() { return /* binding */ zip; }\n/* harmony export */ });\nfunction assign(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nfunction chunk(iterable, length) {\n  const results = [];\n  const lengthOfIterable = iterable.length;\n  for (let i = 0; i < lengthOfIterable; i += length) {\n    const chunked = [];\n    for (let ci = i; ci < i + length; ci++) {\n      chunked.push(iterable[ci]);\n    }\n    results.push(chunked);\n  }\n  return results;\n}\n\nfunction endsWith(string, expectedEnding) {\n  if (string.length < expectedEnding.length) {\n    return false;\n  }\n  const actualEnding = string.substr(string.length - expectedEnding.length);\n  return actualEnding === expectedEnding;\n}\n\nfunction forEach(iterable, func) {\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    func(iterable[i], i);\n  }\n}\n\nfunction invert(oldObj) {\n  const newObj = {};\n  for (const key in oldObj) {\n    if (oldObj.hasOwnProperty(key)) {\n      const value = oldObj[key];\n      newObj[value] = key;\n    }\n  }\n  return newObj;\n}\n\nfunction range(n) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(i);\n  }\n  return results;\n}\n\nfunction times(numTimes, func) {\n  const results = [];\n  for (let i = 0; i < numTimes; i++) {\n    results.push(func(i));\n  }\n  return results;\n}\n\nfunction toArray(iterable) {\n  const results = [];\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    results.push(iterable[i]);\n  }\n  return results;\n}\n\nfunction toArrayRecursively(input) {\n  if (input.length) {\n    return toArray(input).map(toArrayRecursively);\n  }\n  return input;\n}\n\n// copied from https://github.com/academia-de-codigo/parse-content-range-header/blob/master/index.js\nfunction parseContentRange(headerValue) {\n  if (!headerValue) {\n    return null;\n  }\n\n  if (typeof headerValue !== 'string') {\n    throw new Error('invalid argument');\n  }\n\n  const parseInt = (number) => Number.parseInt(number, 10);\n\n  // Check for presence of unit\n  let matches = headerValue.match(/^(\\w*) /);\n  const unit = matches && matches[1];\n\n  // check for start-end/size header format\n  matches = headerValue.match(/(\\d+)-(\\d+)\\/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: parseInt(matches[1]),\n      last: parseInt(matches[2]),\n      length: matches[3] === '*' ? null : parseInt(matches[3]),\n    };\n  }\n\n  // check for size header format\n  matches = headerValue.match(/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: null,\n      last: null,\n      length: matches[1] === '*' ? null : parseInt(matches[1]),\n    };\n  }\n\n  return null;\n}\n\n/*\n * Promisified wrapper around 'setTimeout' to allow 'await'\n */\nasync function wait(milliseconds) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\nfunction zip(a, b) {\n  const A = Array.isArray(a) ? a : Array.from(a);\n  const B = Array.isArray(b) ? b : Array.from(b);\n  return A.map((k, i) => [k, B[i]]);\n}\n\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nclass AbortError extends Error {\n  constructor(params) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AbortError);\n    }\n\n    this.name = 'AbortError';\n  }\n}\n\nclass CustomAggregateError extends Error {\n  constructor(errors, message) {\n    super(message);\n    this.errors = errors;\n    this.message = message;\n    this.name = 'AggregateError';\n  }\n}\n\nconst AggregateError = CustomAggregateError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLFVBQVUsU0FBUztBQUNuQixrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0EsVUFBVSxTQUFTO0FBQ25CLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3V0aWxzLmpzPzk1ZTkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaHVuayhpdGVyYWJsZSwgbGVuZ3RoKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgY29uc3QgbGVuZ3RoT2ZJdGVyYWJsZSA9IGl0ZXJhYmxlLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGhPZkl0ZXJhYmxlOyBpICs9IGxlbmd0aCkge1xuICAgIGNvbnN0IGNodW5rZWQgPSBbXTtcbiAgICBmb3IgKGxldCBjaSA9IGk7IGNpIDwgaSArIGxlbmd0aDsgY2krKykge1xuICAgICAgY2h1bmtlZC5wdXNoKGl0ZXJhYmxlW2NpXSk7XG4gICAgfVxuICAgIHJlc3VsdHMucHVzaChjaHVua2VkKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuZHNXaXRoKHN0cmluZywgZXhwZWN0ZWRFbmRpbmcpIHtcbiAgaWYgKHN0cmluZy5sZW5ndGggPCBleHBlY3RlZEVuZGluZy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYWN0dWFsRW5kaW5nID0gc3RyaW5nLnN1YnN0cihzdHJpbmcubGVuZ3RoIC0gZXhwZWN0ZWRFbmRpbmcubGVuZ3RoKTtcbiAgcmV0dXJuIGFjdHVhbEVuZGluZyA9PT0gZXhwZWN0ZWRFbmRpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoKGl0ZXJhYmxlLCBmdW5jKSB7XG4gIGNvbnN0IHsgbGVuZ3RoIH0gPSBpdGVyYWJsZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGZ1bmMoaXRlcmFibGVbaV0sIGkpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob2xkT2JqKSB7XG4gIGNvbnN0IG5ld09iaiA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvbGRPYmopIHtcbiAgICBpZiAob2xkT2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2xkT2JqW2tleV07XG4gICAgICBuZXdPYmpbdmFsdWVdID0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3T2JqO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2Uobikge1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgcmVzdWx0cy5wdXNoKGkpO1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZXMobnVtVGltZXMsIGZ1bmMpIHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVRpbWVzOyBpKyspIHtcbiAgICByZXN1bHRzLnB1c2goZnVuYyhpKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0FycmF5KGl0ZXJhYmxlKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgY29uc3QgeyBsZW5ndGggfSA9IGl0ZXJhYmxlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0cy5wdXNoKGl0ZXJhYmxlW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvQXJyYXlSZWN1cnNpdmVseShpbnB1dCkge1xuICBpZiAoaW5wdXQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRvQXJyYXkoaW5wdXQpLm1hcCh0b0FycmF5UmVjdXJzaXZlbHkpO1xuICB9XG4gIHJldHVybiBpbnB1dDtcbn1cblxuLy8gY29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FjYWRlbWlhLWRlLWNvZGlnby9wYXJzZS1jb250ZW50LXJhbmdlLWhlYWRlci9ibG9iL21hc3Rlci9pbmRleC5qc1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29udGVudFJhbmdlKGhlYWRlclZhbHVlKSB7XG4gIGlmICghaGVhZGVyVmFsdWUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaGVhZGVyVmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBjb25zdCBwYXJzZUludCA9IChudW1iZXIpID0+IE51bWJlci5wYXJzZUludChudW1iZXIsIDEwKTtcblxuICAvLyBDaGVjayBmb3IgcHJlc2VuY2Ugb2YgdW5pdFxuICBsZXQgbWF0Y2hlcyA9IGhlYWRlclZhbHVlLm1hdGNoKC9eKFxcdyopIC8pO1xuICBjb25zdCB1bml0ID0gbWF0Y2hlcyAmJiBtYXRjaGVzWzFdO1xuXG4gIC8vIGNoZWNrIGZvciBzdGFydC1lbmQvc2l6ZSBoZWFkZXIgZm9ybWF0XG4gIG1hdGNoZXMgPSBoZWFkZXJWYWx1ZS5tYXRjaCgvKFxcZCspLShcXGQrKVxcLyhcXGQrfFxcKikvKTtcbiAgaWYgKG1hdGNoZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdW5pdCxcbiAgICAgIGZpcnN0OiBwYXJzZUludChtYXRjaGVzWzFdKSxcbiAgICAgIGxhc3Q6IHBhcnNlSW50KG1hdGNoZXNbMl0pLFxuICAgICAgbGVuZ3RoOiBtYXRjaGVzWzNdID09PSAnKicgPyBudWxsIDogcGFyc2VJbnQobWF0Y2hlc1szXSksXG4gICAgfTtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBzaXplIGhlYWRlciBmb3JtYXRcbiAgbWF0Y2hlcyA9IGhlYWRlclZhbHVlLm1hdGNoKC8oXFxkK3xcXCopLyk7XG4gIGlmIChtYXRjaGVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuaXQsXG4gICAgICBmaXJzdDogbnVsbCxcbiAgICAgIGxhc3Q6IG51bGwsXG4gICAgICBsZW5ndGg6IG1hdGNoZXNbMV0gPT09ICcqJyA/IG51bGwgOiBwYXJzZUludChtYXRjaGVzWzFdKSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qXG4gKiBQcm9taXNpZmllZCB3cmFwcGVyIGFyb3VuZCAnc2V0VGltZW91dCcgdG8gYWxsb3cgJ2F3YWl0J1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2FpdChtaWxsaXNlY29uZHMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1pbGxpc2Vjb25kcykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gemlwKGEsIGIpIHtcbiAgY29uc3QgQSA9IEFycmF5LmlzQXJyYXkoYSkgPyBhIDogQXJyYXkuZnJvbShhKTtcbiAgY29uc3QgQiA9IEFycmF5LmlzQXJyYXkoYikgPyBiIDogQXJyYXkuZnJvbShiKTtcbiAgcmV0dXJuIEEubWFwKChrLCBpKSA9PiBbaywgQltpXV0pO1xufVxuXG4vLyBCYXNlZCBvbiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvclxuZXhwb3J0IGNsYXNzIEFib3J0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIC8vIFBhc3MgcmVtYWluaW5nIGFyZ3VtZW50cyAoaW5jbHVkaW5nIHZlbmRvciBzcGVjaWZpYyBvbmVzKSB0byBwYXJlbnQgY29uc3RydWN0b3JcbiAgICBzdXBlcihwYXJhbXMpO1xuXG4gICAgLy8gTWFpbnRhaW5zIHByb3BlciBzdGFjayB0cmFjZSBmb3Igd2hlcmUgb3VyIGVycm9yIHdhcyB0aHJvd24gKG9ubHkgYXZhaWxhYmxlIG9uIFY4KVxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQWJvcnRFcnJvcik7XG4gICAgfVxuXG4gICAgdGhpcy5uYW1lID0gJ0Fib3J0RXJyb3InO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDdXN0b21BZ2dyZWdhdGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZXJyb3JzLCBtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLm5hbWUgPSAnQWdncmVnYXRlRXJyb3InO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBBZ2dyZWdhdGVFcnJvciA9IEN1c3RvbUFnZ3JlZ2F0ZUVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/quick-lru/index.js":
/*!*****************************************!*\
  !*** ./node_modules/quick-lru/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ QuickLRU; }\n/* harmony export */ });\nclass QuickLRU extends Map {\n\tconstructor(options = {}) {\n\t\tsuper();\n\n\t\tif (!(options.maxSize && options.maxSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tif (typeof options.maxAge === 'number' && options.maxAge === 0) {\n\t\t\tthrow new TypeError('`maxAge` must be a number greater than 0');\n\t\t}\n\n\t\t// TODO: Use private class fields when ESLint supports them.\n\t\tthis.maxSize = options.maxSize;\n\t\tthis.maxAge = options.maxAge || Number.POSITIVE_INFINITY;\n\t\tthis.onEviction = options.onEviction;\n\t\tthis.cache = new Map();\n\t\tthis.oldCache = new Map();\n\t\tthis._size = 0;\n\t}\n\n\t// TODO: Use private class methods when targeting Node.js 16.\n\t_emitEvictions(cache) {\n\t\tif (typeof this.onEviction !== 'function') {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const [key, item] of cache) {\n\t\t\tthis.onEviction(key, item.value);\n\t\t}\n\t}\n\n\t_deleteIfExpired(key, item) {\n\t\tif (typeof item.expiry === 'number' && item.expiry <= Date.now()) {\n\t\t\tif (typeof this.onEviction === 'function') {\n\t\t\t\tthis.onEviction(key, item.value);\n\t\t\t}\n\n\t\t\treturn this.delete(key);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_getOrDeleteIfExpired(key, item) {\n\t\tconst deleted = this._deleteIfExpired(key, item);\n\t\tif (deleted === false) {\n\t\t\treturn item.value;\n\t\t}\n\t}\n\n\t_getItemValue(key, item) {\n\t\treturn item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;\n\t}\n\n\t_peek(key, cache) {\n\t\tconst item = cache.get(key);\n\n\t\treturn this._getItemValue(key, item);\n\t}\n\n\t_set(key, value) {\n\t\tthis.cache.set(key, value);\n\t\tthis._size++;\n\n\t\tif (this._size >= this.maxSize) {\n\t\t\tthis._size = 0;\n\t\t\tthis._emitEvictions(this.oldCache);\n\t\t\tthis.oldCache = this.cache;\n\t\t\tthis.cache = new Map();\n\t\t}\n\t}\n\n\t_moveToRecent(key, item) {\n\t\tthis.oldCache.delete(key);\n\t\tthis._set(key, item);\n\t}\n\n\t* _entriesAscending() {\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield item;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\tget(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\tconst item = this.cache.get(key);\n\n\t\t\treturn this._getItemValue(key, item);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\tconst item = this.oldCache.get(key);\n\t\t\tif (this._deleteIfExpired(key, item) === false) {\n\t\t\t\tthis._moveToRecent(key, item);\n\t\t\t\treturn item.value;\n\t\t\t}\n\t\t}\n\t}\n\n\tset(key, value, {maxAge = this.maxAge} = {}) {\n\t\tconst expiry =\n\t\t\ttypeof maxAge === 'number' && maxAge !== Number.POSITIVE_INFINITY ?\n\t\t\t\tDate.now() + maxAge :\n\t\t\t\tundefined;\n\t\tif (this.cache.has(key)) {\n\t\t\tthis.cache.set(key, {\n\t\t\t\tvalue,\n\t\t\t\texpiry\n\t\t\t});\n\t\t} else {\n\t\t\tthis._set(key, {value, expiry});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\thas(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.cache.get(key));\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.oldCache.get(key));\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpeek(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this._peek(key, this.cache);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn this._peek(key, this.oldCache);\n\t\t}\n\t}\n\n\tdelete(key) {\n\t\tconst deleted = this.cache.delete(key);\n\t\tif (deleted) {\n\t\t\tthis._size--;\n\t\t}\n\n\t\treturn this.oldCache.delete(key) || deleted;\n\t}\n\n\tclear() {\n\t\tthis.cache.clear();\n\t\tthis.oldCache.clear();\n\t\tthis._size = 0;\n\t}\n\n\tresize(newSize) {\n\t\tif (!(newSize && newSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tconst items = [...this._entriesAscending()];\n\t\tconst removeCount = items.length - newSize;\n\t\tif (removeCount < 0) {\n\t\t\tthis.cache = new Map(items);\n\t\t\tthis.oldCache = new Map();\n\t\t\tthis._size = items.length;\n\t\t} else {\n\t\t\tif (removeCount > 0) {\n\t\t\t\tthis._emitEvictions(items.slice(0, removeCount));\n\t\t\t}\n\n\t\t\tthis.oldCache = new Map(items.slice(removeCount));\n\t\t\tthis.cache = new Map();\n\t\t\tthis._size = 0;\n\t\t}\n\n\t\tthis.maxSize = newSize;\n\t}\n\n\t* keys() {\n\t\tfor (const [key] of this) {\n\t\t\tyield key;\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const [, value] of this) {\n\t\t\tyield value;\n\t\t}\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesDescending() {\n\t\tlet items = [...this.cache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\titems = [...this.oldCache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesAscending() {\n\t\tfor (const [key, value] of this._entriesAscending()) {\n\t\t\tyield [key, value.value];\n\t\t}\n\t}\n\n\tget size() {\n\t\tif (!this._size) {\n\t\t\treturn this.oldCache.size;\n\t\t}\n\n\t\tlet oldCacheSize = 0;\n\t\tfor (const key of this.oldCache.keys()) {\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\toldCacheSize++;\n\t\t\t}\n\t\t}\n\n\t\treturn Math.min(this._size + oldCacheSize, this.maxSize);\n\t}\n\n\tentries() {\n\t\treturn this.entriesAscending();\n\t}\n\n\tforEach(callbackFunction, thisArgument = this) {\n\t\tfor (const [key, value] of this.entriesAscending()) {\n\t\t\tcallbackFunction.call(thisArgument, value, key, this);\n\t\t}\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn JSON.stringify([...this.entriesAscending()]);\n\t}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9xdWljay1scnUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2YseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQixJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSTtBQUNKLG1CQUFtQixjQUFjO0FBQ2pDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3F1aWNrLWxydS9pbmRleC5qcz9iMmE5Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1aWNrTFJVIGV4dGVuZHMgTWFwIHtcblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdGlmICghKG9wdGlvbnMubWF4U2l6ZSAmJiBvcHRpb25zLm1heFNpemUgPiAwKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignYG1heFNpemVgIG11c3QgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDAnKTtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIG9wdGlvbnMubWF4QWdlID09PSAnbnVtYmVyJyAmJiBvcHRpb25zLm1heEFnZSA9PT0gMCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignYG1heEFnZWAgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMCcpO1xuXHRcdH1cblxuXHRcdC8vIFRPRE86IFVzZSBwcml2YXRlIGNsYXNzIGZpZWxkcyB3aGVuIEVTTGludCBzdXBwb3J0cyB0aGVtLlxuXHRcdHRoaXMubWF4U2l6ZSA9IG9wdGlvbnMubWF4U2l6ZTtcblx0XHR0aGlzLm1heEFnZSA9IG9wdGlvbnMubWF4QWdlIHx8IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblx0XHR0aGlzLm9uRXZpY3Rpb24gPSBvcHRpb25zLm9uRXZpY3Rpb247XG5cdFx0dGhpcy5jYWNoZSA9IG5ldyBNYXAoKTtcblx0XHR0aGlzLm9sZENhY2hlID0gbmV3IE1hcCgpO1xuXHRcdHRoaXMuX3NpemUgPSAwO1xuXHR9XG5cblx0Ly8gVE9ETzogVXNlIHByaXZhdGUgY2xhc3MgbWV0aG9kcyB3aGVuIHRhcmdldGluZyBOb2RlLmpzIDE2LlxuXHRfZW1pdEV2aWN0aW9ucyhjYWNoZSkge1xuXHRcdGlmICh0eXBlb2YgdGhpcy5vbkV2aWN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBba2V5LCBpdGVtXSBvZiBjYWNoZSkge1xuXHRcdFx0dGhpcy5vbkV2aWN0aW9uKGtleSwgaXRlbS52YWx1ZSk7XG5cdFx0fVxuXHR9XG5cblx0X2RlbGV0ZUlmRXhwaXJlZChrZXksIGl0ZW0pIHtcblx0XHRpZiAodHlwZW9mIGl0ZW0uZXhwaXJ5ID09PSAnbnVtYmVyJyAmJiBpdGVtLmV4cGlyeSA8PSBEYXRlLm5vdygpKSB7XG5cdFx0XHRpZiAodHlwZW9mIHRoaXMub25FdmljdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR0aGlzLm9uRXZpY3Rpb24oa2V5LCBpdGVtLnZhbHVlKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuZGVsZXRlKGtleSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0X2dldE9yRGVsZXRlSWZFeHBpcmVkKGtleSwgaXRlbSkge1xuXHRcdGNvbnN0IGRlbGV0ZWQgPSB0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCBpdGVtKTtcblx0XHRpZiAoZGVsZXRlZCA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybiBpdGVtLnZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdF9nZXRJdGVtVmFsdWUoa2V5LCBpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0uZXhwaXJ5ID8gdGhpcy5fZ2V0T3JEZWxldGVJZkV4cGlyZWQoa2V5LCBpdGVtKSA6IGl0ZW0udmFsdWU7XG5cdH1cblxuXHRfcGVlayhrZXksIGNhY2hlKSB7XG5cdFx0Y29uc3QgaXRlbSA9IGNhY2hlLmdldChrZXkpO1xuXG5cdFx0cmV0dXJuIHRoaXMuX2dldEl0ZW1WYWx1ZShrZXksIGl0ZW0pO1xuXHR9XG5cblx0X3NldChrZXksIHZhbHVlKSB7XG5cdFx0dGhpcy5jYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG5cdFx0dGhpcy5fc2l6ZSsrO1xuXG5cdFx0aWYgKHRoaXMuX3NpemUgPj0gdGhpcy5tYXhTaXplKSB7XG5cdFx0XHR0aGlzLl9zaXplID0gMDtcblx0XHRcdHRoaXMuX2VtaXRFdmljdGlvbnModGhpcy5vbGRDYWNoZSk7XG5cdFx0XHR0aGlzLm9sZENhY2hlID0gdGhpcy5jYWNoZTtcblx0XHRcdHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG5cdFx0fVxuXHR9XG5cblx0X21vdmVUb1JlY2VudChrZXksIGl0ZW0pIHtcblx0XHR0aGlzLm9sZENhY2hlLmRlbGV0ZShrZXkpO1xuXHRcdHRoaXMuX3NldChrZXksIGl0ZW0pO1xuXHR9XG5cblx0KiBfZW50cmllc0FzY2VuZGluZygpIHtcblx0XHRmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5vbGRDYWNoZSkge1xuXHRcdFx0Y29uc3QgW2tleSwgdmFsdWVdID0gaXRlbTtcblx0XHRcdGlmICghdGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0XHRjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdmFsdWUpO1xuXHRcdFx0XHRpZiAoZGVsZXRlZCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHR5aWVsZCBpdGVtO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBpdGVtIG9mIHRoaXMuY2FjaGUpIHtcblx0XHRcdGNvbnN0IFtrZXksIHZhbHVlXSA9IGl0ZW07XG5cdFx0XHRjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdmFsdWUpO1xuXHRcdFx0aWYgKGRlbGV0ZWQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHlpZWxkIGl0ZW07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Z2V0KGtleSkge1xuXHRcdGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7XG5cdFx0XHRjb25zdCBpdGVtID0gdGhpcy5jYWNoZS5nZXQoa2V5KTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuX2dldEl0ZW1WYWx1ZShrZXksIGl0ZW0pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9sZENhY2hlLmhhcyhrZXkpKSB7XG5cdFx0XHRjb25zdCBpdGVtID0gdGhpcy5vbGRDYWNoZS5nZXQoa2V5KTtcblx0XHRcdGlmICh0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCBpdGVtKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy5fbW92ZVRvUmVjZW50KGtleSwgaXRlbSk7XG5cdFx0XHRcdHJldHVybiBpdGVtLnZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHNldChrZXksIHZhbHVlLCB7bWF4QWdlID0gdGhpcy5tYXhBZ2V9ID0ge30pIHtcblx0XHRjb25zdCBleHBpcnkgPVxuXHRcdFx0dHlwZW9mIG1heEFnZSA9PT0gJ251bWJlcicgJiYgbWF4QWdlICE9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgP1xuXHRcdFx0XHREYXRlLm5vdygpICsgbWF4QWdlIDpcblx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7XG5cdFx0XHR0aGlzLmNhY2hlLnNldChrZXksIHtcblx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdGV4cGlyeVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3NldChrZXksIHt2YWx1ZSwgZXhwaXJ5fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRoYXMoa2V5KSB7XG5cdFx0aWYgKHRoaXMuY2FjaGUuaGFzKGtleSkpIHtcblx0XHRcdHJldHVybiAhdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdGhpcy5jYWNoZS5nZXQoa2V5KSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub2xkQ2FjaGUuaGFzKGtleSkpIHtcblx0XHRcdHJldHVybiAhdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdGhpcy5vbGRDYWNoZS5nZXQoa2V5KSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cGVlayhrZXkpIHtcblx0XHRpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3BlZWsoa2V5LCB0aGlzLmNhY2hlKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vbGRDYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3BlZWsoa2V5LCB0aGlzLm9sZENhY2hlKTtcblx0XHR9XG5cdH1cblxuXHRkZWxldGUoa2V5KSB7XG5cdFx0Y29uc3QgZGVsZXRlZCA9IHRoaXMuY2FjaGUuZGVsZXRlKGtleSk7XG5cdFx0aWYgKGRlbGV0ZWQpIHtcblx0XHRcdHRoaXMuX3NpemUtLTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5vbGRDYWNoZS5kZWxldGUoa2V5KSB8fCBkZWxldGVkO1xuXHR9XG5cblx0Y2xlYXIoKSB7XG5cdFx0dGhpcy5jYWNoZS5jbGVhcigpO1xuXHRcdHRoaXMub2xkQ2FjaGUuY2xlYXIoKTtcblx0XHR0aGlzLl9zaXplID0gMDtcblx0fVxuXG5cdHJlc2l6ZShuZXdTaXplKSB7XG5cdFx0aWYgKCEobmV3U2l6ZSAmJiBuZXdTaXplID4gMCkpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2BtYXhTaXplYCBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwJyk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaXRlbXMgPSBbLi4udGhpcy5fZW50cmllc0FzY2VuZGluZygpXTtcblx0XHRjb25zdCByZW1vdmVDb3VudCA9IGl0ZW1zLmxlbmd0aCAtIG5ld1NpemU7XG5cdFx0aWYgKHJlbW92ZUNvdW50IDwgMCkge1xuXHRcdFx0dGhpcy5jYWNoZSA9IG5ldyBNYXAoaXRlbXMpO1xuXHRcdFx0dGhpcy5vbGRDYWNoZSA9IG5ldyBNYXAoKTtcblx0XHRcdHRoaXMuX3NpemUgPSBpdGVtcy5sZW5ndGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChyZW1vdmVDb3VudCA+IDApIHtcblx0XHRcdFx0dGhpcy5fZW1pdEV2aWN0aW9ucyhpdGVtcy5zbGljZSgwLCByZW1vdmVDb3VudCkpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm9sZENhY2hlID0gbmV3IE1hcChpdGVtcy5zbGljZShyZW1vdmVDb3VudCkpO1xuXHRcdFx0dGhpcy5jYWNoZSA9IG5ldyBNYXAoKTtcblx0XHRcdHRoaXMuX3NpemUgPSAwO1xuXHRcdH1cblxuXHRcdHRoaXMubWF4U2l6ZSA9IG5ld1NpemU7XG5cdH1cblxuXHQqIGtleXMoKSB7XG5cdFx0Zm9yIChjb25zdCBba2V5XSBvZiB0aGlzKSB7XG5cdFx0XHR5aWVsZCBrZXk7XG5cdFx0fVxuXHR9XG5cblx0KiB2YWx1ZXMoKSB7XG5cdFx0Zm9yIChjb25zdCBbLCB2YWx1ZV0gb2YgdGhpcykge1xuXHRcdFx0eWllbGQgdmFsdWU7XG5cdFx0fVxuXHR9XG5cblx0KiBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcblx0XHRmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5jYWNoZSkge1xuXHRcdFx0Y29uc3QgW2tleSwgdmFsdWVdID0gaXRlbTtcblx0XHRcdGNvbnN0IGRlbGV0ZWQgPSB0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCB2YWx1ZSk7XG5cdFx0XHRpZiAoZGVsZXRlZCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0eWllbGQgW2tleSwgdmFsdWUudmFsdWVdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLm9sZENhY2hlKSB7XG5cdFx0XHRjb25zdCBba2V5LCB2YWx1ZV0gPSBpdGVtO1xuXHRcdFx0aWYgKCF0aGlzLmNhY2hlLmhhcyhrZXkpKSB7XG5cdFx0XHRcdGNvbnN0IGRlbGV0ZWQgPSB0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCB2YWx1ZSk7XG5cdFx0XHRcdGlmIChkZWxldGVkID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdHlpZWxkIFtrZXksIHZhbHVlLnZhbHVlXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdCogZW50cmllc0Rlc2NlbmRpbmcoKSB7XG5cdFx0bGV0IGl0ZW1zID0gWy4uLnRoaXMuY2FjaGVdO1xuXHRcdGZvciAobGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuXHRcdFx0Y29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0Y29uc3QgW2tleSwgdmFsdWVdID0gaXRlbTtcblx0XHRcdGNvbnN0IGRlbGV0ZWQgPSB0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCB2YWx1ZSk7XG5cdFx0XHRpZiAoZGVsZXRlZCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0eWllbGQgW2tleSwgdmFsdWUudmFsdWVdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGl0ZW1zID0gWy4uLnRoaXMub2xkQ2FjaGVdO1xuXHRcdGZvciAobGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuXHRcdFx0Y29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0Y29uc3QgW2tleSwgdmFsdWVdID0gaXRlbTtcblx0XHRcdGlmICghdGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0XHRjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdmFsdWUpO1xuXHRcdFx0XHRpZiAoZGVsZXRlZCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHR5aWVsZCBba2V5LCB2YWx1ZS52YWx1ZV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQqIGVudHJpZXNBc2NlbmRpbmcoKSB7XG5cdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fZW50cmllc0FzY2VuZGluZygpKSB7XG5cdFx0XHR5aWVsZCBba2V5LCB2YWx1ZS52YWx1ZV07XG5cdFx0fVxuXHR9XG5cblx0Z2V0IHNpemUoKSB7XG5cdFx0aWYgKCF0aGlzLl9zaXplKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vbGRDYWNoZS5zaXplO1xuXHRcdH1cblxuXHRcdGxldCBvbGRDYWNoZVNpemUgPSAwO1xuXHRcdGZvciAoY29uc3Qga2V5IG9mIHRoaXMub2xkQ2FjaGUua2V5cygpKSB7XG5cdFx0XHRpZiAoIXRoaXMuY2FjaGUuaGFzKGtleSkpIHtcblx0XHRcdFx0b2xkQ2FjaGVTaXplKys7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIE1hdGgubWluKHRoaXMuX3NpemUgKyBvbGRDYWNoZVNpemUsIHRoaXMubWF4U2l6ZSk7XG5cdH1cblxuXHRlbnRyaWVzKCkge1xuXHRcdHJldHVybiB0aGlzLmVudHJpZXNBc2NlbmRpbmcoKTtcblx0fVxuXG5cdGZvckVhY2goY2FsbGJhY2tGdW5jdGlvbiwgdGhpc0FyZ3VtZW50ID0gdGhpcykge1xuXHRcdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuZW50cmllc0FzY2VuZGluZygpKSB7XG5cdFx0XHRjYWxsYmFja0Z1bmN0aW9uLmNhbGwodGhpc0FyZ3VtZW50LCB2YWx1ZSwga2V5LCB0aGlzKTtcblx0XHR9XG5cdH1cblxuXHRnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KFsuLi50aGlzLmVudHJpZXNBc2NlbmRpbmcoKV0pO1xuXHR9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/quick-lru/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-leaflet/lib/hooks.js":
/*!*************************************************!*\
  !*** ./node_modules/react-leaflet/lib/hooks.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMap: function() { return /* binding */ useMap; },\n/* harmony export */   useMapEvent: function() { return /* binding */ useMapEvent; },\n/* harmony export */   useMapEvents: function() { return /* binding */ useMapEvents; }\n/* harmony export */ });\n/* harmony import */ var _react_leaflet_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-leaflet/core */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/context.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n\nfunction useMap() {\n    return (0,_react_leaflet_core__WEBPACK_IMPORTED_MODULE_1__.useLeafletContext)().map;\n}\nfunction useMapEvent(type, handler) {\n    const map = useMap();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function addMapEventHandler() {\n        // @ts-ignore event type\n        map.on(type, handler);\n        return function removeMapEventHandler() {\n            // @ts-ignore event type\n            map.off(type, handler);\n        };\n    }, [\n        map,\n        type,\n        handler\n    ]);\n    return map;\n}\nfunction useMapEvents(handlers) {\n    const map = useMap();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function addMapEventHandlers() {\n        map.on(handlers);\n        return function removeMapEventHandlers() {\n            map.off(handlers);\n        };\n    }, [\n        map,\n        handlers\n    ]);\n    return map;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi9ob29rcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF3RDtBQUN0QjtBQUMzQjtBQUNQLFdBQVcsc0VBQWlCO0FBQzVCO0FBQ087QUFDUDtBQUNBLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi9ob29rcy5qcz9mM2NiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUxlYWZsZXRDb250ZXh0IH0gZnJvbSAnQHJlYWN0LWxlYWZsZXQvY29yZSc7XG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5leHBvcnQgZnVuY3Rpb24gdXNlTWFwKCkge1xuICAgIHJldHVybiB1c2VMZWFmbGV0Q29udGV4dCgpLm1hcDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VNYXBFdmVudCh0eXBlLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgbWFwID0gdXNlTWFwKCk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uIGFkZE1hcEV2ZW50SGFuZGxlcigpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBldmVudCB0eXBlXG4gICAgICAgIG1hcC5vbih0eXBlLCBoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZU1hcEV2ZW50SGFuZGxlcigpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgZXZlbnQgdHlwZVxuICAgICAgICAgICAgbWFwLm9mZih0eXBlLCBoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIG1hcCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgaGFuZGxlclxuICAgIF0pO1xuICAgIHJldHVybiBtYXA7XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlTWFwRXZlbnRzKGhhbmRsZXJzKSB7XG4gICAgY29uc3QgbWFwID0gdXNlTWFwKCk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uIGFkZE1hcEV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIG1hcC5vbihoYW5kbGVycyk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiByZW1vdmVNYXBFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICAgICAgbWFwLm9mZihoYW5kbGVycyk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBtYXAsXG4gICAgICAgIGhhbmRsZXJzXG4gICAgXSk7XG4gICAgcmV0dXJuIG1hcDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-leaflet/lib/hooks.js\n"));

/***/ })

}]);